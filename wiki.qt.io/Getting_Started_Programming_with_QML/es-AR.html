<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/Getting_Started_Programming_with_QML/es-AR by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 07:57:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>Getting Started Programming with QML/es-AR - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<link rel="shortcut icon" href="../favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="../opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="../api251f.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="../apidf90.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="../load771b.css?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="../loadc6d2.css?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="../load8478.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Getting_Started_Programming_with_QML/es-AR","wgTitle":"Getting Started Programming with QML/es-AR","wgCurRevisionId":16512,"wgRevisionId":16512,"wgArticleId":836,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Articles needing cleanup","Learning"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Getting_Started_Programming_with_QML/es-AR","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp-qt {line-height: normal;}
.source-cpp-qt li, .source-cpp-qt pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp-qt
 * CSS class: source-cpp-qt, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp-qt.source-cpp-qt .de1, .cpp-qt.source-cpp-qt .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.cpp-qt.source-cpp-qt  {font-family:monospace;}
.cpp-qt.source-cpp-qt .imp {font-weight: bold; color: red;}
.cpp-qt.source-cpp-qt li, .cpp-qt.source-cpp-qt .li1 {font-weight: normal; vertical-align:top;}
.cpp-qt.source-cpp-qt .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp-qt.source-cpp-qt .li2 {font-weight: bold; vertical-align:top;}
.cpp-qt.source-cpp-qt .kw1 {color: #000000; font-weight:bold;}
.cpp-qt.source-cpp-qt .kw2 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .kw4 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw5 {color: #22aadd;}
.cpp-qt.source-cpp-qt .co1 {color: #888888;}
.cpp-qt.source-cpp-qt .co2 {color: #006E28;}
.cpp-qt.source-cpp-qt .coMULTI {color: #888888; font-style: italic;}
.cpp-qt.source-cpp-qt .es0 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es1 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es2 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es3 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es4 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es5 {color: #006699; font-weight: bold;}
.cpp-qt.source-cpp-qt .br0 {color: #006E28;}
.cpp-qt.source-cpp-qt .sy0 {color: #006E28;}
.cpp-qt.source-cpp-qt .st0 {color: #BF0303;}
.cpp-qt.source-cpp-qt .nu0 {color: #B08000;}
.cpp-qt.source-cpp-qt .nu6 {color: #208080;}
.cpp-qt.source-cpp-qt .nu8 {color: #208080;}
.cpp-qt.source-cpp-qt .nu12 {color: #208080;}
.cpp-qt.source-cpp-qt .nu16 {color:#800080;}
.cpp-qt.source-cpp-qt .nu17 {color:#800080;}
.cpp-qt.source-cpp-qt .nu18 {color:#800080;}
.cpp-qt.source-cpp-qt .nu19 {color:#800080;}
.cpp-qt.source-cpp-qt .me1 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me2 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .ln-xtra, .cpp-qt.source-cpp-qt li.ln-xtra, .cpp-qt.source-cpp-qt div.ln-xtra {background-color: #ffc;}
.cpp-qt.source-cpp-qt span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Getting_Started_Programming_with_QML_es-AR skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Getting Started Programming with QML/es-AR</span></h1>
						<div id="bodyContent">
								<div id="siteSub">From Qt Wiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table style="center; margin: -1px auto 0px;border: 1px solid rgb(127, 194, 66); border-left: 10px solid rgb(127, 194, 66); background:rgb(250,250,250); width:600px">

<tr>
<td style="padding: 0.25em 0.5em;"> <b>This article may require cleanup to meet the Qt Wiki's quality standards.</b> Reason: Auto-imported from ExpressionEngine.<br /><small>Please <b><a rel="nofollow" class="external text" href="../index1964.html?title=Getting_Started_Programming_with_QML/es-AR&amp;action=edit">improve this article</a></b> if you can. Remove the {{cleanup}} tag and add this page to <b><a href="../Updated_pages.html" title="Updated pages">Updated pages</a></b> list after it's clean.</small>
</td></tr></table>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Comenzando_a_Programar_con_QML"><span class="tocnumber">1</span> <span class="toctext">Comenzando a Programar con QML</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#QML_para_Armar_Interfaces_de_Usuario"><span class="tocnumber">1.1</span> <span class="toctext">QML para Armar Interfaces de Usuario</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Definiendo_un_Bot.C3.B3n_y_un_Men.C3.BA"><span class="tocnumber">1.2</span> <span class="toctext">Definiendo un Botón y un Menú</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Componente_B.C3.A1sico_-_un_Bot.C3.B3n"><span class="tocnumber">1.3</span> <span class="toctext">Componente Básico - un Botón</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Creando_una_P.C3.A1gina_de_Men.C3.BA"><span class="tocnumber">1.4</span> <span class="toctext">Creando una Página de Menú</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Implementando_una_Barra_de_Men.C3.BA"><span class="tocnumber">1.5</span> <span class="toctext">Implementando una Barra de Menú</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Usando_Modelos_de_Datos_y_Vistas"><span class="tocnumber">1.6</span> <span class="toctext">Usando Modelos de Datos y Vistas</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Armando_un_Editor_de_Texto"><span class="tocnumber">1.7</span> <span class="toctext">Armando un Editor de Texto</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Declarando_un_elemento_TextArea"><span class="tocnumber">1.8</span> <span class="toctext">Declarando un elemento TextArea</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Combinando_Componentes_para_el_Editor_de_Texto"><span class="tocnumber">1.9</span> <span class="toctext">Combinando Componentes para el Editor de Texto</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Decorando_el_Editor_de_Texto"><span class="tocnumber">1.10</span> <span class="toctext">Decorando el Editor de Texto</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Implementando_una_Interface_Caj.C3.B3n"><span class="tocnumber">1.11</span> <span class="toctext">Implementando una Interface Cajón</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#A_d.C3.B3nde_ir_desde_Aqu.C3.AD"><span class="tocnumber">1.12</span> <span class="toctext">A dónde ir desde Aquí</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Extendiendo_QML_al_usar_Qt_C.2B.2B"><span class="tocnumber">1.13</span> <span class="toctext">Extendiendo QML al usar Qt C++</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Exponiendo_Clases_C.2B.2B_a_QML"><span class="tocnumber">1.14</span> <span class="toctext">Exponiendo Clases C++ a QML</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Construyendo_un_complemento_Qt"><span class="tocnumber">1.15</span> <span class="toctext">Construyendo un complemento Qt</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Registrando_una_Clase_en_QML"><span class="tocnumber">1.16</span> <span class="toctext">Registrando una Clase en QML</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Creando_Propiedades_QML_en_una_clase_C.2B.2B"><span class="tocnumber">1.17</span> <span class="toctext">Creando Propiedades QML en una clase C++</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Importando_un_Complemento_en_QML"><span class="tocnumber">1.18</span> <span class="toctext">Importando un Complemento en QML</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Integrando_un_Di.C3.A1logo_Archivo_en_el_Men.C3.BA_Archivo"><span class="tocnumber">1.19</span> <span class="toctext">Integrando un Diálogo Archivo en el Menú Archivo</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Finalizaci.C3.B3n_del_Editor_de_Texto"><span class="tocnumber">1.20</span> <span class="toctext">Finalización del Editor de Texto</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Comenzando_a_Programar_con_QML">Comenzando a Programar con QML</span></h2>
<p>Bienvenido al mundo de QML, el lenguaje declarativo para Interfaces de Usuario (IU). En esta guía Comenzar a Programar, crearemos una simple aplicación para editar textos usando QML. Luego de leer esta guía, deberías estar listo para desarrollar tus propias aplicaciones usando QML y Qt C+<i>.</i>
</p>
<h3><span class="mw-headline" id="QML_para_Armar_Interfaces_de_Usuario">QML para Armar Interfaces de Usuario</span></h3>
<p>La aplicación que estamos armando es un simple editor de texto que cargará, guardará y realizará alguna manipulación de texto. Esta guía consiste de dos partes. La primera parte involucrará desarrollar el diseño de la aplicación y los comportamientos usando lenguaje declarativo en QML. Para la segunda parte, cargar y guardar el archivo serán implementados usando Qt C. Al usar el <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/metaobjects.html">Sistema de Meta-Objetos de Qt</a>, podemos exponer funciones de C<i>+ como propiedades que los elementos de QML pueden usar. Usando QML y Qt C++ podemos desacoplar de manera eficiente la lógica de la interface de la lógica de la aplicación.</i>
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor5_editmenu.png" alt="qml-texteditor5_editmenu.png" />
</p><p>Para ejecutar el código QML de ejemplo, simplemente provee a la herramienta incluida <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qmlviewer.html">qmlviewer</a> el nombre del archivo QML como argumento. La parte de C++ de este tutorial asume que el lector posee conocimiento básico de los procedimientos de compilación de Qt.
</p><p>Capítulos del Tutorial:
</p>
<ol>
<li> Definiendo un Botón y un Menú
</li>
<li> Implementando una Barra de Menú
</li>
<li> Armando un Editor de Texto
</li>
<li> Decorando un Editor de Texto
</li>
<li> Extendiendo QML al usar Qt C++
</li>
</ol>
<h3><span class="mw-headline" id="Definiendo_un_Bot.C3.B3n_y_un_Men.C3.BA">Definiendo un Botón y un Menú</span></h3>
<h3><span class="mw-headline" id="Componente_B.C3.A1sico_-_un_Bot.C3.B3n">Componente Básico - un Botón</span></h3>
<p>Comenzamos nuestro editor de texto armando un botón. Funcionalmente un butón tiene un área sensible al ratón (<i>mousse</i>) y una etiqueta. Los botones realizan acciones cuando un usuario presiona el botón.
</p><p>En QML, el ítem visual básico es el elemento <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qml-rectangle.html">Rectangle</a>. El elemento Rectangle tiene propiedades para controlar la apariencia del elemento y su ubicación.
</p><p>Primero, la instrucción import Qt 4.7 permite que la herramienta qmlviewer importe los elementos que usaremos luego. Esta línea debe existir en cada archivo QML. Tener presente que la versión de los módulos Qt se incluye en la instrucción import.
</p><p>Este simple rectángulo tiene un identificador unívoco, simplebutton, el cual está ligado a la propiedad id. Las propiedades del elemento Rectangle están ligadas a valores al listar la propiedad, seguidos por dos puntos, luego el valor. En el código de ejemplo, el color gris está ligado a la propiedad color del elemento Rectangle. De manera similar, ligamos el ancho y alto del elemento Rectangle.
</p><p>El elemento Text es un campo de texto de sólo lectura (no editable). Nombramos a este elemento Text buttonLabel. Para establecer el contenido de la cadena de caracteres de este campo Texto, ligamos un valor a la propiedad text. La etiqueta está contenida dentro del elemento Rectangle y para centrarla, asignamos las anclas del elemento Text a su padre, el cual se llama simplebutton. Las anclas pueden ligarse a las anclas de otros ítems, de esa forma facilitando las asignaciones de diseño.
</p><p>Guardamos este código como SimpleButton.qml. Ejecutando qmlviewer con el nombre del archivo como argumento mostrará el rectángulo gris con la etiqueta de texto.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor1_simplebutton.png" alt="qml-texteditor1_simplebutton.png" />
</p><p>Para implementar la funcionalidad del click del botón, podemos usar el manejo de eventos de QML. El manejo de eventos de QML es muy similar al mecanismo de <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/signalsandslots.html">señales y ranuras de Qt</a>. Se emiten señales y las ranuras conectadas son invocadas.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">Rectangle<span class="br0">&#123;</span>
 id<span class="sy0">:</span>simplebutton
 …
&#160;
MouseArea<span class="br0">&#123;</span>
 id<span class="sy0">:</span> buttonMouseArea
&#160;
anchors.<span class="me1">fill</span><span class="sy0">:</span> parent <span class="co1">//anchor all sides of the mouse area to the rectangle's anchors</span>
 <span class="co1">//onClicked handles valid mouse button clicks</span>
 onClicked<span class="sy0">:</span> console.<span class="kw3">log</span><span class="br0">&#40;</span>buttonLabel.<span class="me1">text</span> <span class="sy0">+</span> <span class="st0">&quot; clicked&quot;</span> <span class="br0">&#41;</span>
 <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Incluimos un elemento <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qml-mousearea.html">MouseArea</a> (área del ratón) n nuestro simplebutton. Los elementos <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qml-mousearea.html">MouseArea</a> describen el área interactiva donde se detectan los movimientos del ratón. Para nuestro botón, anclamos el elemento MouseArea completo a su padre, el cual es simplebutton. La sintaxis anchors.fill es una manera de acceder a una propiedad específica llamada fill dentro de un grupo de propiedades llamado anchors. QML usa <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qml-anchor-layout.html">diseños basados en anclas</a> donde los ítems pueden anclarse unos a otros, creando diseños robustos.
</p><p>El elemento MouseArea tiene muchos manejadores de señales que se llaman durante los movimientos del ratón dentro de los límites especificados para el elemento MouseArea. Uno de ellos es onClicked y se llama cada vez que el botón apropiado del ratón se pulsa, siendo el izquierdo el valor por omisión. Podemos ligar acciones al manipulador onClicked. En nuestro ejemplo, console.log() muestra texto siempre que se hace click en el área del ratón. La función console.log() es una herramienta útil para propósitos de depuración (debugging) y para mostrar texto.
</p><p>El código en SimpleButton.qml es suficiente para mostrar un botón en la pantalla y emitir texto cuando se selecciona mediante un click con el ratón.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> Rectangle <span class="br0">&#123;</span>
 id<span class="sy0">:</span>Button
 …
&#160;
property color buttonColor<span class="sy0">:</span> <span class="st0">&quot;lightblue&quot;</span>
 property color onHoverColor<span class="sy0">:</span> <span class="st0">&quot;gold&quot;</span>
 property color borderColor<span class="sy0">:</span> <span class="st0">&quot;white&quot;</span>
&#160;
<span class="kw4">signal</span> buttonClick<span class="br0">&#40;</span><span class="br0">&#41;</span>
 onButtonClick<span class="sy0">:</span> <span class="br0">&#123;</span>
 console.<span class="kw3">log</span><span class="br0">&#40;</span>buttonLabel.<span class="me1">text</span> <span class="sy0">+</span> <span class="st0">&quot; clicked&quot;</span> <span class="br0">&#41;</span>
 <span class="br0">&#125;</span>
&#160;
MouseArea<span class="br0">&#123;</span>
 onClicked<span class="sy0">:</span> buttonClick<span class="br0">&#40;</span><span class="br0">&#41;</span>
 hoverEnabled<span class="sy0">:</span> <span class="kw2">true</span>
 onEntered<span class="sy0">:</span> parent.<span class="me1">border</span>.<span class="me1">color</span> <span class="sy0">=</span> onHoverColor
 onExited<span class="sy0">:</span> parent.<span class="me1">border</span>.<span class="me1">color</span> <span class="sy0">=</span> borderColor
 <span class="br0">&#125;</span>
&#160;
<span class="co1">//determines the color of the button by using the conditional operator</span>
 color<span class="sy0">:</span> buttonMouseArea.<span class="me1">pressed</span>&#160;? <span class="kw5">Qt</span>.<span class="me1">darker</span><span class="br0">&#40;</span>buttonColor<span class="sy0">,</span> <span class="nu16">1.5</span><span class="br0">&#41;</span> <span class="sy0">:</span> buttonColor
 <span class="br0">&#125;</span></pre></div></div>
<p>Un botón completamente funcional está en Button.qml. Los fragmentos de código en este artículo tienen partes del código omitidas, denotadas por puntos suspensivos porque ellas fueron ya sea presentadas en secciones previas o no son relevantes para la discusión actual del código.
</p><p>Las propiedades Custom se declaran usando la sintaxis property type. En el código, la propiedad buttonColor, de tipo color, se declara y liga al valor "lightblue" (celeste). buttonColor se usa más adelante en una operación condicional para determinar el color de relleno del botón. Notar que la asignación de valor a la propiedad es posible usando el signo = (igual), además de ligar el valor usando el caracter ':' (dos puntos). Las propiedades Custom permiten acceder a ítems internos fuera del alcance del elemento Rectangle. Hay tipos básicos de QML tales como int, string, real, como también un tipo llamado variant.
</p><p>Al vincular los manejadores de señales onEntered y onExited a colores, el borde del botón se volverá amarillo cuando el mouse pase sobre el botón y volverá al otro color cuando el ratón salga del área del ratón.
</p><p>Una señal buttonClick() se declara en Button.qml al colocar la palabra clave signal delante del nombre de la señal. Todas las señales tienen sus manejadores creados automáticamente, con sus nombres comenzando con el prefijo on. Como resultado, onButtonClick es el manejador de buttonClick. Luego onButtonClick se asigna a una acción para que sea llevada a cabo. En nuestro botón de ejemplo, el manejador onClicked del ratón simplemente invocará onButtonClick, el cual muestra un texto. onButtonClick permite que objetos externos accedan al área del ratón del elemento Button de manera sencilla. Por ejemplo, los ítems pueden tener más de una declaración MouseArea y una señal buttonClick puede hacer una mejor distinción entre los distintos manejadores de señal para MouseArea.
</p><p>Ahora tenemos el conocimiento básico para implementar ítems en QML que pueden manejar movimientos básicos del ratón. Creamos una etiqueta Text dentro de un elemento Rectangle, ajustamos sus propiedades, e implementamos comportamientos que responden a movimientos del ratón. Esta idea de crear elementos dentro de elementos se repite a través de la aplicación del editor de texto.
</p><p>Este botón no es útil a menos que se use como un componente para realizar una acción. En la próxima sección, pronto crearemos un menú conteniendo varios de estos botones.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor1_button.png" alt="qml-texteditor1_button.png" />
</p>
<h3><span class="mw-headline" id="Creando_una_P.C3.A1gina_de_Men.C3.BA">Creando una Página de Menú</span></h3>
<p>Hasta este momento, hemos cubierto como crear elementos y asignar comportamientos dentro de un único archivo QML. En esta sección, cubriremos ccomo importar elementos QML y como reusar algunos de los componentes creados para armar otros componentes.
</p><p>Los menúes muestran el contenido de una lista, con cada ítem teniendo la capacidad de realizar una acción. En QML, podemos crear un menú de varias formas. Primero, crearemos un menú que contiene botones los cuales eventualmente realizarán diferentes acciones.
El código del menú está en FileMenu.qml.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">import <span class="kw5">Qt</span> <span class="nu16">4.7</span> import the main <span class="kw5">Qt</span> QML module
import <span class="st0">&quot;folderName&quot;</span> import the contents of the folder
import <span class="st0">&quot;script.js&quot;</span> as Script import a Javascript file and name it as Script</pre></div></div>
<p>La sintaxis arriba muestra como usar la palabra reservada import. Esto se requiere para usar archivos JavaScript, o archivos QML que no están en el mismo directorio. Ya que Button.qml está en el mismo directorio que FileMenu.qml, no necesitamos importar el archivo Button.qml para usarlo. Directamente podemos crear un elemento Button declarando Button{}, de manera similar a la declaración Rectangle{}.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In FileMenu.<span class="me1">qml</span><span class="sy0">:</span>
&#160;
Row<span class="br0">&#123;</span>
 anchors.<span class="me1">centerIn</span><span class="sy0">:</span> parent
 spacing<span class="sy0">:</span> parent.<span class="me1">width</span><span class="sy0">/</span><span class="nu0">6</span>
&#160;
Button<span class="br0">&#123;</span>
 id<span class="sy0">:</span> loadButton
 buttonColor<span class="sy0">:</span> <span class="st0">&quot;lightgrey&quot;</span>
 label<span class="sy0">:</span> <span class="st0">&quot;Load&quot;</span>
 <span class="br0">&#125;</span>
 Button<span class="br0">&#123;</span>
 buttonColor<span class="sy0">:</span> <span class="st0">&quot;grey&quot;</span>
 id<span class="sy0">:</span> saveButton
 label<span class="sy0">:</span> <span class="st0">&quot;Save&quot;</span>
 <span class="br0">&#125;</span>
 Button<span class="br0">&#123;</span>
 id<span class="sy0">:</span> exitButton
 label<span class="sy0">:</span> <span class="st0">&quot;Exit&quot;</span>
 buttonColor<span class="sy0">:</span> <span class="st0">&quot;darkgrey&quot;</span>
&#160;
onButtonClick<span class="sy0">:</span> <span class="kw5">Qt</span>.<span class="me1">quit</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>En FileMenu.qml, declaramos tres elementos Button. Se declaran dentro de un elemeto Row, un posicionador que ubicará sus hijos en una fila vertical. La declaración Button permanece en Button.qml, que es el mismo que el archivo Button.qml que usamos previamente. Pueden declararse nuevas vinculaciones a propiedades dentro de los nuevos botones creados, sobreescribiendo efectivamente las propiedades establecidas en Button.qml. El botón exitButton terminará y cerrará la ventana cuando sea seleccionado. Notar que el manejador de señal onButtonClick en Button.qml será llamado además del manejador onButtonClick en exitButton.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor1_filemenu.png" alt="qml-texteditor1_filemenu.png" />
</p><p>La declaración Row se realiza en un elemento Rectangle, creando un rectágulo contenedor para la fila de botones. Este rectángulo adicional crea una manera indirecta de organizar la fila de botones dentro de un menú.
</p><p>La declaración del menu editar es muy similar a esta etapa. El menú tiene botones con las etiquetas: Copiar, Pegar y Seleccionar Todo.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor1_editmenu.png" alt="qml-texteditor1_editmenu.png" />
</p><p>Armados con nuestro conocimiento de importar y customizing componentes creados previamente, ahora podemos combinar estas páginas de menu para crear una barra de menú, que consiste de botones para seleccionar el menú, y mirar como podemos estructurar los datos usando QML.
</p>
<h3><span class="mw-headline" id="Implementando_una_Barra_de_Men.C3.BA">Implementando una Barra de Menú</span></h3>
<p>Nuestra aplicación de editor de texto necesitará una manera de mostrar los menúes usando una barra de menú. La barra de menú cambiará los diferentes menues y el usuario puede elegir qué menú mostrar. El cambio de menúes implica que los menúes necesitan más estructura que meramente mostrarlos en una fila. QML usa modelos y vistas para estructurar los datos y mostrar los datos estructurados.
</p>
<h3><span class="mw-headline" id="Usando_Modelos_de_Datos_y_Vistas">Usando Modelos de Datos y Vistas</span></h3>
<p>QML tiene diferentes vistas de datos que muestran modelos de datos. Nuestra barra de menú mostrará los menúes en una lista, con un encabezado que muestra una fila de los nombres de los menúes. La lista de menúes se declaran dentro de un elemento VisualItemModel. El elemento VisualItemModel contiene ítems que ya tienen vistas tales como elementos Rectangle y elementos importados de la IU. Otros tipos de modelos tales como el elemento ListModel necesitan un delegado para mostrar sus datos.
</p><p>Declaramos dos ítems visuales en el elemento menuListModel, el ítem FileMenu y el ítem EditMenu. Personalizamos los dos menúes y los mostramos usando un elemento ListView. El archivo MenuBar.qml file contiene las declaraciones QML y un menú simple para editar se define en el archivo EditMenu.qml.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">VisualItemModel<span class="br0">&#123;</span>
 id<span class="sy0">:</span> menuListModel
 FileMenu<span class="br0">&#123;</span>
 width<span class="sy0">:</span> menuListView.<span class="me1">width</span>
 height<span class="sy0">:</span> menuBar.<span class="me1">height</span>
 color<span class="sy0">:</span> fileColor
 <span class="br0">&#125;</span>
 EditMenu<span class="br0">&#123;</span>
 color<span class="sy0">:</span> editColor
 width<span class="sy0">:</span> menuListView.<span class="me1">width</span>
 height<span class="sy0">:</span> menuBar.<span class="me1">height</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>El elemento ListView mostrará un modelo de acuerdo a un delegado. El delegado puede declarar los ítems del modelo a mostrar en un elemento Row o mostrar los ítems en una grilla. Nuestro menuListModel ya tiene ítems visible, y de ese modo, no necesitamos declarar un delegado.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">ListView<span class="br0">&#123;</span>
 id<span class="sy0">:</span> menuListView
&#160;
<span class="co1">//Anchors are set to react to window anchors</span>
 anchors.<span class="me1">fill</span><span class="sy0">:</span>parent
 anchors.<span class="me1">bottom</span><span class="sy0">:</span> parent.<span class="me1">bottom</span>
 width<span class="sy0">:</span>parent.<span class="me1">width</span>
 height<span class="sy0">:</span> parent.<span class="me1">height</span>
&#160;
<span class="co1">//the model contains the data</span>
 model<span class="sy0">:</span> menuListModel
&#160;
<span class="co1">//control the movement of the menu switching</span>
 snapMode<span class="sy0">:</span> ListView.<span class="me1">SnapOneItem</span>
 orientation<span class="sy0">:</span> ListView.<span class="me1">Horizontal</span>
 boundsBehavior<span class="sy0">:</span> Flickable.<span class="me1">StopAtBounds</span>
 flickDeceleration<span class="sy0">:</span> <span class="nu0">5000</span>
 highlightFollowsCurrentItem<span class="sy0">:</span> <span class="kw2">true</span>
 highlightMoveDuration<span class="sy0">:</span><span class="nu0">240</span>
 highlightRangeMode<span class="sy0">:</span> ListView.<span class="me1">StrictlyEnforceRange</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Adicionalmente, ListView hereda de Flickable, haciendo que la lista responda a arrastres del ratón y otros gestos. La última parte del código arriba ajustas propiedades del elemento Flickable para crear en nuestra vista el movimiento de parpadeo deseado. En particular, la propiedad highlightMoveDuration cambia la duración de la transición de parpadeo. Un valor highlightMoveDuration mayor resulta en un cambio de menú más lento.
</p><p>El elemento ListView mantiene los ítems del modelo a través de un índice y cada ítem visual en el modelo es accesible a través del índice, en el orden de declaración. Cambiar el valor de currentIndex efectivamente cambia el ítem resaltado en el elemento ListView. El encabezado de nuestra barra de menú ejemplifica este efecto. Hay dos botones en una fila, ambos cambiando el menú actual cuando son seleccionados. El elemento fileButton cambia el menú actual al menú archivo cuando se selecciona, y el índice es 0 porque FileMenu se declaró primero en menuListModel. De manera similar, editButton cambiará el menú actual a EditMenu cuando se seleccione.
</p><p>El rectángulo labelList tiene un valor z de 1, denotando que se muestra al frente de la barra de menú. Ítems con valores z mayores se muestran al frente de ítems con valores z menores. El valor de z por omisión es 0.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">Rectangle<span class="br0">&#123;</span>
 id<span class="sy0">:</span> labelList
 …
 z<span class="sy0">:</span> <span class="nu0">1</span>
 Row<span class="br0">&#123;</span>
 anchors.<span class="me1">centerIn</span><span class="sy0">:</span> parent
 spacing<span class="sy0">:</span><span class="nu0">40</span>
 Button<span class="br0">&#123;</span>
 label<span class="sy0">:</span> <span class="st0">&quot;File&quot;</span>
 id<span class="sy0">:</span> fileButton
 …
 onButtonClick<span class="sy0">:</span> menuListView.<span class="me1">currentIndex</span> <span class="sy0">=</span> <span class="nu0">0</span>
 <span class="br0">&#125;</span>
 Button<span class="br0">&#123;</span>
 id<span class="sy0">:</span> editButton
 label<span class="sy0">:</span> <span class="st0">&quot;Edit&quot;</span>
 …
 onButtonClick<span class="sy0">:</span> menuListView.<span class="me1">currentIndex</span> <span class="sy0">=</span> <span class="nu0">1</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>La barra de menú que hemos creado puede tener parpadeo para acceder a los menúes o al hacer click sobre los nombres del menú en la parte superior. El cambio de pantallas de menúes se siente intuitivo y con respuesta.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor2_menubar.png" alt="qml-texteditor2_menubar.png" />
</p>
<h3><span class="mw-headline" id="Armando_un_Editor_de_Texto">Armando un Editor de Texto</span></h3>
<h3><span class="mw-headline" id="Declarando_un_elemento_TextArea">Declarando un elemento TextArea</span></h3>
<p>Nuestro editor de texto no es un editor de texto si no contiene un área de texto que se pueda editar. El elemento TextEdit de QML permite la declaración de un área de texto editable multi-línea. TextEdit es diferente de un elemento Text, el cual no permite que el usuario edite directamente el texto.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> TextEdit<span class="br0">&#123;</span>
 id<span class="sy0">:</span> textEditor
 anchors.<span class="me1">fill</span><span class="sy0">:</span>parent
 width<span class="sy0">:</span>parent.<span class="me1">width</span><span class="sy0">;</span> height<span class="sy0">:</span>parent.<span class="me1">height</span>
 color<span class="sy0">:</span><span class="st0">&quot;midnightblue&quot;</span>
 focus<span class="sy0">:</span> <span class="kw2">true</span>
&#160;
wrapMode<span class="sy0">:</span> TextEdit.<span class="me1">Wrap</span>
&#160;
onCursorRectangleChanged<span class="sy0">:</span> flickArea.<span class="me1">ensureVisible</span><span class="br0">&#40;</span>cursorRectangle<span class="br0">&#41;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>El editor tiene su propiedad color de fuente establecida y también para wrap el texto. El área TextEdit está dentro de un área parpadeante que se desplazará si el cursor de texto está fuera del área visible. La función ensureVisible() comprobará si el rectángulo del cursor está fuera de los límites visibles y moverá el área de texto de manera apropiada. QML usa sintaxis de Javascript para sus secuencias de comandos (scripts), y como se mencionó anteriormente, pueden importarse archivos Javascript y ser usados dentro de un archivo QML.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> function ensureVisible®<span class="br0">&#123;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span>contentX <span class="sy0">&gt;=</span> r.<span class="me1">x</span><span class="br0">&#41;</span>
 contentX <span class="sy0">=</span> r.<span class="me1">x</span><span class="sy0">;</span>—
 <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>contentX<span class="sy0">+</span>width <span class="sy0">&lt;=</span> r.<span class="me1">x</span><span class="sy0">+</span>r.<span class="me1">width</span><span class="br0">&#41;</span>
 contentX <span class="sy0">=</span> r.<span class="me1">x</span><span class="sy0">+</span>r.<span class="me1">width</span><span class="sy0">-</span>width<span class="sy0">;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span>contentY <span class="sy0">&gt;=</span> r.<span class="me1">y</span><span class="br0">&#41;</span>
 contentY <span class="sy0">=</span> r.<span class="me1">y</span><span class="sy0">;</span>
 <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>contentY<span class="sy0">+</span>height <span class="sy0">&lt;=</span> r.<span class="me1">y</span><span class="sy0">+</span>r.<span class="me1">height</span><span class="br0">&#41;</span>
 contentY <span class="sy0">=</span> r.<span class="me1">y</span><span class="sy0">+</span>r.<span class="me1">height</span><span class="sy0">-</span>height<span class="sy0">;</span>
 <span class="br0">&#125;</span></pre></div></div>
<h3><span class="mw-headline" id="Combinando_Componentes_para_el_Editor_de_Texto">Combinando Componentes para el Editor de Texto</span></h3>
<p>Estamos listos para crear el diseño de nuestro editor de texto usando QML. El editor de texto tiene dos componentes, la barra de menú que creamos y el área de texto. QML nos permite reusar componentes, y así, hacer nuestro código más simple, al importar componentes y personalizarlos cuando sea necesario. Nuestro editor de texto divide la ventana en dos; un tercio de la pantalla se dedica a la barra de menú y dos tercios de la pantalla muestran el área de texto. La barra de menú se muestra en frente de cualquier otro elemento.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> Rectangle<span class="br0">&#123;</span>
&#160;
id<span class="sy0">:</span> screen
 width<span class="sy0">:</span> <span class="nu0">1000</span><span class="sy0">;</span> height<span class="sy0">:</span> <span class="nu0">1000</span>
&#160;
<span class="co1">//the screen is partitioned into the MenuBar and TextArea. 1/3 of the screen is assigned to the MenuBar</span>
 property <span class="kw4">int</span> partition<span class="sy0">:</span> height<span class="sy0">/</span><span class="nu0">3</span>
&#160;
MenuBar<span class="br0">&#123;</span>
 id<span class="sy0">:</span>menuBar
 height<span class="sy0">:</span> partition
 width<span class="sy0">:</span>parent.<span class="me1">width</span>
 z<span class="sy0">:</span> <span class="nu0">1</span>
 <span class="br0">&#125;</span>
&#160;
TextArea<span class="br0">&#123;</span>
 id<span class="sy0">:</span>textArea
 anchors.<span class="me1">bottom</span><span class="sy0">:</span>parent.<span class="me1">bottom</span>
 y<span class="sy0">:</span> partition
 color<span class="sy0">:</span> <span class="st0">&quot;white&quot;</span>
 height<span class="sy0">:</span> partition<span class="sy0">*</span><span class="nu0">2</span>
 width<span class="sy0">:</span>parent.<span class="me1">width</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Al importar componentes reutilizables, nuestro código TextEditor luce mucho más simple. Podemos entonces personalizar la aplicación principal, sin preocuparnos acerca de las propiedades que ya han definido comportamientos. Usando esta aproximación, los diseños de aplicaciones y componentes de IU se pueden crear fácilmente.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor3_texteditor.png" alt="qml-texteditor3_texteditor.png" />
</p>
<h3><span class="mw-headline" id="Decorando_el_Editor_de_Texto">Decorando el Editor de Texto</span></h3>
<h3><span class="mw-headline" id="Implementando_una_Interface_Caj.C3.B3n">Implementando una Interface Cajón</span></h3>
<p>Nuestro editor de texto luce simple y necesitamos decorarlo. Usando QML, podemos declarar transiciones y animar nuestro editor de texto. Nuestra barra de menú está ocupando un tercio de la pantalla y sería bueno hacerla aparecer cuando querramos.
</p><p>Podemos agregar una interface cajón, que contraerá o expandirá la barra de menú cuando se haga click sobre ella. En nuestra implementación, tenemos un rectángulo delgado que responde a los clicks del ratón. El cajón, como también la aplicación, tienen dos estados: el estado "cajón está abierto" y el estado "cajón está cerrado". El ítem cajón es una tira de un rectángulo con una altura pequeña. Hay un elemento Image anidado que declara que un ícono de una flecha será centrado dentro del cajón. El cajón asigna un estado a toda la aplicación, con el identificador screen, siempre que un usuario hace click en el área del ratón.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> Rectangle<span class="br0">&#123;</span>
 id<span class="sy0">:</span>drawer
 height<span class="sy0">:</span><span class="nu0">15</span>
&#160;
Image<span class="br0">&#123;</span>
 id<span class="sy0">:</span> arrowIcon
 source<span class="sy0">:</span> <span class="st0">&quot;images/arrow.png&quot;</span>
 anchors.<span class="me1">horizontalCenter</span><span class="sy0">:</span> parent.<span class="me1">horizontalCenter</span>
 <span class="br0">&#125;</span>
&#160;
MouseArea<span class="br0">&#123;</span>
 id<span class="sy0">:</span> drawerMouseArea
 anchors.<span class="me1">fill</span><span class="sy0">:</span>parent
 onClicked<span class="sy0">:</span><span class="br0">&#123;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span>screen.<span class="me1">state</span>  <span class="st0">&quot;DRAWER_CLOSED&quot;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
                     screen.<span class="me1">state</span> <span class="sy0">=</span> <span class="st0">&quot;DRAWER_OPEN&quot;</span>
                 <span class="br0">&#125;</span>
                 <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>screen.<span class="me1">state</span>  <span class="st0">&quot;DRAWER_OPEN&quot;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
 screen.<span class="me1">state</span> <span class="sy0">=</span> <span class="st0">&quot;DRAWER_CLOSED&quot;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span>
 …
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Un estado es simplemente una colección de configuraciones y se declara en un elemento State. Una lista de estdos pueden listarse y asociarse a la propiedad estados. En nuestra aplicación, los dos estados se llaman DRAWER_CLOSED y DRAWER_OPEN. Los ítems de as configuraciones se declaran en elementos PropertyChanges. En el estado DRAWER_OPEN, hay cuatro ítems que recibirán cambios de propiedades. El primer destino, menuBar, cambiará su propiedad y a 0. De manera similar, textArea bajará a una nueva posición cuando el estado es DRAWER_OPEN. textArea, el cajón, y el ícono del cajón sufrirán cambios de propiedades para ajustarse al estado actual.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> states<span class="sy0">:</span><span class="br0">&#91;</span>
 State <span class="br0">&#123;</span>
 name<span class="sy0">:</span> <span class="st0">&quot;DRAWER_OPEN&quot;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> menuBar<span class="sy0">;</span> y<span class="sy0">:</span> <span class="nu0">0</span><span class="br0">&#125;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> textArea<span class="sy0">;</span> y<span class="sy0">:</span> partition <span class="sy0">+</span> drawer.<span class="me1">height</span><span class="br0">&#125;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> drawer<span class="sy0">;</span> y<span class="sy0">:</span> partition<span class="br0">&#125;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> arrowIcon<span class="sy0">;</span> rotation<span class="sy0">:</span> <span class="nu0">180</span><span class="br0">&#125;</span>
 <span class="br0">&#125;</span><span class="sy0">,</span>
 State <span class="br0">&#123;</span>
 name<span class="sy0">:</span> <span class="st0">&quot;DRAWER_CLOSED&quot;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> menuBar<span class="sy0">;</span> y<span class="sy0">:-</span>height<span class="sy0">;</span> <span class="br0">&#125;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> textArea<span class="sy0">;</span> y<span class="sy0">:</span> drawer.<span class="me1">height</span><span class="sy0">;</span> height<span class="sy0">:</span> screen.<span class="me1">height</span><span class="sy0">-</span> drawer.<span class="me1">height</span> <span class="br0">&#125;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> drawer<span class="sy0">;</span> y<span class="sy0">:</span> <span class="nu0">0</span> <span class="br0">&#125;</span>
 PropertyChanges <span class="br0">&#123;</span> target<span class="sy0">:</span> arrowIcon<span class="sy0">;</span> rotation<span class="sy0">:</span> <span class="nu0">0</span> <span class="br0">&#125;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#93;</span></pre></div></div>
<p>Los cambios de estado son abruptos y necesitamos transiciones más suaves. Las transiciones entre estados se definen usando el elemento Transition, el cual puede luego asociarse a la propiedad transitions del ítem. Nuestro editor de texto tiene una transición de estado siempre que los estados cambian tanto a DRAWER_OPEN o a DRAWER_CLOSED. De manera importante, la transición necesita un estado desde y un estado hacia pero para nuestras transiciones, podemos usar el símbolo comodín * para denotar que la transición se aplica a todos los cambios de estado.
</p><p>Durante las transiciones, podemos asignar animaciones a la propiedad changes. Nuestra menuBar cambia la posición desde y:0 a y:-partition y podemos animar esta transición usando el elemento NumberAnimation. Declaramos que las propiedades de los destinos se animarán por un cierto período de tiempo y usamos una cierta curva de aceleración. Una curva de aceleración controla los ritmos de animación y el comportamiento de la interpolación durante las transiciones de estados. La curva de aceleración que elegimos es Easing.OutQuint, la cual enlentece el movimiento cerca del final de la animación. Por favor lee el artículo sobre Animación en QML.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> transitions<span class="sy0">:</span> <span class="br0">&#91;</span>
 Transition <span class="br0">&#123;</span>
 to<span class="sy0">:</span> <span class="st0">&quot;*&quot;</span>
 NumberAnimation <span class="br0">&#123;</span> target<span class="sy0">:</span> textArea<span class="sy0">;</span> properties<span class="sy0">:</span> <span class="st0">&quot;y, height&quot;</span><span class="sy0">;</span> duration<span class="sy0">:</span> <span class="nu0">100</span><span class="sy0">;</span> easing.<span class="me1">type</span><span class="sy0">:</span>Easing.<span class="me1">OutExpo</span> <span class="br0">&#125;</span>
 NumberAnimation <span class="br0">&#123;</span> target<span class="sy0">:</span> menuBar<span class="sy0">;</span> properties<span class="sy0">:</span> <span class="st0">&quot;y&quot;</span><span class="sy0">;</span> duration<span class="sy0">:</span> <span class="nu0">100</span><span class="sy0">;</span> easing.<span class="me1">type</span><span class="sy0">:</span> Easing.<span class="me1">OutExpo</span> <span class="br0">&#125;</span>
 NumberAnimation <span class="br0">&#123;</span> target<span class="sy0">:</span> drawer<span class="sy0">;</span> properties<span class="sy0">:</span> <span class="st0">&quot;y&quot;</span><span class="sy0">;</span> duration<span class="sy0">:</span> <span class="nu0">100</span><span class="sy0">;</span> easing.<span class="me1">type</span><span class="sy0">:</span> Easing.<span class="me1">OutExpo</span> <span class="br0">&#125;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#93;</span></pre></div></div>
<p>Otra manera de animar cambios de propiedades es declarando un elemento Behavior. Una transición solo trabaja durante cambios de estado y Behavior puede establecer una animación para un cambio de una propiedad general. En el editor de texto, la flecha tiene un elemento NumberAnimation que anima su propiedad rotation siempre que la propiedad cambia.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In TextEditor.<span class="me1">qml</span><span class="sy0">:</span>
&#160;
Behavior<span class="br0">&#123;</span>
 NumberAnimation<span class="br0">&#123;</span>property<span class="sy0">:</span> <span class="st0">&quot;rotation&quot;</span><span class="sy0">;</span>easing.<span class="me1">type</span><span class="sy0">:</span> Easing.<span class="me1">OutExpo</span> <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Volviendo a nuestros componentes con conocimiento de estados y animaciones, podemos mejorar el aspecto de los componentes. En Button.qml, podemos agregar cambios a las propiedades color y scale cuando se hace click en el botón. Los tipos de colores se animan usando ColorAnimation y los números se animar usando NumberAnimation. La sintaxis on propertyName mostrada debajo es útil cuando se enfoca una única propiedad.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In Button.<span class="me1">qml</span><span class="sy0">:</span>
 …
&#160;
color<span class="sy0">:</span> buttonMouseArea.<span class="me1">pressed</span>&#160;? <span class="kw5">Qt</span>.<span class="me1">darker</span><span class="br0">&#40;</span>buttonColor<span class="sy0">,</span> <span class="nu16">1.5</span><span class="br0">&#41;</span> <span class="sy0">:</span> buttonColor
 Behavior on color <span class="br0">&#123;</span> ColorAnimation<span class="br0">&#123;</span> duration<span class="sy0">:</span> <span class="nu0">55</span><span class="br0">&#125;</span> <span class="br0">&#125;</span>
&#160;
scale<span class="sy0">:</span> buttonMouseArea.<span class="me1">pressed</span>&#160;? <span class="nu16">1.1</span> <span class="sy0">:</span> <span class="nu16">1.00</span>
 Behavior on scale <span class="br0">&#123;</span> NumberAnimation<span class="br0">&#123;</span> duration<span class="sy0">:</span> <span class="nu0">55</span><span class="br0">&#125;</span> <span class="br0">&#125;</span></pre></div></div>
<p>Adicionalmente, podemos mejorar el aspecto de nuestros componentes QML al agregar efectos de color tales como gradientes y efectos de opaquez. Declarar un elemento Gradient anula la propiedad color del elemento. Puedes declarar un color en el gradiente usando el elemento GradientStop. El gradiente se posiciona usando una escala, entre 0.0 y 1.0.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In MenuBar.<span class="me1">qml</span>
 gradient<span class="sy0">:</span> Gradient <span class="br0">&#123;</span>
 GradientStop <span class="br0">&#123;</span> position<span class="sy0">:</span> <span class="nu16">0.0</span><span class="sy0">;</span> color<span class="sy0">:</span> <span class="st0">&quot;#8C8F8C&quot;</span> <span class="br0">&#125;</span>
 GradientStop <span class="br0">&#123;</span> position<span class="sy0">:</span> <span class="nu16">0.17</span><span class="sy0">;</span> color<span class="sy0">:</span> <span class="st0">&quot;#6A6D6A&quot;</span> <span class="br0">&#125;</span>
 GradientStop <span class="br0">&#123;</span> position<span class="sy0">:</span> <span class="nu16">0.98</span><span class="sy0">;</span>color<span class="sy0">:</span> <span class="st0">&quot;#3F3F3F&quot;</span> <span class="br0">&#125;</span>
 GradientStop <span class="br0">&#123;</span> position<span class="sy0">:</span> <span class="nu16">1.0</span><span class="sy0">;</span> color<span class="sy0">:</span> <span class="st0">&quot;#0e1B20&quot;</span> <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Este gradiente es usado por la barra de menú para mostrar un gradiente simulando profundidad. El primer color comienza en 0.0 y el último color está en 1.0.
</p>
<h3><span class="mw-headline" id="A_d.C3.B3nde_ir_desde_Aqu.C3.AD">A dónde ir desde Aquí</span></h3>
<p>Terminamos de armar la interface de usuario de un editor de textos muy simple. De aquí en adelante, la interfase de usuario está completa y podemos implementar la lógica de la aplicación usando Qt y C++ normal. QML trabaja muy bien como herramienta de prototipado, separando la lógica de la aplicación del diseño de la IU.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor4_texteditor.png" alt="qml-texteditor4_texteditor.png" />
</p>
<h3><span class="mw-headline" id="Extendiendo_QML_al_usar_Qt_C.2B.2B">Extendiendo QML al usar Qt C++</span></h3>
<p>Ahora que tenemos el diseño de nuestro editor de texto, podemos implementar las funcionalidades del editor de texto en C+<i>. Usar QML con C</i>+ nos permite crear la lógica de nuestra aplicación usando Qt. Podemos crear un contexto QML en una aplicación C++ usando las clases Declarative de Qt y mostramos los elementos QML usando Graphics Scene. De manera alternativa, podemos exportar nuestro código C++ en un complemento (plugin) que la herramienta qmlviewer pueda leer. Para nuestra aplicación, implementaremos las funciones cargar y guardar en C++ y las exportaremos como un complemento. De esta forma, solo necesitaremos cargar el archivo QML directamente en lugar de correr un ejecutable.
</p>
<h3><span class="mw-headline" id="Exponiendo_Clases_C.2B.2B_a_QML">Exponiendo Clases C++ a QML</span></h3>
<p>Estaremos implementando la carga y guardado del archivo usando Qt y C+<i>. Las clases y funciones C</i>+ pueden usarse en QML registrándolas. La clase también necesita compilarse como un complemento Qt y el archivo QML necesita saber donde se encuentra el complemento.
</p><p>Para nuestra aplicación, necesitamos crear los siguientes ítems:
</p>
<ol>
<li> Una clase Directory que manejará las operaciones relacionadas con directorios
</li>
<li> Una clase File que es un QObject, simulando la lista de archivos en un directorio
</li>
<li> Una clase plugin que registrará la clase en el contexto QML
</li>
<li> Un proyecto Qt que compilará el complemento
</li>
<li> Un archivo qmldir para indicarle a la herramienta qmlviewer donde está el complemento
</li>
</ol>
<h3><span class="mw-headline" id="Construyendo_un_complemento_Qt">Construyendo un complemento Qt</span></h3>
<p>Para crear un complemento, necesitamos indicar los siguiente en un archivo de proyecto Qt. Primero, necesitamos agregar los fuentes, encabezados y módulos Qt a nuestro proyecto. Todo el código C++ y los archivos de proyecto están en el directorio filedialog.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In cppPlugins.<span class="me1">pro</span><span class="sy0">:</span>
&#160;
TEMPLATE <span class="sy0">=</span> lib
 CONFIG <span class="sy0">+=</span> qt plugin
 QT<span class="sy0">+=</span> declarative
&#160;
DESTDIR <span class="sy0">+=</span> ..<span class="sy0">/</span>plugins
 OBJECTS_DIR <span class="sy0">=</span> tmp
 MOC_DIR <span class="sy0">=</span> tmp
&#160;
 TARGET <span class="sy0">=</span> FileDialog
&#160;
 HEADERS<span class="sy0">+=</span> directory.<span class="me1">h</span>  file.<span class="me1">h</span>  dialogPlugin.<span class="me1">h</span>
&#160;
SOURCES <span class="sy0">+=</span> directory.<span class="me1">cpp</span>  file.<span class="me1">cpp</span>  dialogPlugin.<span class="me1">cpp</span></pre></div></div>
<p>En particular, compilamos Qt con el módulo declarativo y lo configuramos como un complemento, necesitando una plantilla lib. Pondremos el complemento compilado en el directorio padre de complementos.
</p>
<h3><span class="mw-headline" id="Registrando_una_Clase_en_QML">Registrando una Clase en QML</span></h3>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In dialogPlugin.<span class="me1">h</span><span class="sy0">:</span>
&#160;
<span class="co2">#include &lt;QDeclarativeExtensionPlugin&gt;</span>
&#160;
<span class="kw2">class</span> DialogPlugin <span class="sy0">:</span> <span class="kw2">public</span> QDeclarativeExtensionPlugin
 <span class="br0">&#123;</span>
 <span class="kw2">Q_OBJECT</span>
&#160;
<span class="kw2">public</span><span class="sy0">:</span>
 <span class="kw4">void</span> registerTypes<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>uri<span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<p>Nuestra clase complemento, DialogPlugin es una subclase de QDeclarativeExtensionPlugin. Necesitamos implementar la función heredada, registerTypes(). El archivo dialogPlugin.cpp se parece a esto:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> DialogPlugin.<span class="me1">cpp</span><span class="sy0">:</span>
&#160;
<span class="co2">#include &quot;dialogPlugin.h&quot;</span>
 <span class="co2">#include &quot;directory.h&quot;</span>
 <span class="co2">#include &quot;file.h&quot;</span>
 <span class="co2">#include &lt;qdeclarative.h&gt;</span>
&#160;
<span class="kw4">void</span> DialogPlugin<span class="sy0">::</span><span class="me2">registerTypes</span><span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="st0">''</span><span class="st0">'uri){
&#160;
 qmlRegisterType&lt;Directory&gt;(uri, 1, 0, &quot;Directory&quot;);
 qmlRegisterType&lt;File&gt;(uri, 1, 0,&quot;File&quot;);
 }
&#160;
 Q_EXPORT_PLUGIN2(FileDialog, DialogPlugin);</span></pre></div></div>
<p>La función <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qdeclarativeextensionplugin.html#registerTypes">registerTypes()</a> registra nuestras clase File y Directory en QML. Esta función necesita el nombre de la clase para su plantilla, un número de versión principal, un número de versión menor y un nombre para nuestras clases.
</p><p>Necesitamos exportar el complemento usando la macro <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qtplugin.html#Q_EXPORT_PLUGIN2#q-export-plugin2">Q_EXPORT_PLUGIN2</a> macro. Notar que en nuestro archivo dialogPlugin.h, tenemos la macro <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qobject.html#Q_OBJECT">Q_OBJECT</a> al comienzo de nuestra clase. Además, necesitamos ejecutar qmake sobre el archivo del proyecto para generar el código meta-objeto necesario.
</p>
<h3><span class="mw-headline" id="Creando_Propiedades_QML_en_una_clase_C.2B.2B">Creando Propiedades QML en una clase C++</span></h3>
<p>Podemos crear elementos y propiedades QML usando el <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/metaobjects.html">Sistema de Meta-Objetos</a> de Qt. Podemos implementar propiedades usando señales y ranuras, haciendo que Qt esté al tanto de estas propiedades. Estas propiedades pueden luego ser usadas en QML.
</p><p>Para el editor de texto, necesitamos ser capaces de cargar y guardar archivos. For the text editor, we need to be able to load and save files. Típicamente, estas funciones están contenidas en un diálogo de archivo. Afortunadamente, podemos usar <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qdir.html">QDir</a>, <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qfile.html">QFile</a>, y <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qtextstream.html">QTextStream</a> para implementar lectura de directorios y streams de entrada/salida.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> <span class="kw2">class</span> Directory <span class="sy0">:</span> <span class="kw2">public</span> <span class="kw5">QObject</span><span class="br0">&#123;</span>
&#160;
 <span class="kw2">Q_OBJECT</span>
&#160;
 Q_PROPERTY<span class="br0">&#40;</span><span class="kw4">int</span> filesCount READ filesCount CONSTANT<span class="br0">&#41;</span>
 Q_PROPERTY<span class="br0">&#40;</span><span class="kw5">QString</span> filename READ filename WRITE setFilename NOTIFY filenameChanged<span class="br0">&#41;</span>
 Q_PROPERTY<span class="br0">&#40;</span><span class="kw5">QString</span> fileContent READ fileContent WRITE setFileContent NOTIFY fileContentChanged<span class="br0">&#41;</span>
 Q_PROPERTY<span class="br0">&#40;</span>QDeclarativeListProperty<span class="sy0">&lt;</span>File<span class="sy0">&gt;</span> files READ files CONSTANT <span class="br0">&#41;</span>
&#160;
 …</pre></div></div>
<p>La clase directorio usa el Sistema de Meta-Objetos de Qt para registrar propiedades que necesita para llevar a cabo el manejo de archivos. La clase Directory se exporta como un complemento y está para ser usada en QML como el elemento Directory. Cada una de las propiedades listadas usando la macro <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qobject.html#Q_PROPERTY">Q_PROPERTY</a> es una propiedad QML.
</p><p>La macro <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qobject.html#Q_PROPERTY">Q_PROPERTY</a> declara una propiedad como también sus funciones de lectura y escritura en el Sistema de Meta-Objetos de Qt. Por ejemplo, la propiedad filename property, de tipo QString, se puede leer usando la función filename() y se escribe usando la función setFilename(). Adicionalmente, hay una señal asociada a la propiedad filename llamada filenameChanged(), la cual se emite siempre que la propiedad cambia. Las funciones de lectura y escritura se declaran como públicas en el archivo de encabezado.
</p><p>De manera similar, tenemos las otras propiedades declaradas de acuerdo a sus usos. La propiedad filesCount indica el número de archivos en un directorio. La propiedad filename property se establece con el nombre del archivo seleccionado actualmente y el contenido del archivo guardado/cargado se almacena en la propiedad fileContent.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> Q_PROPERTY<span class="br0">&#40;</span>QDeclarativeListProperty<span class="sy0">&lt;</span>File<span class="sy0">&gt;</span> files READ files CONSTANT <span class="br0">&#41;</span></pre></div></div>
<p>La propiedad lista de archivos en una lista de todos los archivos filtrados en un directorio. La clase Directory se implementa para filtrar archivos de texto no válidos; solo son válidos archivos con una extensión .txt. Más aún, QLists pueden usarse en archivos QML al declararlas como QDeclarativeListProperty en C+<i>. El objeto a manera de plantilla necesita heredar de QObject, de este modo, la clase File también debe heredar de QObject. En la clase Directory, la lista de objetos File se almacena en una QList llamada m_fileList.</i>
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> <span class="kw2">class</span> File <span class="sy0">:</span> <span class="kw2">public</span> <span class="kw5">QObject</span><span class="br0">&#123;</span>
&#160;
 <span class="kw2">Q_OBJECT</span>
 Q_PROPERTY<span class="br0">&#40;</span><span class="kw5">QString</span> name READ name WRITE setName NOTIFY nameChanged<span class="br0">&#41;</span>
&#160;
 …
 <span class="br0">&#125;</span><span class="sy0">;</span></pre></div></div>
<p>Las propiedades pueden luego usarse en QML como parte de las propiedades del elemento Directory. Notar que no tenemos que crear una propiedad identificador id en nuestro código C.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> Directory<span class="br0">&#123;</span>
 id<span class="sy0">:</span> directory
&#160;
 filesCount
 filename
 fileContent
 files
&#160;
 files<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span>.<span class="me1">name</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Como QML usa sintaxis y estructura de Javascript, podemos iterar a través de la lista de archivos y recuperar sus propiedades. Para recuperar la propiedad nombre del primer archivo, podemos invocar files[0].name.
</p><p>Las funciones normales de C<i>+ son accesibles también desde QML. Las funciones para cargar y guardar un archvio se implementan en C++ y se declaran usando la macro <a rel="nofollow" class="external text" href="http://doc.qt.nokia.com/4.7/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>. De manera alternativa, podemos declarar las funciones como una ranura y las funciones serán accesibles desde QML.</i>
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In Directory.<span class="me1">h</span><span class="sy0">:</span>
&#160;
 Q_INVOKABLE <span class="kw4">void</span> saveFile<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
 Q_INVOKABLE <span class="kw4">void</span> loadFile<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>La clase Directory tiene que notificar a otros objetos siempre que el contenido del directorio cambia. Esta función se realiza usando una señal. Como se mencionó previamente, las señales de QML tienen un manejador correspondiente con sus nombres precedidos por el prefijo on. La señal se llama directoryChanged y se emite siempre que hay un refresco en un directorio. El refresco simplemente carga el contenido del directorio y actualiza la lista de archivos válidos en el directorio. Los ítems de QML pueden luego ser notificados asignando una acción al manejador de señal onDirectoryChanged.
</p><p>Las propiedades tipo lista necesitan se exploradas un poco más. Esto es porque las propiedades tipo lista usan callbacks para acceder y modificar los contenidos de la lista. La propiedad lista es de tipo QDeclarativeListProperty&lt;File&gt;. Siempre que se accede a la lista, la función de acceso necesita devolver QDeclarativeListProperty&lt;File&gt;. El tipo plantilla, File, necesita ser un derivado de QObject. Más aún, para crear QDeclarativeListProperty, la función para acceder a la lista y las modificadores necesitan pasarse al constructor como punteros a funciones. La lista, una QList en nuestro caso, también necesita ser una lista de punteros File.
</p><p>El constructor de QDeclarativeListProperty y la implementación de Directory:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> QDeclarativeListProperty <span class="br0">&#40;</span> <span class="kw5">QObject</span><span class="st0">''</span><span class="st0">' object, void * data, AppendFunction append, CountFunction count = 0, AtFunction at = 0, ClearFunction clear = 0 )
 QDeclarativeListProperty&lt;File&gt;( this, &amp;m_fileList, &amp;appendFiles, &amp;filesSize, &amp;fileAt, &amp;clearFilesPtr );</span></pre></div></div>
<p>El constructor pasa punteros a funciones que agregarán a la lista, cuentan la lista, recuperan un ítem usando un índice y vacían la lista. Solo la función de agregar es obligatoria. Notar que los punteros a funciones deben coincidir con la definición de AppendFunction, CountFunction, AtFunction, o ClearFunction.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> <span class="kw4">void</span> appendFiles<span class="br0">&#40;</span>QDeclarativeListProperty<span class="sy0">&lt;</span>File<span class="sy0">&gt;</span> <span class="sy0">*</span> property<span class="sy0">,</span> File <span class="sy0">*</span> file<span class="br0">&#41;</span>
 File<span class="sy0">*</span> fileAt<span class="br0">&#40;</span>QDeclarativeListProperty<span class="sy0">&lt;</span>File<span class="sy0">&gt;</span> <span class="sy0">*</span> property<span class="sy0">,</span> <span class="kw4">int</span> index<span class="br0">&#41;</span>
 <span class="kw4">int</span> filesSize<span class="br0">&#40;</span>QDeclarativeListProperty<span class="sy0">&lt;</span>File<span class="sy0">&gt;</span> <span class="sy0">*</span> property<span class="br0">&#41;</span>
 <span class="kw4">void</span> clearFilesPtr<span class="br0">&#40;</span>QDeclarativeListProperty<span class="sy0">&lt;</span>File<span class="sy0">&gt;</span> <span class="sy0">*</span>property<span class="br0">&#41;</span></pre></div></div>
<p>Para simplificar nuestro diálogo de archivo, la clase Directory filtra los archivos de texto no válidos, los cuales son archivos que no tienen una extensión .txt. Si un nombre de archivo no tiene la extensión .txt, entonces el archivo no aparecerá en nuestro diálogo de archivo. También, la implementación se asegura que los archivos guardados tengan una extensión .txt en el nombre del archivo. Directory usa QTextStream para leer el archivo y para sacar el contenido del archivo a un archivo.
</p><p>Con nuestro elemento Directory, podemos recuperar los archivos como una lista, sabiendo cuantos archivos de texto hay en el directorio de la aplicación, obtener el nombre del archivo y su contenido como una cadena de caracteres, y ser notificados siempre que hay cambios en el contenido del directorio.
</p><p>Para compilar el complemento, ejecutamos qmake sobre el archivo de proyecto cppPlugins.pro, luego ejecutamos make para compilar y transferir el complemento al directorio plugins.
</p>
<h3><span class="mw-headline" id="Importando_un_Complemento_en_QML">Importando un Complemento en QML</span></h3>
<p>La herramienta qmlviewer importa archivos que están en el mismo directorio de la aplicación. También podemos crear un archivo qmldir que contengan las ubicaciones de los archivos QML que queremos importar. El archivo qmldir puede almacenar también las ubicaciones de complementos y otros recursos.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In qmldir<span class="sy0">:</span>
&#160;
Button .<span class="sy0">/</span>Button.<span class="me1">qml</span>
 FileDialog .<span class="sy0">/</span>FileDialog.<span class="me1">qml</span>
 TextArea .<span class="sy0">/</span>TextArea.<span class="me1">qml</span>
 TextEditor .<span class="sy0">/</span>TextEditor.<span class="me1">qml</span>
 EditMenu .<span class="sy0">/</span>EditMenu.<span class="me1">qml</span>
&#160;
plugin FileDialog plugins</pre></div></div>
<p>El complemento que recién creamos se llama FileDialog, como se indica en el campo TARGET en el archivo del proyecto. El componente compilado está en el directorio plugins.
</p>
<h3><span class="mw-headline" id="Integrando_un_Di.C3.A1logo_Archivo_en_el_Men.C3.BA_Archivo">Integrando un Diálogo Archivo en el Menú Archivo</span></h3>
<p>Nuestro FileMenu necesita mostrar el elemento FileDialog, que contiene una lista de archivos de texto en un directorio de esa forma permitiendo al usuario seleccionar el archivo al hacer click en la lista. También necesitamos asignar los botones guardar, abrir y nuevo a sus respectivas acciones. FileMenu contiene un campo de texto de entrada editable que permite al usuario tipear el nombre de un archivo usando el teclado.
</p><p>El elemento Directory se usa en el archivo FileMenu.qml y notifica al elemento FileDialog que el directorio refrescó su contenido. Esta notificación se realiza en el manejador de señal, onDirectoryChanged.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In FileMenu.<span class="me1">qml</span><span class="sy0">:</span>
&#160;
Directory<span class="br0">&#123;</span>
 id<span class="sy0">:</span>directory
 filename<span class="sy0">:</span> textInput.<span class="me1">text</span>
 onDirectoryChanged<span class="sy0">:</span> fileDialog.<span class="me1">notifyRefresh</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Para mantener la simplicidad de nuestra aplicación, el diálogo de archivo siempre estará visible y no mostrará nombres de archivos no válidos, los cuales no tienen una extensión .txt en sus nombres.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In FileDialog.<span class="me1">qml</span><span class="sy0">:</span>
&#160;
<span class="kw4">signal</span> notifyRefresh<span class="br0">&#40;</span><span class="br0">&#41;</span>
 onNotifyRefresh<span class="sy0">:</span> dirView.<span class="me1">model</span> <span class="sy0">=</span> directory.<span class="me1">files</span></pre></div></div>
<p>El elemento FileDialog mostrará el contenido de un directorio al leer su propiedad tipo lista llamados archivos. Los archivos se usan como el modelo de un elemento GridView, el cual muestra ítems de datos en una grilla de acuerdo a un delegado. El delegado maneja la apariencia del modelo y nuestro diálogo de archivo simplemente creará una grilla con el texto centrado en el medio. Hacer click en el nombre del archivo resultará en la apariencia del rectángulo resaltando el nombre del archivo. El elemento FileDialog se notifica siempre que se emite la señal notifyRefresh, recargando los archivos en el directorio.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> In FileMenu.<span class="me1">qml</span><span class="sy0">:</span>
&#160;
Button<span class="br0">&#123;</span>
 id<span class="sy0">:</span> newButton
 label<span class="sy0">:</span> <span class="st0">&quot;New&quot;</span>
 onButtonClick<span class="sy0">:</span><span class="br0">&#123;</span>
 textArea.<span class="me1">textContent</span> <span class="sy0">=</span> <span class="st0">&quot;&quot;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span>
 Button<span class="br0">&#123;</span>
 id<span class="sy0">:</span> loadButton
 label<span class="sy0">:</span> <span class="st0">&quot;Load&quot;</span>
 onButtonClick<span class="sy0">:</span><span class="br0">&#123;</span>
 directory.<span class="me1">filename</span> <span class="sy0">=</span> textInput.<span class="me1">text</span>
 directory.<span class="me1">loadFile</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
 textArea.<span class="me1">textContent</span> <span class="sy0">=</span> directory.<span class="me1">fileContent</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span>
 Button<span class="br0">&#123;</span>
 id<span class="sy0">:</span> saveButton
 label<span class="sy0">:</span> <span class="st0">&quot;Save&quot;</span>
 onButtonClick<span class="sy0">:</span><span class="br0">&#123;</span>
 directory.<span class="me1">fileContent</span> <span class="sy0">=</span> textArea.<span class="me1">textContent</span>
 directory.<span class="me1">filename</span> <span class="sy0">=</span> textInput.<span class="me1">text</span>
 directory.<span class="me1">saveFile</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span>
 Button<span class="br0">&#123;</span>
 id<span class="sy0">:</span> exitButton
 label<span class="sy0">:</span> <span class="st0">&quot;Exit&quot;</span>
 onButtonClick<span class="sy0">:</span><span class="br0">&#123;</span>
 <span class="kw5">Qt</span>.<span class="me1">quit</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
 <span class="br0">&#125;</span>
 <span class="br0">&#125;</span></pre></div></div>
<p>Nuestro FileMenu ahora puede conectarse con sus respectivas acciones. El objeto saveButton transferirá el texto de TextEdit a la propiedad fileContent del directorio, y copia su nombre de archivo de la entrada de texto editable. Finalmente, el botón llama a la función saveFile(), guardando el archivo. La función sloadButton tiene una ejecución similar. También, la acción New vacía el contenido del elemento TextEdit.
</p><p>Más aún, los botones EditMenu se conectan a la funciones TextEdit para copiar, pegar y seleccionar todo el texto en el editor de texto.
</p><p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor5_filemenu.png" alt="qml-texteditor5_filemenu.png" />
</p>
<h3><span class="mw-headline" id="Finalizaci.C3.B3n_del_Editor_de_Texto">Finalización del Editor de Texto</span></h3>
<p><img src="http://doc.qt.nokia.com/4.7/images/qml-texteditor5_newfile.png" alt="qml-texteditor5_newfile.png" />
</p><p>La aplicación puede funcionar como un simple editor de texto, capaz de aceptar texto y guardar el texto en un archivo. El editor de texto puede también cargar desde un archivo y realizar manipulación de texto.
</p>
<!-- 
NewPP limit report
CPU time usage: 0.601 seconds
Real time usage: 0.605 seconds
Preprocessor visited node count: 371/1000000
Preprocessor generated node count: 760/1000000
Post‐expand include size: 1376/2097152 bytes
Template argument size: 439/2097152 bytes
Highest expansion depth: 5/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key qtio_wiki:pcache:idhash:836-0!*!0!!en!*!* and timestamp 20151104072542 and revision id 16512
 -->
</div>								<div class="printfooter">
				Retrieved from "<a href="../index8553.html?title=Getting_Started_Programming_with_QML/es-AR&amp;oldid=16512">http://wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/es-AR&amp;oldid=16512</a>"				</div>
												<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="../Special_Categories.html" title="Special:Categories">Categories</a>: <ul><li><a href="../Category_Articles_needing_cleanup.html" title="Category:Articles needing cleanup">Articles needing cleanup</a></li><li><a href="../Category_Learning.html" title="Category:Learning">Learning</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="../User_10.0.113.html" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="../User_talk_10.0.113.html" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="https://login.qt.io/authorize?client_id=one-qt-server-003&amp;response_type=code&amp;state=20fecd1ddfb399ef&amp;scope=authorizations&amp;redirect_uri=https%3A%2F%2Fwiki.qt.io%2FSpecial%3AQtLogin%2Fcallback" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="es-AR.html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="../Talk_Getting_Started_Programming_with_QML/es-AR.html?title=Talk:Getting_Started_Programming_with_QML/es-AR&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="es-AR.html" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="../index1964.html?title=Getting_Started_Programming_with_QML/es-AR&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="../index4796.html?title=Getting_Started_Programming_with_QML/es-AR&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(../skins/common/images/wiki.png);" href="../Main_Page.html"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="../Main_Page.html" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="../Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="../How_to_create_columns_in_a_QML_ListView.html" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="../Special_WhatLinksHere/Getting_Started_Programming_with_QML/es-AR.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="../Special_RecentChangesLinked/Getting_Started_Programming_with_QML/es-AR.html" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="../Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="../indexf122.html?title=Getting_Started_Programming_with_QML/es-AR&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="../index8553.html?title=Getting_Started_Programming_with_QML/es-AR&amp;oldid=16512" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="../index68bd.html?title=Getting_Started_Programming_with_QML/es-AR&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 4 May 2015, at 16:12.</li>
											<li id="footer-info-viewcount">This page has been accessed 2,279 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="../load55ad.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":200});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/Getting_Started_Programming_with_QML/es-AR by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 07:57:40 GMT -->
</html>
