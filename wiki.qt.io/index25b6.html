<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=D-Pointer/es&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:57:56 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>View source for D-Pointer/es - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"D-Pointer/es","wgTitle":"D-Pointer/es","wgCurRevisionId":18991,"wgRevisionId":0,"wgArticleId":754,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"D-Pointer/es","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-D-Pointer_es skin-vector action-edit vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for D-Pointer/es</span></h1>
						<div id="bodyContent">
								<div id="contentSub">← <a href="http://wiki.qt.io/D-Pointer/es" title="D-Pointer/es">D-Pointer/es</a></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in one of the groups: <a href="http://wiki.qt.io/index.php?title=Qt_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Qt Wiki:Users (page does not exist)">Users</a>, KnowledgeBase, QtWS.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Cleanup | reason=Auto-imported from ExpressionEngine.}}

'''Español''' [[Dpointer SimplifiedChinese|简体中文]] [[Dpointer_Bulgarian|Български]] [[Dpointer|English]]
[[Category:HowTo]]
[[Category:Developing with Qt]]
[[Category:QtInternals]]
[[Category:Spanish]]
[[Category:QtDevelopmentSpanish::General]]

= ¿Qué es el d-pointer? =

Si has leído el ficheros fuente de Qt, como [http://qt.gitorious.org/qt/qt/blobs/HEAD/src/gui/widgets/qlabel.cpp éste], habrás encontrado por todas partes las macros &lt;code>Q_D&lt;/code> y &lt;code>Q_Q&lt;/code> macros. Este artículo desentraña el propósito de dichas macros.

Las macros &lt;code>Q_D&lt;/code> y &lt;code>Q_Q&lt;/code> son parte de un patrón de diseño denominado "d-pointer" (también llamado [http://es.wikipedia.org/wiki/Puntero_opaco puntero opaco]) mediante el cual los detalles de implementación de una librería se pueden ocultar a sus usuarios y se pueden realizar cambios en la implementación sin afectar a la compatibilidad binaria.

== Compatibilidad binaria, ¿qué es eso? ==

Cuando se diseñan librerias como Qt, es deseable que las aplicaciones que enlaza con Qt dinámicamente continúen funcionando sin recompilar incluso después de que la librería Qt sea actualizada o reemplazada por otra versión. Por ejemplo, si tu aplicación ''CuteApp'' se basa en Qt 4.5, deberías ser capaz de actualizar las librerías Qt (en Windows son proporcionan con la aplicación, ¡en Linux a menudo vienen automáticamente mediante el administrador de paquetes!) de la versión 4.5 a Qt 4.6 y tu CuteApp, que fue compilada con Qt 4.5, debería poder seguir funcionando.

=== ¿Qué afecta a la compatibilidad binaria? ===

Entonces, ¿en qué caso provoca un cambio en la librería la recompilación de la aplicación? Vamos a ver un ejemplo sencillo:

&lt;code>
 class Widget {
 …
 private:
 Rect m_geometry;
 };

class Label : public Widget {
 …
 String text() const { return m_text; }
 private:
 String m_text;
 };
&lt;/code>

Aquí tenemos un Widget que contiene como variable su geometría. Compilamos nuestro Widget y lo publicamos como '''WidgetLib 1.0'''

Para '''WidgetLib 1.1''', alguien viene con la brillante idea de agregar soporte para hojas de estilo. Sin problmas, simplemente añadimos unos métodos nuevos y agregamos un ''atributo''.
&lt;code>
 class Widget {
 …
 private:
 Rect m_geometry;
 String m_stylesheet; // NUEVO en WidgetLib 1.1
 };

class Label : public Widget {
 public:
 …
 String text() const { return m_text; }
 private:
 String m_text;
 };
&lt;/code>

Publicamos WidgetLib 1.1 con los cambios anteriores para encontrarnos con que CuteApp, que fue compilada con WidgetLib 1.0 y funcionaba perfectamente, ¡se estrella estrepitosamente!

== ¿Por qué se rompió? ==

La razón es que, al agregar un nuevo atributo, hemos cambiado el también el tamaño de los objetos Widget y Label. ¿Y qué importa eso? Cuando el compilador C++ genera código, usa 'offsets' (desplazamientos) para acceder a los datos que hay dentro de un objeto.

Aquí tenemos una versión muy simplificada de cómo aparecerían dichos objetos en la memoria.

{|
|'''Disposición del objeto Label en WidgetLib 1.0'''
|'''Disposición del objeto label en WidgetLib 1.1'''
|-
|m_geometry &lt;offset 0>
|m_geometry &lt;offset 0>
|-
|—————
|m_stylesheet &lt;offset 1>
|-
|m_text &lt;offset 1>
|——————  
|-
|—————
|m_text &lt;offset 2>
|}

En WidgetLib 1.0, el miembro text de Label se encontraba en el desplazamient (lógico) 1. El código que el compilador ha generado en la aplicación para el método &lt;code>Label::text()&lt;/code> se traduce a un acceso al desplazamiento 1 del objeto "label" en la aplicación. En WidgetLib 1.1, ¡el miembro "text" de la Label se ha movido al desplazamiento (lógico) 2! Dado que no hemos recompilado la aplicación, ésta sigue pensando que &lt;code>text&lt;/code> se encuentra en el desplazamiento 1 ¡y acaba accediendo a la variable &lt;code>stylesheet&lt;/code>!

Estoy seguro de que en este momento hay unos cuántos preguntándose por qué el cálculo del desplazamiento de &lt;code>Label::text()&lt;/code> acabó en el binario de CuteApp y no en el de WidgetLib. La respuesta es que el código de &lt;code>Label::text()&lt;/code> se definió en el fichero de cabecera y el compilador terminó por insertarlo ([https://es.wikipedia.org/wiki/Función_inline inline]).

Por tanto, ¿cambiaría la situación si &lt;code>Label::text()&lt;/code> no hubiera sido convertida en "inline"? Digamos, en el caso de haber movido &lt;code>Label::text()&lt;/code> al fichero fuente? Pues no. El compilador C++ se basa en que el tamaño de los objetos va a ser el mismo al compilar y al ejecutar. Por ejemplo, para el desenrollado de pila (si has creado un objeto Label en la pila, el compilador habrá generado código para crear espacio en la pila basándose en el tamaño de Label a la hora de compilar) . Dado que el tamaño de Label es diferente al ejecutarse con WidgetLib 1.1, el constructor de Label va a sobreescribir datos ya existentes en la pila y terminará corrompiéndola.

=== Nunca cambies el tamaño de una clase de C++ exportada ===

En resumen, nunca jamás cambies el tamaño o distribución (no alteres la posición de los datos) de clases de C++ ''exportadas'' (es decir, visibles para el usuario) una vez que hayas publicado tu librería. El compilador C++ genera código asumiendo que el tamaño y orden de los datos en una clase no cambiará ''después'' de que la aplicación ha sido compilada.

Entonces, ¿cómo puede uno agregar nuevas propiedades sin alterar el tamaño de los objetos?

== El d-pointer ==

El truco está en mantener constante el tamaño de todas las clases públicas de una librería, almacenando un único puntero. Este puntero apunta a una estructura de dato privada/interna que contiene todos los datos. El tamaño de esta estructura interna puede encoger o crecer sin tener ningún efecto secundario sobre la aplicación porque a este puntero se acceder sólo desde el código de la librería y, desde el punto de vista de la aplicación, el tamaño del objeto nunca cambia (siempr es del tamaño de un puntero). A este puntero lo llamamos el ''d-pointer''.

El espíritu de este patrón lo esbozamos en el siguiente código (el código en este artículo no contiene destructures, pero por supuesto deberíamos añadirlos en código real).

&lt;code>
 /* widget.h */
 // Declaración anticipada. La definición estará en widget.cpp o
 // en un fichero aparte, digamos widget_p.h
 class WidgetPrivate;

class Widget {
 …
 Rect geometry() const;
 …
 private:
 // nunca se hace referencia al d-pointer en el fichero de cabecera.
 // dado que WidgetPrivate no está definida en esta cabecera,
 // cualquier acceso provocará un error de compilación
 WidgetPrivate '''d_ptr;
 };

 /''' widget_p.h */ (_p significa privado)
 struct WidgetPrivate {
 Rect geometry;
 String stylesheet;
 };

 /''' widget.cpp */
 #include "widget_p.h"
 Widget::Widget()
 : d_ptr(new WidgetPrivate) {// creamos los datos privados
 }

 Rect Widget::geoemtry() const {
 // sólo se accede al d-ptr en el código de la librería
 return d_ptr->geometry;
 }

 /''' label.h */
 class Label : public Widget {
 …
 String text();
 private:
 // cada clase mantiene su propio d-pointer
 LabelPrivate '''d_ptr;
 };

 /''' label.cpp */
 // Al contrario que en WidgetPrivate, definimos LabelPrivate en el propio fichero fuente
 struct LabelPrivate {
 String text;
 };

 Label::Label()
 : d_ptr(new LabelPrivate) {
 }

 String Label::text() {
 return d_ptr->text;
 }
&lt;/code>

Con la estructura anterior, CuteApp nunca accede directamente al d-pointer. Y dado que los únicos accessos al ''d-pointer'' están en WidgetLib, que se recompila con cada nueva publicación, se puede cambiar con libertad la clase Private sin tener impacto en CuteApp.

== Otros beneficios del d-pointer ==
La compatibilidad binaria no lo es todo. El d-pointer tiene otras ventajas:
''' Oculta detalles de implementación - Podemos publicar simplemente los ficheros de cabecera y binarios de WidgetLib. Los ficheros .cpp pueden ser fuente cerrada.
* El fichero de cabecera está limpio de detalles de implementación y puede servir como API de referencia.
* Dado que los ficheros de cabecera necesarios para la implementación se han pasado desde un fichero de cabecera al fichero (fuente) de implementación, las compilaciones serán mucho más rápidas.

Ciertamente, estas ventajas pueden parecer triviales. La razón real para el uso de los d-pointer en Qt es la compatibilidad binaria y el hecho de que Qt comenzó siendo de código cerrado.

== El q-pointer ==

Hasta ahora, sólo hemos visto el d-pointer como una estructura de datos de tipo C. En realidad, contiene métodos privados (funciones de ayuda). Por ejemplo, &lt;code>LabelPrivate&lt;/code> podría tener una función de ayuda &lt;code>getLinkTargetFromPoint()&lt;/code> que se precisa para encontrar el objetivo cuando se pulsa el ratón. En muchos casos, estos métodos de ayuda requieren de acceso a la clase pública (es decir, algunas funciones de Label o de su clase base, Widget). Por ejemplo, &lt;code>setTextAndUpdateWidget()&lt;/code> (un método de ayuda), podría querer llamar a &lt;code>Widget::update()&lt;/code>, que es un método público para solicitar una repintada de Widget. Por tanto, el &lt;code>WidgetPrivate&lt;/code> almacena un puntero a la clase pública llamado el q-pointer. Modificando el código de arriba para tener el q-pointer obtenemos:

&lt;code>
 /* widget.h */
 // Declaración anticipada. La definición estará en widget.cpp o
 // en un fichero aparte, digamos widget_p.h
 class WidgetPrivate;

class Widget {
 …
 Rect geometry() const;
 …
 private:
 // nunca se hace referencia al d-pointer en el fichero de cabecera.
 // dado que WidgetPrivate no está definida en esta cabecera,
 // cualquier acceso provocará un error de compilación
 WidgetPrivate '''d_ptr;
 };

 /''' widget_p.h */ (_p significa privado)
 struct WidgetPrivate {
 // constructor que inicializa el q-ptr
 WidgetPrivate(Widget *q) : q_ptr(q) { }
 Widget '''q_ptr; // q-ptr que apunta a la clase de API
 Rect geometry;
 String stylesheet;
 };

 /''' widget.cpp */
 #include "widget_p.h"
 // creamos los datos privados. pasamos el puntero 'this' para inicializar el q-ptr
 Widget::Widget()
 : d_ptr(new WidgetPrivate(this)) {
 }

 Rect Widget::geometry() const {
 // sólo se accede al d-ptr en el código de la librería
 return d_ptr->geometry;
 }

 /''' label.h */
 class Label : public Widget {
 …
 String text() const;
 private:
 LabelPrivate '''d_ptr; // cada clase mantiene su propio d-pointer
 };

 /''' label.cpp */
 // Al contrario que en WidgetPrivate, definimos LabelPrivate en el propio fichero fuente
 struct LabelPrivate {
 LabelPrivate(Label *q) : q_ptr(q) { }
 Label '''q_ptr;
 String text;
 };

 Label::Label()
 : d_ptr(new LabelPrivate(this)) {
 }

 String Label::text() {
 return d_ptr->text;
 }
&lt;/code>

== Herencia de d-pointers para optimización ==
En el código anterior, la creación de una Label resulta en la reserva de memoria para &lt;code>LabelPrivate&lt;/code> y &lt;code>WidgetPrivate&lt;/code>. Si empleásemos esta estrategia para Qt, la situación se volvería mucho peor en clases como &lt;code>QListWidget&lt;/code>, que se encuentra a 6 niveles en la jerarquía de herencia de clases ¡y resultaría en hasta 6 reservas de memoria!

Eto se resuelve teniendo una jerarquía de herencia para nuestras clases ''privadas'' y haciendo que la clase que se está instanciando pase el d-pointer hacia arriba.

Observa que cuando se heredan d-pointers, la declarción de la clase privada tiene que estar en un fichero separado, por ejemplo widget_p.h. No se puede seguir declarando en el fichero widget.cpp.

&lt;code>
 /''' widget.h */
 class Widget {
 public:
 Widget();
 …
 protected:
 // sólo las subclases pueden acceder a lo siguiente
 Widget(WidgetPrivate &amp;d); // permitir a las subclases inicializarse usando su propio Private concreto
 WidgetPrivate '''d_ptr;
 };

 /''' widget_p.h */ (_p significa private)
 struct WidgetPrivate {
 WidgetPrivate(Widget *q) : q_ptr(q) { } // constructor que inicializa el q-ptr
 Widget '''q_ptr; // q-ptr que apunta a la clase de API
 Rect geometry;
 String stylesheet;
 };

 /''' widget.cpp */
 Widget::Widget()
 : d_ptr(new WidgetPrivate(this)) {
 }

 Widget::Widget(WidgetPrivate &amp;d)
 : d_ptr(&amp;d) {
 }

 /''' label.h */
 class Label : public Widget {
 public:
 Label();
 …
 protected:
 Label(LabelPrivate &amp;d); // allow Label subclasses to pass on their Private
 // observa cómo Label ¡no tiene un d_ptr! Simplemente usa el de Widget
 };

 /''' label.cpp */
 #include "widget_p.h" // de manera que podamos acceder a WidgetPrivate

class LabelPrivate : public WidgetPrivate {
 public:
 String text;
 };

Label::Label()
 : Widget(*new LabelPrivate) // inicializar el d-pointer con nuestro propio Private
 }

Label::Label(LabelPrivate &amp;d)
 : Widget(d) {
 }
&lt;/code>

¿Ves la belleza? Ahora cuando creamos un objeto &lt;code>Label&lt;/code>, creará un &lt;code>LabelPrivate&lt;/code> (que deriva de &lt;code>WidgetPrivate&lt;/code>). ¡Pasa el ''d-pointer'' en concreto al constructor protegido de Widget! Ahora, cuando se crea un objeto &lt;code>Label&lt;/code>, sólo se hace una reserva de memoria. Label tiene también un constructor protegido que pueden usar sus clases derivadas para proporcionar sus propias clases privadas.

== d-pointers en Qt ==

En Qt, prácticamente cada clase pública usa el enfoque d-pointer. Los únicos casos en los que no se usa es cuando se sabe con anticipación que nunca se van a agregar miembros nuevos a la clase. Por ejemplo, no se espera añadir miembros nuevos para clases como &lt;code>QPoint&lt;/code> o &lt;code>QRect&lt;/code> y, por tanto, los miembros datos se almacenan directmente en la clase en lugar de usar el d-pointer.

Observa que, en Qt, la clase base de todos los objetos Private es &lt;code>QObjectPrivate&lt;/code>.

=== Q_D and Q_Q ===

Un efecto colateral a la optimización que hicimos en el paso anterior es que el q-ptr y el d-ptr son de tipo &lt;code>Widget&lt;/code> y &lt;code>WidgetPrivate&lt;/code>. Eso significa que lo siguiente no va a funcionar.

&lt;code>
 void Label::setText(const String &amp;text) {
 // ¡no funcionará! ya que d_ptr es de tipo WidgetPrivate incluso aunque apunta a un objeto LabelPrivate
 d_ptr->text = text;
 }
&lt;/code>

Por tanto, cuando se accede al d-pointer en una clase derivada, necesitamos un static_cast con el tipo apropiado.
&lt;code>
 void Label::setText(const String &amp;text) {
 LabelPrivate '''d = static_cast&lt;LabelPrivate'''>(d_ptr); // convertir a nuestro tipo privado
 d->text = text;
 }
&lt;/code>

Como puedes ver, no es bonito tener static_cast por todos lados. En su lugar, se han definido dos macros en src/corelib/global/qglobal.h, que lo convierte en algo más sencillo:

'''global.h'''
&lt;code>
 #define Q_D(Class) Class##Private * const d = d_func()
 #define Q_Q(Class) Class * const q = q_func()
&lt;/code>

'''label.cpp'''
&lt;code>
//Con Q_D se pueden usar miembros de LabelPrivate desde Label
 void Label::setText(const String &amp;text) {
 Q_D(Label);
 d->text = text;
 }
//Con Q_Q puedes usar los miembros de Label desde LabelPrivate
 void LabelPrivate::someHelperFunction() {
 Q_Q(Label);
 q->selectAll();
 }
&lt;/code>

=== Q_DECLARE_PRIVATE y Q_DECLARE_PUBLIC ===

Las clases de Qt tienen una macro &lt;code>Q_DECLARE_PRIVATE&lt;/code> en la clase pública. La macro es como sigue:

'''qglobal.h'''
&lt;code>
 #define Q_DECLARE_PRIVATE(Class)  inline Class##Private* d_func() { return reinterpret_cast&lt;Class##Private '''>(qGetPtrHelper(d_ptr)); }  inline const Class##Private''' d_func() const {  return reinterpret_cast&lt;const Class##Private *>(qGetPtrHelper(d_ptr)); }  friend class Class##Private;
&lt;/code>

Esta macro se puede puede usar de esta manera:

'''qlabel.h'''
&lt;code>
 class QLabel {
 private:
 Q_DECLARE_PRIVATE(QLabel);
 };
&lt;/code>

La idea es que &lt;code>QLabel&lt;/code> proporcione una función &lt;code>d_func()&lt;/code> que permita el acceso a su clase privada interna. Este método en sí es privado (dado que la macro está en una sección privada de qlabel.h). Sin embargo, &lt;code>d_func()&lt;/code> puede ser invocada por clases '''amigas''' (C++ friend) de &lt;code>QLabel&lt;/code>. Esto es útil principalmente para que clases de Qt que no pueden acceder a la API pública de &lt;code>QLabel&lt;/code> puedan acceder a la información. Un ejemplo estrafalario de esto sería que &lt;code>QLabel&lt;/code> quiera llevar un conteo del número de veces que un usuario ha pulsado en un enlace. Sin embargo, no hay API pública para acceder a esta información. &lt;code>QStatistics&lt;/code> es una clase que necesita esta información. Un desarrollador de Qt añadirá &lt;code>QStatistics&lt;/code> como clase amiga de &lt;code>QLabel&lt;/code> y &lt;code>QStatistics&lt;/code> podrá entonces hacer &lt;code>label->d_func()->linkClickCount&lt;/code>.

La &lt;code>d_func&lt;/code> tiene también la ventaja de forzar la corrección de const: en una función miembro const de MyClass, necesitarás una Q_D(const MyClass) y, por tanto, sólo podrás invocar a funciones miembro const de MyClassPrivate. Con un d_ptr "desnudo" también podrías invocar funciones que no sean const.
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="http://wiki.qt.io/Template:Ambox" title="Template:Ambox">Template:Ambox</a> (<a href="http://wiki.qt.io/index.php?title=Template:Ambox&amp;action=edit" title="Template:Ambox">view source</a>) </li><li><a href="http://wiki.qt.io/Template:Cleanup" title="Template:Cleanup">Template:Cleanup</a> (<a href="http://wiki.qt.io/index.php?title=Template:Cleanup&amp;action=edit" title="Template:Cleanup">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="http://wiki.qt.io/D-Pointer/es" title="D-Pointer/es">D-Pointer/es</a>.</p>
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/D-Pointer/es">http://wiki.qt.io/D-Pointer/es</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=D-Pointer%2Fes" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/D-Pointer/es"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:D-Pointer/es&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="http://wiki.qt.io/D-Pointer/es" >Read</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="http://wiki.qt.io/index.php?title=D-Pointer/es&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=D-Pointer/es&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/D-Pointer/es" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/D-Pointer/es" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=D-Pointer/es&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":210});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=D-Pointer/es&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:57:56 GMT -->
</html>
