<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=QtWhitepaper/ko&oldid=17403 by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 13:17:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>QtWhitepaper/ko - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"QtWhitepaper/ko","wgTitle":"QtWhitepaper/ko","wgCurRevisionId":17403,"wgRevisionId":17403,"wgArticleId":1884,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Articles needing cleanup","Pages with broken file links"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"QtWhitepaper/ko","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp-qt {line-height: normal;}
.source-cpp-qt li, .source-cpp-qt pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp-qt
 * CSS class: source-cpp-qt, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp-qt.source-cpp-qt .de1, .cpp-qt.source-cpp-qt .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.cpp-qt.source-cpp-qt  {font-family:monospace;}
.cpp-qt.source-cpp-qt .imp {font-weight: bold; color: red;}
.cpp-qt.source-cpp-qt li, .cpp-qt.source-cpp-qt .li1 {font-weight: normal; vertical-align:top;}
.cpp-qt.source-cpp-qt .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp-qt.source-cpp-qt .li2 {font-weight: bold; vertical-align:top;}
.cpp-qt.source-cpp-qt .kw1 {color: #000000; font-weight:bold;}
.cpp-qt.source-cpp-qt .kw2 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .kw4 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw5 {color: #22aadd;}
.cpp-qt.source-cpp-qt .co1 {color: #888888;}
.cpp-qt.source-cpp-qt .co2 {color: #006E28;}
.cpp-qt.source-cpp-qt .coMULTI {color: #888888; font-style: italic;}
.cpp-qt.source-cpp-qt .es0 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es1 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es2 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es3 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es4 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es5 {color: #006699; font-weight: bold;}
.cpp-qt.source-cpp-qt .br0 {color: #006E28;}
.cpp-qt.source-cpp-qt .sy0 {color: #006E28;}
.cpp-qt.source-cpp-qt .st0 {color: #BF0303;}
.cpp-qt.source-cpp-qt .nu0 {color: #B08000;}
.cpp-qt.source-cpp-qt .nu6 {color: #208080;}
.cpp-qt.source-cpp-qt .nu8 {color: #208080;}
.cpp-qt.source-cpp-qt .nu12 {color: #208080;}
.cpp-qt.source-cpp-qt .nu16 {color:#800080;}
.cpp-qt.source-cpp-qt .nu17 {color:#800080;}
.cpp-qt.source-cpp-qt .nu18 {color:#800080;}
.cpp-qt.source-cpp-qt .nu19 {color:#800080;}
.cpp-qt.source-cpp-qt .me1 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me2 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .ln-xtra, .cpp-qt.source-cpp-qt li.ln-xtra, .cpp-qt.source-cpp-qt div.ln-xtra {background-color: #ffc;}
.cpp-qt.source-cpp-qt span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-QtWhitepaper_ko skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">QtWhitepaper/ko</span></h1>
						<div id="bodyContent">
								<div id="siteSub">From Qt Wiki</div>
								<div id="contentSub"><span class="subpages">&lt; <a href="http://wiki.qt.io/QtWhitepaper" title="QtWhitepaper">QtWhitepaper</a></span><div id="mw-revision-info">Revision as of 12:22, 26 May 2015 by <a href="http://wiki.qt.io/User:Wieland" title="User:Wieland" class="mw-userlink">Wieland</a>  <span class="mw-usertoollinks">(<a href="http://wiki.qt.io/User_talk:Wieland" title="User talk:Wieland">Talk</a> | <a href="http://wiki.qt.io/Special:Contributions/Wieland" title="Special:Contributions/Wieland">contribs</a>)</span></div><br />
				<div id="mw-revision-nav">(<a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;diff=prev&amp;oldid=17403" title="QtWhitepaper/ko">diff</a>) <a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;direction=prev&amp;oldid=17403" title="QtWhitepaper/ko">← Older revision</a> | Latest revision (diff) | Newer revision → (diff)</div></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table style="center; margin: -1px auto 0px;border: 1px solid rgb(127, 194, 66); border-left: 10px solid rgb(127, 194, 66); background:rgb(250,250,250); width:600px">

<tr>
<td style="padding: 0.25em 0.5em;"> <b>This article may require cleanup to meet the Qt Wiki's quality standards.</b> Reason: Auto-imported from ExpressionEngine.<br /><small>Please <b><a rel="nofollow" class="external text" href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;action=edit">improve this article</a></b> if you can. Remove the {{cleanup}} tag and add this page to <b><a href="http://wiki.qt.io/Updated_pages" title="Updated pages">Updated pages</a></b> list after it's clean.</small>
</td></tr></table>
<p><b>한국어</b> <a href="http://wiki.qt.io/QtWhitepaper" title="QtWhitepaper">English</a>
</p><p><br />
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Qt_.EB.B0.B1.EC.84.9C"><span class="tocnumber">1</span> <span class="toctext">Qt 백서</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.EC.84.9C.EB.AC.B8"><span class="tocnumber">2</span> <span class="toctext">서문</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#.EC.A3.BC.EC.9A.94_.EA.B8.B0.EB.8A.A5_.EC.9A.94.EC.95.BD"><span class="tocnumber">2.1</span> <span class="toctext">주요 기능 요약</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#.EA.B7.B8.EB.9E.98.ED.94.BD_.EC.9C.A0.EC.A0.80_.EC.9D.B8.ED.84.B0.ED.8E.98.EC.9D.B4.EC.8A.A4_.28GUI.29"><span class="tocnumber">3</span> <span class="toctext">그래픽 유저 인터페이스 (GUI)</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#.EC.9C.84.EC.A0.AF"><span class="tocnumber">3.1</span> <span class="toctext">위젯</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#.EB.A0.88.EC.9D.B4.EC.95.84.EC.9B.83_.28.EB.B0.B0.EC.B9.98.29"><span class="tocnumber">3.2</span> <span class="toctext">레이아웃 (배치)</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#.EC.8B.9C.EA.B7.B8.EB.84.90.2C_.EC.8A.AC.EB.A1.AF"><span class="tocnumber">3.3</span> <span class="toctext">시그널, 슬롯</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98_.EA.B8.B0.EB.8A.A5"><span class="tocnumber">4</span> <span class="toctext">어플리케이션 기능</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#.EB.A9.94.EC.9D.B8_.EC.9C.88.EB.8F.84.EC.9A.B0.EC.9D.98_.EA.B8.B0.EB.8A.A5"><span class="tocnumber">4.1</span> <span class="toctext">메인 윈도우의 기능</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#.EC.95.A1.EC.85.98"><span class="tocnumber">4.2</span> <span class="toctext">액션</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#.EB.8B.A4.EC.9D.B4.EC.96.BC.EB.A1.9C.EA.B7.B8.EC.99.80_.EC.9C.84.EC.A0.80.EB.93.9C"><span class="tocnumber">4.3</span> <span class="toctext">다이얼로그와 위저드</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#.EC.9D.B8.ED.84.B0.EB.9E.99.ED.8B.B0.EB.B8.8C_.ED.97.AC.ED.94.84"><span class="tocnumber">4.4</span> <span class="toctext">인터랙티브 헬프</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#.EC.84.B8.ED.8C.85"><span class="tocnumber">4.5</span> <span class="toctext">세팅</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#.EB.A9.80.ED.8B.B0_.EC.8A.A4.EB.A0.88.EB.94.A9.EA.B3.BC_.EB.B3.91.EB.A0.AC.28Concurrent.29_.ED.94.84.EB.A1.9C.EA.B7.B8.EB.9E.98.EB.B0.8D"><span class="tocnumber">4.6</span> <span class="toctext">멀티 스레딩과 병렬(Concurrent) 프로그래밍</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#.EB.8D.B0.EC.8A.A4.ED.81.AC.ED.83.91_.ED.86.B5.ED.95.A9"><span class="tocnumber">4.7</span> <span class="toctext">데스크탑 통합</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Qt_.EB.94.94.EC.9E.90.EC.9D.B4.EB.84.88"><span class="tocnumber">5</span> <span class="toctext">Qt 디자이너</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#Qt_.EB.94.94.EC.9E.90.EC.9D.B4.EB.84.88.EC.9D.98_.ED.99.9C.EC.9A.A9"><span class="tocnumber">5.1</span> <span class="toctext">Qt 디자이너의 활용</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Qt_.EB.94.94.EC.9E.90.EC.9D.B4.EB.84.88_.EA.B8.B0.EB.8A.A5.EC.9D.98_.ED.99.95.EC.9E.A5"><span class="tocnumber">5.2</span> <span class="toctext">Qt 디자이너 기능의 확장</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="#.EA.B7.B8.EB.9E.98.ED.94.BD.EC.8A.A4.EC.99.80_.EB.A9.80.ED.8B.B0.EB.AF.B8.EB.94.94.EC.96.B4"><span class="tocnumber">6</span> <span class="toctext">그래픽스와 멀티미디어</span></a>
<ul>
<li class="toclevel-2 tocsection-24"><a href="#.ED.8E.98.EC.9D.B8.ED.8C.85"><span class="tocnumber">6.1</span> <span class="toctext">페인팅</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#.EC.9D.B4.EB.AF.B8.EC.A7.80"><span class="tocnumber">6.2</span> <span class="toctext">이미지</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#.ED.8E.98.EC.9D.B8.ED.8A.B8_.EB.94.94.EB.B0.94.EC.9D.B4.EC.8A.A4.EC.99.80_.ED.94.84.EB.A6.B0.ED.8C.85"><span class="tocnumber">6.3</span> <span class="toctext">페인트 디바이스와 프린팅</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#.EA.B7.B8.EB.9E.98.ED.94.BD.EC.8A.A4_.EB.B7.B0_.ED.94.84.EB.A0.88.EC.9E.84.EC.9B.8C.ED.81.AC"><span class="tocnumber">6.4</span> <span class="toctext">그래픽스 뷰 프레임워크</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Scalable_Vector_Graphics_.28SVG.29"><span class="tocnumber">6.5</span> <span class="toctext">Scalable Vector Graphics (SVG)</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#3D_.EA.B7.B8.EB.9E.98.ED.94.BD.EC.8A.A4"><span class="tocnumber">6.6</span> <span class="toctext">3D 그래픽스</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#.EB.A9.80.ED.8B.B0.EB.AF.B8.EB.94.94.EC.96.B4"><span class="tocnumber">6.7</span> <span class="toctext">멀티미디어</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-32"><a href="#.EC.95.84.EC.9D.B4.ED.85.9C_.EB.B7.B0"><span class="tocnumber">7</span> <span class="toctext">아이템 뷰</span></a>
<ul>
<li class="toclevel-2 tocsection-33"><a href="#.EA.B8.B0.EB.B3.B8_.EC.95.84.EC.9D.B4.ED.85.9C_.EB.B7.B0"><span class="tocnumber">7.1</span> <span class="toctext">기본 아이템 뷰</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Qt.EC.9D.98_.EB.AA.A8.EB.8D.B8.2F.EB.B7.B0_.ED.94.84.EB.A0.88.EC.9E.84.EC.9B.8C.ED.81.AC"><span class="tocnumber">7.2</span> <span class="toctext">Qt의 모델/뷰 프레임워크</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="#.ED.85.8D.EC.8A.A4.ED.8A.B8_.EC.B2.98.EB.A6.AC"><span class="tocnumber">8</span> <span class="toctext">텍스트 처리</span></a>
<ul>
<li class="toclevel-2 tocsection-37"><a href="#.EB.A6.AC.EC.B9.98_.ED.85.8D.EC.8A.A4.ED.8A.B8_.ED.8E.B8.EC.A7.91"><span class="tocnumber">8.1</span> <span class="toctext">리치 텍스트 편집</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#.EB.AC.B8.EC.84.9C.EC.9D.98_.EC.BB.A4.EC.8A.A4.ED.84.B0.EB.A7.88.EC.9D.B4.EC.A7.95.2C_.EC.9D.B8.EC.87.84.2C_.EC.9D.B5.EC.8A.A4.ED.8F.AC.ED.8A.B8"><span class="tocnumber">8.2</span> <span class="toctext">문서의 커스터마이징, 인쇄, 익스포트</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-40"><a href="#.EC.9B.B9.ED.82.B7.EC.9D.84_.EC.9D.B4.EC.9A.A9.ED.95.9C_.EC.9B.B9.EA.B3.BC.EC.9D.98_.ED.86.B5.ED.95.A9"><span class="tocnumber">9</span> <span class="toctext">웹킷을 이용한 웹과의 통합</span></a>
<ul>
<li class="toclevel-2 tocsection-41"><a href="#.EB.84.A4.EC.9D.B4.ED.8B.B0.EB.B8.8C_.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EA.B3.BC.EC.9D.98_.ED.86.B5.ED.95.A9"><span class="tocnumber">9.1</span> <span class="toctext">네이티브 어플리케이션과의 통합</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#DOM_.EC.B0.B8.EC.A1.B0.EC.9A.A9_API"><span class="tocnumber">9.2</span> <span class="toctext">DOM 참조용 API</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="#.EB.84.B7.EC.8A.A4.EC.BC.80.EC.9D.B4.ED.94.84_.ED.94.8C.EB.9F.AC.EA.B7.B8.EC.9D.B8_.EC.A7.80.EC.9B.90"><span class="tocnumber">9.3</span> <span class="toctext">넷스케이프 플러그인 지원</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-45"><a href="#.EB.8D.B0.EC.9D.B4.ED.84.B0.EB.B2.A0.EC.9D.B4.EC.8A.A4"><span class="tocnumber">10</span> <span class="toctext">데이터베이스</span></a>
<ul>
<li class="toclevel-2 tocsection-46"><a href="#SQL_.EB.AA.85.EB.A0.B9_.EC.8B.A4.ED.96.89.ED.95.98.EA.B8.B0"><span class="tocnumber">10.1</span> <span class="toctext">SQL 명령 실행하기</span></a></li>
<li class="toclevel-2 tocsection-47"><a href="#SQL_.EB.AA.A8.EB.8D.B8"><span class="tocnumber">10.2</span> <span class="toctext">SQL 모델</span></a></li>
<li class="toclevel-2 tocsection-48"><a href="#.EB.8D.B0.EC.9D.B4.ED.84.B0_.EB.B3.80.EA.B2.BD.EC.97.90_.EB.B0.98.EC.9D.91.ED.95.98.EB.8A.94_.EC.9C.84.EC.A0.AF_Data-Aware_Widgets"><span class="tocnumber">10.3</span> <span class="toctext">데이터 변경에 반응하는 위젯 Data-Aware Widgets</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-50"><a href="#.EA.B5.AD.EC.A0.9C.ED.99.94"><span class="tocnumber">11</span> <span class="toctext">국제화</span></a>
<ul>
<li class="toclevel-2 tocsection-51"><a href="#.ED.85.8D.EC.8A.A4.ED.8A.B8_.EC.9E.85.EB.A0.A5.EA.B3.BC_.EB.A0.8C.EB.8D.94.EB.A7.81"><span class="tocnumber">11.1</span> <span class="toctext">텍스트 입력과 렌더링</span></a></li>
<li class="toclevel-2 tocsection-52"><a href="#.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EC.9D.98_.EC.96.B8.EC.96.B4_.EB.B2.88.EC.97.AD"><span class="tocnumber">11.2</span> <span class="toctext">어플리케이션의 언어 번역</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#.EC.9C.84.EC.A0.AF_.EC.8A.A4.ED.83.80.EC.9D.BC_.EC.8B.9C.ED.8A.B8"><span class="tocnumber">11.3</span> <span class="toctext">위젯 스타일 시트</span></a></li>
<li class="toclevel-2 tocsection-54"><a href="#.EC.BB.A4.EC.8A.A4.ED.85.80_.EC.8A.A4.ED.83.80.EC.9D.BC"><span class="tocnumber">11.4</span> <span class="toctext">커스텀 스타일</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-56"><a href="#.EC.9E.85.EC.B6.9C.EB.A0.A5.EA.B3.BC_.EB.84.A4.ED.8A.B8.EC.9B.8C.ED.82.B9"><span class="tocnumber">12</span> <span class="toctext">입출력과 네트워킹</span></a>
<ul>
<li class="toclevel-2 tocsection-57"><a href="#.ED.8C.8C.EC.9D.BC_.EB.8B.A4.EB.A3.A8.EA.B8.B0"><span class="tocnumber">12.1</span> <span class="toctext">파일 다루기</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="#XML"><span class="tocnumber">12.2</span> <span class="toctext">XML</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#.ED.94.84.EB.A1.9C.EC.84.B8.EC.8A.A4.EA.B0.84_.ED.86.B5.EC.8B.A0"><span class="tocnumber">12.3</span> <span class="toctext">프로세스간 통신</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="#.EB.84.A4.ED.8A.B8.EC.9B.8C.ED.82.B9"><span class="tocnumber">12.4</span> <span class="toctext">네트워킹</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-63"><a href="#.EC.BB.AC.EB.A0.89.EC.85.98_.ED.81.B4.EB.9E.98.EC.8A.A4"><span class="tocnumber">13</span> <span class="toctext">컬렉션 클래스</span></a>
<ul>
<li class="toclevel-2 tocsection-64"><a href="#.EC.BB.A8.ED.85.8C.EC.9D.B4.EB.84.88"><span class="tocnumber">13.1</span> <span class="toctext">컨테이너</span></a></li>
<li class="toclevel-2 tocsection-65"><a href="#.EC.95.94.EC.8B.9C.EC.A0.81_.EA.B3.B5.EC.9C.A0.28Implicit_Sharing.29"><span class="tocnumber">13.2</span> <span class="toctext">암시적 공유(Implicit Sharing)</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-67"><a href="#.ED.94.8C.EB.9F.AC.EA.B7.B8.EC.9D.B8.EA.B3.BC_.EB.A9.94.ED.83.80_.EC.98.A4.EB.B8.8C.EC.A0.9D.ED.8A.B8_.EC.8B.9C.EC.8A.A4.ED.85.9C"><span class="tocnumber">14</span> <span class="toctext">플러그인과 메타 오브젝트 시스템</span></a>
<ul>
<li class="toclevel-2 tocsection-68"><a href="#.ED.94.8C.EB.9F.AC.EA.B7.B8.EC.9D.B8.EA.B3.BC_.EB.9D.BC.EC.9D.B4.EB.B8.8C.EB.9F.AC.EB.A6.AC"><span class="tocnumber">14.1</span> <span class="toctext">플러그인과 라이브러리</span></a></li>
<li class="toclevel-2 tocsection-69"><a href="#.EB.A9.94.ED.83.80_.EC.98.A4.EB.B8.8C.EC.A0.9D.ED.8A.B8_.EC.8B.9C.EC.8A.A4.ED.85.9C"><span class="tocnumber">14.2</span> <span class="toctext">메타 오브젝트 시스템</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-71"><a href="#Qt_.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EC.9D.98_.EB.B9.8C.EB.93.9C"><span class="tocnumber">15</span> <span class="toctext">Qt 어플리케이션의 빌드</span></a>
<ul>
<li class="toclevel-2 tocsection-72"><a href="#Qt.EC.9D.98_.EB.B9.8C.EB.93.9C_.EC.8B.9C.EC.8A.A4.ED.85.9C"><span class="tocnumber">15.1</span> <span class="toctext">Qt의 빌드 시스템</span></a></li>
<li class="toclevel-2 tocsection-73"><a href="#Qt.EC.9D.98_.EB.A6.AC.EC.86.8C.EC.8A.A4_.EC.8B.9C.EC.8A.A4.ED.85.9C"><span class="tocnumber">15.2</span> <span class="toctext">Qt의 리소스 시스템</span></a></li>
<li class="toclevel-2 tocsection-74"><a href="#Qt_.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EC.9D.98_.ED.85.8C.EC.8A.A4.ED.8C.85.EA.B3.BC_.EB.B2.A4.EC.B9.98.EB.A7.88.ED.81.AC"><span class="tocnumber">15.3</span> <span class="toctext">Qt 어플리케이션의 테스팅과 벤치마크</span></a></li>
<li class="toclevel-2 tocsection-75"><a href="#Qt_.ED.81.AC.EB.A6.AC.EC.97.90.EC.9D.B4.ED.84.B0"><span class="tocnumber">15.4</span> <span class="toctext">Qt 크리에이터</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-77"><a href="#Qt.EC.9D.98_.EC.95.84.ED.82.A4.ED.85.8D.EC.B3.90"><span class="tocnumber">16</span> <span class="toctext">Qt의 아키텍쳐</span></a>
<ul>
<li class="toclevel-2 tocsection-78"><a href="#X11"><span class="tocnumber">16.1</span> <span class="toctext">X11</span></a></li>
<li class="toclevel-2 tocsection-79"><a href="#Microsoft_Windows"><span class="tocnumber">16.2</span> <span class="toctext">Microsoft Windows</span></a></li>
<li class="toclevel-2 tocsection-80"><a href="#Mac_OS_X"><span class="tocnumber">16.3</span> <span class="toctext">Mac OS X</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-82"><a href="#.ED.8A.B9.EC.A0.95_.ED.94.8C.EB.9E.AB.ED.8F.BC.EC.9A.A9_.ED.99.95.EC.9E.A5_.EA.B8.B0.EB.8A.A5.EA.B3.BC_Qt_.EC.86.94.EB.A3.A8.EC.85.98"><span class="tocnumber">17</span> <span class="toctext">특정 플랫폼용 확장 기능과 Qt 솔루션</span></a>
<ul>
<li class="toclevel-2 tocsection-83"><a href="#ActiveX_.ED.98.B8.ED.99.98"><span class="tocnumber">17.1</span> <span class="toctext">ActiveX 호환</span></a></li>
<li class="toclevel-2 tocsection-84"><a href="#Qt_.EC.86.94.EB.A3.A8.EC.85.98"><span class="tocnumber">17.2</span> <span class="toctext">Qt 솔루션</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-86"><a href="#The_Qt_Development_Community"><span class="tocnumber">18</span> <span class="toctext">The Qt Development Community</span></a>
<ul>
<li class="toclevel-2 tocsection-87"><a href="#Online_References"><span class="tocnumber">18.1</span> <span class="toctext">Online References</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Qt_.EB.B0.B1.EC.84.9C">Qt 백서</span></h1>
<p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://qt.nokia.com/logo.png" class="new" title="File:Http://qt.nokia.com/logo.png">http://qt.nokia.com/logo.png</a>
</p><p>이 백서는 Qt C++ 프레임워크에 대한 설명을 담고 있습니다. Qt는 "write once, compile anywhere"(한 번 작성 후 여러 플랫폼에서 컴파일)를 지향하는 크로스 플랫폼 GUI 어플리케이션 개발을 지원하고 있습니다. 단일한 소스트리 상에서 단순한 재컴파일을 통해, Windows, Mac OS X, Linux, Solaris, HP-UX, X11시리즈 등 다양한 환경에서 실행가능한 어플리케이션을 작성할 수 있습니다.
</p><p>뿐만아니라 Qt 어플리케이션은 embedded Linux, Symbian, Windows CE 플랫폼 상에서도 작동합니다.
</p><p>Qt는 멀티미디어, 3D 그래픽, 국제화, SQL, XML, 단위 테스트 등에서 고성능의 크로스 플랫폼 환경을 지원하고 있습니다. 물론 특정 플랫폼을 위한 특화된 확장기능 역시 제공하고 있습니다.
</p><p>유저 인터페이스 개발 환경인 <i>Qt Designer</i> 를 이용하면 Qt 어플리케이션을 시각적으로 확인하면서 개발가능합니다. Qt Designer는 기존의 유명한 IDE에 통합되어 문제없이 이용 가능합니다.
</p><p>Qt Quick이란 Qt 4.7에서 도입한 유저 인터페이스 기술들의 총칭으로, 신속한 프로토타입 개발(rapid prototyping)과 최신의 직관적인 유저 인터페이스 개발을 가능하게 합니다. 이와 관련 된 간략한 설명은 백서의 <i>Qt Quick</i> 섹션에서 볼 수 있으며 보다 구체적인 내용은 <i>Introduction to Qt Quick for C++ Developers</i> 에서 볼 수 있습니다..
</p>
<h1><span class="mw-headline" id=".EC.84.9C.EB.AC.B8">서문</span></h1>
<p><i>Qt는 고성능의 크로스 플랫폼 소프트웨어 개발을 가능하게 해 주는, 표준 C++ 기반의 최신 프레임워크입니다. Qt는 확장성이 용이한 C++ 클래스 라이브러리는 물론, 어플리케이션을 신속하고 간편하게 작성할 수 있도록 해 주는 툴들을 포함하고 있습니다. Qt의 크로스 플랫폼 기능과 국제화 지원기능을 이용하면, Qt 어플리케이션이 적용가능한 마켓이 가장 광범위하다고 자신합니다.</i>
</p><p>Qt C+<i>프레임워크는 1995년 이래로 상용 어플리케이션의 핵심 기능의 개발에 사용되어 왔습니다. Adobe®, Boeing®, Google®, IBM (R), Motorola®, NASA, Skype®를 비롯하여 수많은 기업과 기관에서 Qt가 쓰여졌습니다. Qt 4는 이전보다 강력한 기능을 제공함은 물론, 보다 사용하기 편리하도록 재설계 되었습니다. 각종 Qt 클래스들은 사용자에게 필요한 기능을 거의 완벽히 갖추고 있으며 일관성있는 인터페이스를 제공합니다. 개발자가 사용법을 익히기 쉽도록 하고, 개발에 필요한 추가 부담을 줄여주며, 프로그래머의 생산성을 향상시켜줍니다. Qt는 완벽한 개체지향(Object-oriented) 프레임워크입니다.</i>
</p><p>이 백서는 Qt가 제공하는 기능과 툴에 대해 전반적으로 설명합니다. 각 섹션의 도입부는 non-technical한 설명으로 되어 있으며 도입부 이후 구체적인 기능에 대해 설명합니다. 설명에 쓰인 자료는 각 영역별로 온라인 링크가 제공되어 있습니다.
</p><p>Qt를 30일간 사용해 보고 싶으시다면 <a rel="nofollow" class="external free" href="http://qt.nokia.com/">http://qt.nokia.com/</a> 를 방문하세요. 
</p>
<h2><span class="mw-headline" id=".EC.A3.BC.EC.9A.94_.EA.B8.B0.EB.8A.A5_.EC.9A.94.EC.95.BD">주요 기능 요약</span></h2>
<p>Qt에는 다양한 기능의 위젯 - wiget - (Windows에서는 보통 컨트롤 - control - 이라는 말을 씁니다.)이 포함되어있으며 표준 GUI 기능을 제공합니다. Qt는 "signals and slots"(시그널 - 슬롯)이라고 하는 매우 혁신적인 오브젝트 상호간의 통신 기술을 도입하였습니다. 시그널 - 슬롯은 기존의 프레임워크에서 흔히 사용되었던 구식의 불안전한(unsafe) 콜백 기능을 대체하기 위한 기술입니다. 단, 마우스, 키, 기타 입력장치의 이벤트 핸들링에 대해서는 기존 방식으로도 Qt에서 핸들링 할 수 있습니다. 또한, 메뉴, 컨텍스트 메뉴, 드래그 앤드 드롭, 도킹 툴바 등 최근에 등장한 UI 기능들도 제공하고 있습니다. Qt에서 제공하는 데스크탑(바탕화면)연계 기능을 이용하면 각 플래폼 별로 제공하는 데스크탑 기능을 어플리케이션에서 활용할 수 있습니다. 
</p><p>Qt는 또한 _Qt Designer_라는 이름의 GUI 디자인 툴을 제공합니다. _Qt Designer_는 고정된 위치 설정 등을 비롯한 강력한 레이아웃 기능을 제공합니다. _Qt Designer_는 순전히 GUI 디자인만을 위해 사용할 수도 있으나, 현존하는 유명한 개발툴(IDE)과 통합시켜서 사용하면, 어플리케이션의 UI를 바로 개발툴 안에서 적용하는 것도 가능합니다.
</p><p>Qt는 멀티미디어와 3D그래픽 (page)을 지원합니다. Qt는 플랫폼 독립적인 OpenGL® 프로그래밍을 지원하는 _가장 최신_의 표준 GUI 프레임워크입니다. Qt가 지원하는 플랫폼에서는 전부 고성능의 렌더링 기능을 제공합니다. 캔버스 프레임워크를 사용하면, Qt의 고성능 페인팅 기능을 활용한 인터랙티브한 그래픽 어플리케이션을 개발할 수 있습니다.
</p><p>Qt는 표준 데이터베이스를 이용하면서 플랫폼 독립성을 갖춘 어플리케이션을 개발하는 것이 가능합니다.
Qt는 이미 Oracle®, Microsoft® SQL Server, Sybase® Adaptive Server, IBM DB2®, PostgreSQL™, MySQL®, Borland® Interbase, SQLite, ODBC호환 데이터베이스 등의 다양한 데이터베이스 드라이버가 기본 탑재되어 있습니다. Qt는 데이터베이스에 특화된 위젯을 제공합니다. 물론 Qt 기본 위젯이나 상속된 위젯 역시 간단히 데이터베이스 연계가 가능합니다.
</p>
Qt가 지원하는 플랫폼에서 Qt 스타일, 테마를 이용하면, Qt기반의 프로그램은 독자적인 룩앤필(native look and feel)을 가질 수 있습니다. 단일한 소스트리에서 컴파일 설정을 바꾸는 것만으로 Windows® XP (R)and Windows Vista™, Mac OS X (R), Linux®, Solaris™, HP-UX™, X11™를 지원하는 여타 Unix® 등 각 플랫폼 기반의 어플리케이션을 생성하는 것이 가능합니다. Qt는 설정된 플랫폼에 맞게 자동으로 makefile이나 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">.<span class="me1">dsp</span></pre></div></div>를 생성해 주며, 이를 위해 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">qmake</pre></div></div>라는 빌드 툴을 제공합니다.
<p>Windows, Mac OS X, Unix 등에서 Qt는 단일 플랫폼 기반의 개발방식으로써도 여전히 매력적입니다. 이들 플랫폼 상에서 Qt는 플랫폼의 거의 모든 기능을 커버하며, Qt식의 개발방법론을 많은 개발자가 선호하기 때문입니다. Qt는 Windows의ActiveX®나 Unix의Motif™같이 특정 플랫폼에서만 작동하지만 중요하다고 여겨지는 기능 역시 지원하고 있습니다. 자세한 내용은 sec:Qt's-Architecture 를 참고하세요.
</p><p>Qt는 완벽히 Unicode™를 지원하며, 이것은 특히 국제화 지원에 매우 용이합니다. Qt는 언어 번역 기능을 위해 <i>Qt Linguist</i> 등의 툴을 제공합니다. 어플리케이션은 유니코드를 지원하기 때문에 다양한 언어를 동시에 한 텍스트에 표현하는 것이 가능합니다.
</p><p>Qt는 이밖에도 다양한 목적을 위한 클래스들을 다수 제공합니다. Qt는 SAX나 DOM같이 XML형식의 데이터를 처리하기 위한 클래스들을 제공합니다. STL과 호환가능한 컬렉션 클래스들 역시 제공하고 있습니다. 이들을 이용하면 개체들을 메모리에 저장할 수 있으며, 자바나 C<i>+ 표준 템플릿 라이브러리(STL)에서 사용되었던 반복자(iterator)스타일을 사용하는 것도 가능합니다. 또한 입출력 클래스와 네트워킹 클래스를 제공하고 있으며, 이를 이용하면 표준 방식으로 로컬 파일 혹인 리모트 파일을 처리할 수 있습니다.</i>
</p><p>Qt어플리케이션에서는 플러그인이나 다이나믹 라이브러리를 통해 기능을 확장하는 것이 가능합니다. 플러그인으로는 코덱, 데이터베이스 드라이버, 이미지 포맷, 스타일, 위젯을 추가할 수 있습니다. 플러그인과 라이브러리는 개발자(사)의 저작권을 부여하여 제품으로 판매하는 것이 가능합니다.
</p><p>QtScript 모듈을 이용하면 스크립트를 통해 어플리케이션을 작동시키게 할 수 있습니다. QtScript는 JavaScript와 밀접한 관련이 있는 ECMAScript를 기반으로 하고 있습니다. 스크립트의 용도 범위를 개발자가 설정 가능하기 때문에, 어플리케이션 사용자가 특정 기능을 이용하지 못하게 할 수도 있습니다.
</p><p>Qt는 전세계적으로 널리 사용되는 매우 뛰어난 C++ 프레임워크 입니다. Qt는 상용 제품 개발에 널리 사용됨은 물론, 리눅스 데스크탑 환경을 개발하는 KDE 재단에서는 오픈소스로도 사용되고 있습니다. Qt의 크로스 플랫폼 빌드 환경, 비주얼화된 폼 디자인, 그리고 빼어난 API를 이용함으로써 보다 쾌적하게 어플리케이션을 개발하는 것이 가능합니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/qt-in-use">http://qt.nokia.com/qt-in-use</a>
</p>
<h1><span class="mw-headline" id=".EA.B7.B8.EB.9E.98.ED.94.BD_.EC.9C.A0.EC.A0.80_.EC.9D.B8.ED.84.B0.ED.8E.98.EC.9D.B4.EC.8A.A4_.28GUI.29">그래픽 유저 인터페이스 (GUI)</span></h1>
<p><i>Qt는 어플리케이션의 그래픽 유저 인터페이스를 만들기 위해 다양한 종류의 표준 위젯들을 지원합니다. 레이아웃 메니저를 이용하면, 위젯의 크기와 배치가, 유저가 지정한 스크린 크기, 언어, 폰트에 맞춰서 바뀝니다.</i>
</p><p>위젯이란 유저 인터페이스를 만들기위해 시각적 요소가 조합된 것을 의미합니다. 버튼, 메뉴, 스크롤바, 메시지 박스, 어플리케이션 윈도우 등이 전부 위젯이라 할 수 있습니다.
</p><p>레이아웃 매니저는 하위(child) 위젯들이 상위(parent) 위젯 영역 안에서 어떻게 구성될 것인지를 설정해 주는 역할을 합니다. 차일드 위젯의 사이즈나 위치를 자동으로 조절하며, 최상위(top-level) 위젯의 최소 사이즈나, 디폴트 사이즈 등을 설정 가능합니다. 위젯의 내부 설정이 바뀔 경우에는 자동으로 위치를 재조정해 줍니다.
</p><p>시그널과 슬롯은 어플리케이션 컴포넌트들을 간결하면서도 타입 안정적(type-safe)인 방법으로 소통하도록 연결해 줍니다. 이러한 오브젝트간 통신 방법은 표준 위젯에서는 물론, 개발자들이 만든 커스텀 위젯에서도 사용가능합니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/widgets.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/widgets.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/widgets.png</a>
</p><p><i>Qt에서 제공하는 대표적인 위젯</i>
</p>
<h2><span class="mw-headline" id=".EC.9C.84.EC.A0.AF">위젯</span></h2>
<p>위 그림은 대표적인 위젯들을 나타낸 것입니다. 여기에는 텍스트 입력 위젯, 체크박스, 라디오 버튼, 슬라이더, 푸시 버튼 같은 표준 위젯은 물론 날짜나 시간 입력에 특화된 위젯들도 포함되어 있습니다.
</p><p>라벨, 메시지 박스, 툴팁, 그 밖의 텍스트 표시를 위한 위젯들은 다양한 색상, 폰트, 언어를 지원합니다. Qt의 모든 텍스트 렌더링 위젯들은 HTML의 일부 기능을 이용하여 다국어 리치 텍스트를 표시할 수 있습니다.
</p><p>탭 위젯, 그룹 박스 같은 컨테이너 위젯들 역시 제공하고 있습니다. 이들을 통해 유저 인터페이스 컴포넌트들을 관계 별로 그룹화 시킬 수 있습니다. 특히_Qt Designer_를 이용하면 컨테이너 위젯들을 보다 쉽게 사용할 수 있도록 해 줍니다. 디자이너들이 보다 편리하게 유저 인터페이스를 만들 수 있습니다 . 스크롤 뷰 위젯 같이 보다 복잡한 위젯의 경우, 처리하는 컨텐츠가 매우 특수하거나, 실행중에 시시각각 변하기 때문에, 이러한 위젯은 디자이너 보다는 개발자들이 직접 다루는 경우가 많습니다.
</p><p>개발자들은 자기들만의 독자적인 위젯이나 다이얼로그를 만들 수 있습니다. 이것은 <b>QWidget</b> 클래스를 직접 간접적으로 상속함으로써 가능합니다. 독자적인 컨텐츠를 표시하기 위해, 유저로부터의 입력을 처리하기 위해, 독자적인 시그널 슬롯을 제공하기 위해 커스터마이즈한 특수 위젯을 문제 없이 만들 수 있습니다.
</p><p>지금까지 소개한 위젯 이외에도 Qt는 많은 위젯을 제공합니다. Qt 온라인 <a rel="nofollow" class="external text" href="http://qt.nokia.com/doc/latest/gallery.html">위젯 갤러리</a> 에서는 다양한 종류의 위젯들을 소개하고 있으며 해당 클래스에 대한 도큐먼트를 링크하고 있습니다 .
</p>
<h2><span class="mw-headline" id=".EB.A0.88.EC.9D.B4.EC.95.84.EC.9B.83_.28.EB.B0.B0.EC.B9.98.29">레이아웃 (배치)</span></h2>
<p>레이아웃은 유저 인터페이스의 스타일, 방향, 텍스트 폰트 등이 변경될 경우 즉각적이면서 유동성 있게 대응하게 해 줍니다.
</p><p>레이아웃은 개발자들이 어플리케이션이 국제화를 지원하도록 해 줍니다. 텍스트의 사이즈나 위치를 고정시킨 상태에서 텍스트의 내용을 다른 언어로 바꿀 경우 내용이 전부 표시되지 않을 수도 있습니다. 하지만 레이아웃을 이용하면 차일드 위젯은 자동적으로 사이즈를 조절합니다. 또한, 글자를 오른쪽에서 왼쪽으로 쓰는 체계를 가진 언어의 경우, 보다 자연스럽게 보일 수 있도록 위젯의 위치를 역순으로 바꾸어 줍니다.
</p><p>레이아웃의 방향은 위젯의 배치를 오른 쪽에서 왼 쪽, 밑에서 위로의 방향으로도 가능합니다. 아랍어나 히브리어 같이 글자를 오른쪽에서 왼쪽으로 쓰는 언어를 지원하는 국제화에 유용합니다. 기본으로 제공되는 레이아웃은 Qt의 스타일 시스템에 완벽히 통합되어 있기 때문에 역순으로 배치될 시에도 룩-앤-필의 일관성을 잃어버리지 않습니다.
</p><p><i>Qt Designer</i> 이용하면 위젯을 배치하기 위한 레이아웃을 마음 껏 활용할 수 있습니다.
</p>
<h2><span class="mw-headline" id=".EC.8B.9C.EA.B7.B8.EB.84.90.2C_.EC.8A.AC.EB.A1.AF">시그널, 슬롯</span></h2>
이벨트가 발생하면 위젯은 시그널을 내보냅니다. 예를 들어, 버튼이 클릭되면 이 버튼은 "clicked"라는 시그널을 내보냅니다. 개발자들은 시그널을 자유롭게 연결시킬 수가 있습니다. 슬롯 역할을 하는 멤버함수를 만들고 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw2">connect</span><span class="br0">&#40;</span><span class="br0">&#41;</span></pre></div></div> 함수를 호출하면 시그널이 슬롯에 연결됩니다. Qt의 시그널 슬롯 메커니즘은 연결하려는 상대방이 어떤 클래스인지를 알 필요가 없기 때문에, 클래스의 재사용이 매우 쉽습니다. 시그널, 슬롯은 타입 안정적(type-safe)이기 때문에, 타입 에러가 warning을 발생시키기는 하지만, 오류를 발생시키지는 않습니다.
한 예로, 만약, Quit 버튼의 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">clicked<span class="br0">&#40;</span><span class="br0">&#41;</span></pre></div></div>라는 시그널이 어플리케이션의 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">quit<span class="br0">&#40;</span><span class="br0">&#41;</span></pre></div></div> 라는 슬롯에 연결되어 있으면, 유저가 Quit버튼을 클릭할 시에 어플리케이션은 종료됩니다. 코드 상에서는 다음과 같이 표현됩니다.
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw2">connect</span><span class="br0">&#40;</span>button<span class="sy0">,</span> SIGNAL <span class="br0">&#40;</span>clicked<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span> qApp<span class="sy0">,</span> SLOT <span class="br0">&#40;</span>quit<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;&lt;</span>code<span class="sy0">&gt;</span>
&#160;
이러한 연결은 <span class="kw5">Qt</span> 어플리케이션이 실행되는 중에 언제든지 추가되거나 삭제될 수 있습니다. 시그널은 바로 발산되어 바로 그에 연결된 실행이 이루어지기도 하고<span class="sy0">,</span> 혹은 즉시 큐에 저장되어 나중에 실행되기도 합니다. 또한 서로 다른 스레드상에 있는 오브젝트끼리도 연결하는 것이 가능합니다.
&#160;
시그널<span class="sy0">,</span> 슬롯 메커니즘은 표준 C<span class="sy0">+</span><span class="st0">''</span>상에서 구현됩니다. 이러한 메커니즘을 구현하기 위해서는 C전처리기와 <span class="sy0">&lt;</span>code<span class="sy0">&gt;</span>moc</pre></div></div>이라는 메타 오브젝트 컴파일러를 이용합니다. 이것은 Qt에 이미 포함되어 있으며 Qt 빌드 시스템 sub:Qt's-Build-System 에서 자동적으로 관련된 코드를 생성합니다. 개발자들은 자동 생성된 코드를 수정하거나 의식할 필요가 없습니다.
<p>메타 오브젝트 컴파일러 시스템은 시그널 슬롯의 핸들링 뿐만 아니라, Qt의 번역 메커니즘, 프로퍼티 시스템, 확장된 런타임 타입 정보 (RTTI)를 지원합니다. 또한 Qt가 지원하는 여러 플랫폼 상에서 동일한 방법으로, 런타임 인트로스펙션을 C<i>+ 프로그램 상에서 지원하게 해 줍니다. 이러한 기능들을 제공하는 시스템을 Qt 메타 오브젝트 시스템이라고 합니다(see page.</i>
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_2">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/examples.html">http://qt.nokia.com/doc/latest/examples.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/layout.html">http://qt.nokia.com/doc/latest/layout.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/object.html">http://qt.nokia.com/doc/latest/object.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/signalsandslots.html">http://qt.nokia.com/doc/latest/signalsandslots.html</a>
</p>
<h1><span class="mw-headline" id=".EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98_.EA.B8.B0.EB.8A.A5">어플리케이션 기능</span></h1>
<p><i>Qt를 이용하여 최신의 GUI 어플리케이션을 개발하는 것은 매우 빠르고 간단합니다. 직접 코드를 타이핑함으로써 개발할 수도 있고, 혹은 Qt의 비주얼 디자인 툴인 QtDesigner를 이용할 수도 있습니다.</i>
</p><p>메뉴, 툴바, 도킹 윈도우 같이, GUI 어플리케이션 작성에 필요한 최신 기능들을 전부 Qt에서 제공합니다. Qt는 SDI (single document interface) 와 MDI (multiple document interface) 양쪽을 모두 지원합니다. 또한 Qt는 드래그-앤-드롭과 클립보드를 지원합니다.
</p><p>Qt는 파일 선택, 폴더 선택, 폰트 선택, 컬러 선택 등을 포함하여 일반적으로 사용되는 표준 다이얼로그를 전부 지원합니다. 실제로, Qt의 정형화된 편의 기능을 이용하면 한줄짜리 문장의 출력은 단순히 표준 다이얼로그에게 맡기면 됩니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/assistant.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/assistant.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/assistant.png</a>
</p><p><i>Qt Assistant는 메인 어플리케이션이 제공하는 다양한 기능을 사용하여 Qt 문서들을 보여 줍니다.</i>
</p><p>Qt는 유저 인터페이스 프로그래밍을 보다 편리하게 할 수 있도록 액션이라는 개념을 사용합니다. 예를 들어, 만약 메뉴 옵션, 툴바 버튼, 키보드 단축키가 동일한 액션을 수행하도록 한다 하더라도 이 액션은 단 한번만 코딩하면 됩니다.
</p><p>Qt는 어플리케이션의 설정값을 플랫폼 독립적인 방법으로 저장합니다. 이러한 기능들은 내부적으로 시스템 레지스트리나, 텍스트파일을 이용하며, 유저의 환경설정값도 저장하게 함으로써 최근에 사용했던 파일 리스트나 이전에 사용했던 윈도우, 툴바의 위치나 사이즈 등을 기록하게끔 합니다.
</p><p>멀티 스레드 프로그래밍 지원 역시 제공됩니다. 스레드와 관련하여 거의 일반적이라 할 수 있는 기능들을 구현한 클래스들을 통해 제공됩니다. 이러한 클래스들을 이용하면, 어플리케이션에서 처리시간이 오래 걸리는 기능을 수행하거나, 어플리케이션의 반응속도를 향상시키기 위해 스레드를 사용하는 것이 가능합니다.
</p><p>어플리케이션은 또한 Qt의 데스크탑 통합 기능을 이용할 수 있습니다. 유저의 데스크탑 환경에서 제공하는 서비스를 Qt어플리케이션에서 이용할 수 있습니다.
</p>
<h2><span class="mw-headline" id=".EB.A9.94.EC.9D.B8_.EC.9C.88.EB.8F.84.EC.9A.B0.EC.9D.98_.EA.B8.B0.EB.8A.A5">메인 윈도우의 기능</span></h2>
<p><b>QMainWindow</b> 클래스는 일반적인 어플리케이션용 메인 윈도우를 위한 프레임워크를 제공합니다. 메인 윈도우에는 몇몇의 표준 위젯들이 들어가 있습니다. 메인 윈도우의 상단에는 메뉴바가 자리잡고 있으며, 그 밑에 툴바가 위치합니다. 가운데 있는 윈도우 주변에서 툴바 영역이 자리잡아 이 안에 툴바가 들어가게 됩니다. 메인 윈도우의 제일 하단에 있는 툴바보다도 밑에는 스테이터스바가 자리잡고 있습니다. 툴팁과 "What's this?" 헬프는 유저 인터페이스 요소들을 위한 풍선 도움말을 제공합니다.
</p><p><b>QMenu</b> 위젯은 메뉴 아이템을 세로방향으로 나열시켜 표시해 줍니다. 메뉴는 혼자 독립될 수도 있고 (대표적으로 컨텍스트 팝업 메뉴), 메뉴바에 바로 표시되기도 하며, 혹은 다른 팝업 메뉴의 서브메뉴로 존재하기도 합니다. 메뉴는 분리시켜 사용할 수도 있습니다.
</p><p>각각의 메뉴 아이템들은 아이콘, 체크박스, 단축키를 가질 수 있습니다. 메뉴 아이템은 대개 액션과 연결되어 있어서(예:"Save") 유저가 해당 메뉴를 선택하면, 이와 연결된 슬롯이 실행됩니다. Qt의 레이아웃 매니저는 다양한 메뉴바를 고려하였습니다. Mac OS X에서, 메뉴바는 화면의 맨 위에 표시됩니다.
</p><p>Qt의 메뉴는 매우 유연하며, _액션시스템_의 일부로서 통합되어 사용됩니다(sub:액션 을 참조). 액션은 상황에 맞게 실행을 허가할 지 금지할 지를 설정할 수 있으며, 메뉴에 추가하거나 삭제하는 것도 런타임에 가능합니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-unified-toolbar.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-unified-toolbar.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-unified-toolbar.png</a>
</p><p><i>Mac OS X 환경에 통합된 툴바를 지원합니다. 인접 툴바나 윈도우 타이틀바에 적절하게 붙일 수 있도록 함으로써, 어플리케이션의 룩앤필을 향상시킵니다.</i>
</p><p>툴바는 유저가 액션을 수행하기 편리하도록 버튼이나 다른 위젯들을 모아서 표시합니다. 메인 윈도우의 중심 부분과 인접한 상,하,좌,우 영역에서 자유롭게 이동가능합니다. 툴바는 툴바 영역 밖으로 드래그 시켜서 독립적인 툴 팔레트 형태로 바꿀 수 있습니다.
</p><p>툴바에 들어가는 버튼은 <b>QToolButton</b> 클래스로 만들어집니다. 이 클래스는 한개의 아이콘과 한개의 프레임 스타일을 가지며 추가적으로 라벨을 넣을 수 있습니다. 토글 툴바 버튼은 기능을 온/오프 시킬 때 사용됩니다. 다른 툴바 버튼은 명령을 실행하기 위해 사용됩니다. 활성화/비활성화, 사용가능/불가능, 온/오프 모드 같이 버튼의 상태에 맞게 다른 아이콘을 설정할 수도 있습니다. 만약 단 하나의 아이콘만 설정한 경우에는 Qt는 자동적으로 적절한 시각효과를 줌으로써 상태를 구별짓습니다. 예를 들어 버튼이 사용 불가능한 상태에서는 아이콘 색상을 옅은 색으로 만듭니다. 툴바 버튼은 팝업 메뉴를 표시하게 하는 것도 가능합니다.
</p><p>도킹 윈도우는 유저가 툴바 영역 내부에서 자유롭게 이동시킬 수 있는 윈도우를 가리킵니다. 물론 떨어져 있는 다른 툴바 영역으로도 이동시킬 수 있습니다. 유저는 도킹을 해제할 수 있으며, 이 경우 어플리케이션 최상층에 띄워져 표시되거나, 최소화됩니다. 도킹 에리어 경계상에서 윈도우가 이동 될 경우에는 부드럽게 스크롤되는 애니메이션 효과를 냅니다.
</p><p>도킹 영역안에서는 여러 도킹 윈도우를 행이나 열방향으로 붙이는 것이 가능합니다. 또한 도킹 윈도우는 같은 영역을 공통적으로 포개질 수도 있으며 이 경우에는 탭 형태를 가지게 됩니다.
</p><p>도킹 윈도우를 커스터마이즈하는 것도 가능합니다. 세로로 긴 타이틀바를 표시할 수도 있고, 개별적으로 다른 스타일의 타이틀바나 윈도우 컨트롤을 가지는 것도 가능합니다.
</p><p><i>Qt Designer</i> 나 <i>Qt Linguist</i> 같은 어플리케이션은 도킹윈도우의 기능을 확장시켰습니다. 도킹 윈도우나 툴바의 위치를 저장해 두는 기능을 제공하였기 때문에 유저가 원하는 작업 환경을 이전 그대로 되살릴 수 있습니다.
</p>
<h2><span class="mw-headline" id=".EC.95.A1.EC.85.98">액션</span></h2>
<p>어플리케이션은 하나의 특정 액션을 실행하는 데에 있어서 다양한 방법을 제공해 줍니다. 예를 들어, 대부분의 어플리케이션은 "저장"이라는 액션을 제공하며 이 액션은 메뉴, 툴바(저장이라는 액션에 어울리는 아이콘을 가진 툴바 버튼), 단축키를 통해 실행시킬 수가 있습니다. <b>QAction</b> 클래스는 이러한 개념을 캡슐화 시킵니다. 이 클래스는 프로그래머가 한 액션을 중복해서 정의하는 것을 허락하지 않습니다.
</p><p><b>QAction</b> 은 이처럼 작업이 서로 중복되는 것을 방지할 뿐만 아니라, 서로 연관성 있는 메뉴와 툴바 버튼의 상태를 자동적으로 동기화 시켜 줍니다. 또한 필요한 경우에는 인터랙티브 헬프 기능도 지원합니다. 특정 액션을 사용불가로 설정하면, 연관되어 있는 메뉴와 툴바 버튼도 따라서 사용불가 상태가 됩니다. 뿐만 아니라, 유저가 툴바에 있는 토글 버튼을 클릭하여 토글 상태를 바꾸면, 메뉴에 있는 아이템도 따라서 토글 상태가 바뀝니다.
</p>
<h2><span class="mw-headline" id=".EB.8B.A4.EC.9D.B4.EC.96.BC.EB.A1.9C.EA.B7.B8.EC.99.80_.EC.9C.84.EC.A0.80.EB.93.9C">다이얼로그와 위저드</span></h2>
<p>대부분의 GUI 어플리케이션은 특정 목적을 위해 유저와 긴밀히 소통하기 위한 다이얼로그 박스를 이용합니다.
</p>
<pre>Qt는 대부분의 일반적인 작업을 위한 편리한 기능들을 클래스에 담아 준비해 두었습니다. 아래의 사진은 Qt의 표준 다이얼로그를 나타낸 것입니다. Qt는 색상 선택, 프린팅, 프로그레스를 나타내고 메시지를 표시하는 등의 표준 다이얼로그를 제공합니다.
</pre>
<p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/filedialog.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/filedialog.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/filedialog.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/fontdialog.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/fontdialog.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/fontdialog.png</a>
</p><p><i><b>QFileDialog</b> 와 <b>QFontDialog</b> 는 Plastique 스타일이 적용된 모습입니다. Windows나 Mac OS X 상에서는 네이티브에서 제공하는 다이얼로그가 사용됩니다.</i>
</p><p>프로그래머는 *QDialog*를 상속하여 독자적인 다이얼로그를 만들 수 있습니다. 또한 <i>Qt Designer</i> 는 개발자가 독자적인 디자인을 쉽게 작성할 수 있도록 다이얼로그 템플릿을 제공합니다.
</p><p>특별하지 않은 일반적인 작업이나 절차를 유저에게 안내할 경우에는 위저드가 사용됩니다. 한 단계씩 한 단계씩 유저가 사용가능한 옵션을 제시하고 필요에 따라서는 도움말을 제공합니다. Qt는 확장성이 뛰어나면서도 매우 직관적인 API를 제공합니다. 각각의 플랫폼에 맞는 네이티브 룩앤필을 같이 제공합니다.
</p><p><b>QWizard</b> 클래스는 플랫폼에 특화된 룩앤필이 아닌, 독자적으로 디스플레이 스타일을 커스터마이즈할 수 있는 기능을 제공합니다. 이 클래스의 인스턴스는 유저에게 보여주는 페이지의 순서들을 컨트롤합니다. <b>QWizardPage</b> 는 유저가 입력한 내용이 적절한지 검사하거나 입력한 내용을 저장하는 기능을 제공하는 표준 위젯입니다.
</p>
<h2><span class="mw-headline" id=".EC.9D.B8.ED.84.B0.EB.9E.99.ED.8B.B0.EB.B8.8C_.ED.97.AC.ED.94.84">인터랙티브 헬프</span></h2>
<p>어플리케이션은 유저 인터페이스 요소의 용도를 설명하고 사용을 용이하게 하기 위해서 다양한 형태의 인터랙티브 헬프가 필요할 때가 있습니다. Qt는 단문의 헬프 메세지를 제공하기 위해 두 가지 방법을 제공합니다. 하나는 툴팁이라는, 현재의 정황에 맞는 단문의 헬프를 제공하는 기능이며 다른 하나는 보다 장문의 구체적인 메세지를 표시하는 "What's this?" 팝업 헬프입니다. 두 기능 모두 Qt의 액션 시스템에 통합되어 있습니다.
</p><p>Qt의 Help 모듈에 있는 클래스들을 이용하면, 어플리케이션의 헬프 브라우저 형태로서 혹은 도큐먼트 형태로서 <i>Qt Assistant</i> 를 사용할 수 있습니다. 또한 이 모듈은 유저에게 유용한 정보를 제공할 수 있도록, 툴팁이나 "What's This?" 클래스를 이용하여 어플리케이션의 도큐먼트를 표시하게 해 주는 API를 제공합니다.
</p>
<h2><span class="mw-headline" id=".EC.84.B8.ED.8C.85">세팅</span></h2>
<p><b>QSettings</b> 클래스를 이용하면 유저 혹은 어플리케이션의 설정값을 디스크에 저장 가능합니다. Windows, Mac OS X, Linux 플랫폼 상에서는 설정값이 표준 시스템 로케이션에 저장됩니다. 다른 플랫폼에서는 텍스트파일에 저장됩니다.
</p><p>특별한 추가작업없이 어플리케이션이 데이터를 시리얼라이즈하여 저장하고 불러들일 수 있도록 <b>QSettings</b> 에서는 다양한 Qt데이터 타입을 이용할 수 있습니다. Qt의 데이터 타입의 시리얼라이즈에 관해 보다 자세한 정보를 원하시면 sub:File-Handling 를 참조하시기 바랍니다.
</p>
<h2><span class="mw-headline" id=".EB.A9.80.ED.8B.B0_.EC.8A.A4.EB.A0.88.EB.94.A9.EA.B3.BC_.EB.B3.91.EB.A0.AC.28Concurrent.29_.ED.94.84.EB.A1.9C.EA.B7.B8.EB.9E.98.EB.B0.8D">멀티 스레딩과 병렬(Concurrent) 프로그래밍</span></h2>
<p>Qt 어플리케이션은 멀티 스레드를 이용할 수 있습니다. 다만, 오직 한 스레드만이 유저 인터페이스의 응답을 받을 수 있으며 그 이외의 스레드는 대량의 파일을 읽거나 복잡한 연산을 수행하는 등의 작업을 위해 사용됩니다. Qt는 스레드, 뮤텍스, 세마포, 스레드 글로벌 영역, 프리미티브 록을 사용할 수 있는 클래스들을 제공합니다.
</p><p>map-reduce와 filter-reduce같은 유명한 알고리즘을 포함한 병렬(concurrent) 프로그래밍을 지원하기 위한 기능 역시 제공합니다. 이들은 Qt의 오브젝트 모델에 통합되어 있어서, 표준 컨테이너 클래스를 이용하면 Qt 어플리케이션에서 병렬 처리를 보다 편리하게 이용할 수 있습니다.
</p><p>Qt의 메타오브젝트 시스템을 이용하면, 다른 스레드상에 있는 개체간의 통신을 가능하게 합니다. 이를 위해 시그널 슬롯을 이용하며, 초기에 어플리케이션이 싱글 스레드 기반으로 만들어졌다 하더라도, 특별히 어플리케이션을 재설계할 필요 없이 간단하게 멀티 스레드를 도입하는 것이 가능합니다.
</p>
<h2><span class="mw-headline" id=".EB.8D.B0.EC.8A.A4.ED.81.AC.ED.83.91_.ED.86.B5.ED.95.A9">데스크탑 통합</span></h2>
Qt의 데스크탑 통합 클래스를 이용함으로서 유저의 데스크탑 환경에서 제공하는 서비스와 어플리케이션을 연계할 수 있습니다. <b>QSystemTrayIcon</b> 은 장기간에 걸쳐 실행되는 어플리케이션을 위해 시스템 트레이에 영구적으로 아이콘을 표시하게 해 줍니다. <b>QDesktopServices</b> 는 각 플랫폼이 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">mailto<span class="sy0">:</span></pre></div></div> 나 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">http<span class="sy0">:</span><span class="co1">//</span></pre></div></div> URL 같은 리소스에 적절한 어플리케이션을 찾아 실행될 수 있도록 하게 해 줍니다.
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_3">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qt4-mainwindow.html">http://qt.nokia.com/doc/latest/qt4-mainwindow.html</a>
</p>
<h1><span class="mw-headline" id="Qt_.EB.94.94.EC.9E.90.EC.9D.B4.EB.84.88">Qt 디자이너</span></h1>
<p><i>Qt 디자이너는 Qt 어플리케이션의 GUI를 디자인하기 위한 툴입니다. 어플리케이션은 소스코드상에서 전부 개발되기도 하지만 Qt 디자이너를 이용하여 개발속도를 향상시킬 수 있습니다. 컴포넌트 기반 아키텍쳐는 개발자가 Qt 디자이너의 위젯이나 확장기능을 커스터마이즈할 수 있게 해주며 심지어는 통합 개발환경(IDE) (예:이클립스, 비주얼 스튜디오, Qt 크리에이터)에 통합시켜서 사용하게 하는 것도 가능합니다.</i>
</p><p><i>Qt 디자이너</i> 를 이용하여 폼(form)을 디자인하는 방법은 매우 간단합니다. 개발자는 툴박스에 있는 위젯을 폼으로 드래그하거나 선택, 자르기, 붙이기, 크기 조절 같은 일반적인 편집기능을 사용가능합니다. 그 다음 프로퍼티 에디터에서 각 위젯들의 프로퍼티를 변경합니다. 위젯의 위치나 크기를 정밀하게 조정하는 것도 매우 쉽습니다. 개발자는 하나 이상의 위젯을 선택한다음 레이아웃을 적용하기만 하면 됩니다. 예를 들어, 몇 개의 버튼 위젯을 선택한 후 "lay out horizontally" 옵션을 선택하면 위젯들은 옆으로 붙어서 배열됩니다. 이러한 방법은 디자인 시간을 크게 단축시키며, 개발자가 폼의 디자인을 마친 후, 엔드유저가 원하는 대로 윈도우의 사이즈를 바꾸더라도 알맞은 사이즈로 폼의 크기가 자동 조절됩니다. Qt의 자동 레이아웃에 관한 자세한 설명을 원하신다면 sub:레이아웃 을 참고하세요.
</p><p><i>Qt 디자이너</i> 는 유저 인터페이스 디자인에 있어서, 많은 시간이 허비되는 "compile, link, and run" 라는 반복과정을 생략함으로써 디자인의 잘못된 점을 개선하고, 디자인을 변경하기가 쉬어졌습니다. <i>Qt 디자이너</i> 의 미리보기 옵션은 개발자가 다른 스타일의 폼을 보고자 할 때 그 결과물을 바로 눈으로 확인할 수 있게 해 줍니다. 예를 들어, Mac OS X 상에서 개발이 이루어진다 하더라도 Windows 스타일로 폼을 미리 볼 수 있습니다. 디바이스의 스킨을 이용하여 미리보는 것도 가능하며, 이 경우 디스플레이의 제약이나 해당 디바이스에서 어떤 모습으로 나타나는가를 미리 볼 수 있습니다.
</p><p>Windows의 상용 라이센스 버전에서는 <i>Qt 디자이너</i> 의 UI 디자인 지원툴을 Microsoft Visual Studio®에서 사용 가능합니다. 또한 Qt 프레임워크를 이용하면 크로스 플랫폼을 지원하는 Eclipse™ IDE의 플러그인을 개발할 수 있습니다. 이러한 플러그인은 <i>Qt 디자이너</i> 는 물론 다른 Qt 기술들을 IDE 프레임워크 내부로 통합 시켜 주는 역할을 합니다.
</p>
<h2><span class="mw-headline" id="Qt_.EB.94.94.EC.9E.90.EC.9D.B4.EB.84.88.EC.9D.98_.ED.99.9C.EC.9A.A9">Qt 디자이너의 활용</span></h2>
<p>개발자는 두 가지 스타일의 어플리케이션을 작성할 수 있습니다. 하나는 다이얼로그 스타일 어플리케이션이고, 다른 하나는 메인 윈도우 스타일의 어플리케이션입니다. 메인 윈도우 스타일은 메뉴, 툴바, 풍선 도움말 등의 표준 기능을 포함하고 있습니다. 몇 가지의 템플릿이 제공되어 있으며 개발자들 고유의 템플릿을 생성할 수 있습니다. 이를 이용하면 하나 이상의 어플리케이션에 일관성을 확보하는 것이 가능합니다. 또한 프로그래머는 고유의 커스텀 위젯을 작성할 수 있으며 이러한 위젯을 간단하게 <i>Qt 디자이너</i> 상에 통합시킬 수 있습니다.
</p>
<i>Qt 디자이너</i> 는 폼 기반의 어플리케이션 개발 방법을 지원합니다. 폼(form)이란 하나의 유저 인터페이스 파일(<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">.<span class="me1">ui</span></pre></div></div>)에서 작성되며, 이렇게 작성된 파일은 C+<i>로 컴파일되어 어플리케이션에 통합됩니다. 뿐만 아니라 유저 인터페이스 파일을 동적으로 작성하여 런타임에 처리하는 것도 가능합니다. 유저 인터페이스를 컴파일 타임에 생성시킬 경우, 보다 편리한 디자인 프로세스가 가능하도록 하기 위해, Qt의 빌드 시스템은 (see page) 이러한 과정을 자동화시킬 수 있습니다.</i>
<p><i>Qt 디자이너</i> 를 이용하여 어플리케이션을 만들 경우라도, 개발자는 자신이 선호하는 툴을 사용하여 어플리케이션의 소스를 코딩할 수 있습니다. <i>Qt 디자이너</i> 는 Microsoft Visual Studio 혹은 Eclipse 개발환경에 통합되어 사용할 수 있습니다.
<a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/designer-46-overview.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/designer-46-overview.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/designer-46-overview.png</a>
</p><p><i>Qt 디자이너의 유저 인터페이스의 전반적인 모습</i>
</p>
<h2><span class="mw-headline" id="Qt_.EB.94.94.EC.9E.90.EC.9D.B4.EB.84.88_.EA.B8.B0.EB.8A.A5.EC.9D.98_.ED.99.95.EC.9E.A5">Qt 디자이너 기능의 확장</span></h2>
<p><i>Qt 디자이너</i> 의 내부 아키텍쳐는 컴포넌트 기반 아키텍쳐로 구축되어 있습니다. 그러므로 개발자는 커스텀 컴포넌트를 이용하여 유저 인터페이스나 편집 툴을 확장할 수 있습니다. 게다가 <i>Qt 디자이너</i> 어플리케이션 자체가 모듈화되어 있다는 특성을 활용하여 Microsoft Visual Studio 나 KDevelop 같은 통합개발환경(IDE)상에서도 _Qt 디자이너_를 사용할 수 있도록 해줍니다.
</p>
Qt 디자이너 모듈은 , <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">.<span class="me1">ui</span></pre></div></div>를 작성하고, 기능을 확장하기 위해 20개 이상의 클래스를 제공합니다. 이러한 수많은 클래스들을 이용하여, 서드파티는 어플리케이션 고유의 유저인터페이스를 커스터마이즈 할 수 있습니다.
<p>커스터마이즈한 위젯을 다시 <i>Qt 디자이너</i> 상에서 사용하는 것도 가능합니다. 커스텀 위젯의 기본 프로퍼티와 생성자를 제공하는 인터페이스를 이용하여 플러그인을 구현하면, <i>Qt 디자이너</i> 에서 커스텀 위젯을 통합시킬 수 있습니다. sub:Plugins 에 나온 설명과 비슷한 매크로를 이용하면, 커스텀 위젯 플러그인의 인터페이스가 <i>Qt 디자이너</i> 로 익스포트 됩니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_4">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/designer-manual.html">http://qt.nokia.com/doc/latest/designer-manual.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/products/developer-tools">http://qt.nokia.com/products/developer-tools</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtdesigner.html">http://qt.nokia.com/doc/latest/qtdesigner.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/examples.html">http://qt.nokia.com/doc/latest/examples.html</a> 
</p>
<h1><span class="mw-headline" id=".EA.B7.B8.EB.9E.98.ED.94.BD.EC.8A.A4.EC.99.80_.EB.A9.80.ED.8B.B0.EB.AF.B8.EB.94.94.EC.96.B4">그래픽스와 멀티미디어</span></h1>
<p><i>Qt는 2D 3D 그래픽을 훌륭히 지원합니다. Qt의 2D 그래픽 클래스들은 래스터 그래픽과 벡터 그래픽 양쪽을 모두 지원하며 현존하는 다양한 이미지 포맷을 지원하며 이를 확장하는 것도 가능합니다. 또한 텍스트와 그래픽을 PDF 포맷으로 출력할 수도 있습니다. Qt는 변형된 유니코드 리치 텍스트와 SVG를 표현 가능하며, 인터랙티브 어플리케이션에서 필수적인 캔버스 기능을 완벽하게 제공합니다. 또한 Qt는 오디오, 비디오, 스트림 파일을 재생하는 기능을 제공합니다.</i>
</p><p>그래픽의 표현은 디바이스 독립적인(device-independent) 페인터 오브젝트를 이용하여 이루어집니다. 다른 타입의 디바이스에서 그래픽을 렌더링을 한다 하더라도 디바이스가 Qt 페인트 디바이스를 구현했다면, 개발자는 기존 코드를 그대로 사용가능합니다(see sub:Painting on page ). 이러한 방법은, Qt가 지원하는 디바이스라면, 다양한 종류의 고성능의 페인팅을 완벽하게 수행할 수 있다는 것을 보장해 줍니다. 또한 개발자가 큰 고민 없이, 자신의 목적에 맞는 디바이스를 도입할 수 있게 해 줍니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/demos-boxes.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/demos-boxes.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/demos-boxes.png</a>
</p><p><i>Boxes 데모에서는 Qt의 다양한 그래픽 기능들을 확인할 수 있습니다.</i>
</p><p>인터랙티브한 캔버스를 이용한 그래픽 어플리케이션을 작성해야 한다면, Graphics View 프레임워크를 이용하는 것이 편리합니다. Graphics View 프레임워크는 수많은 인터액티브 아이템을 효과적으로 렌더링 화면에서 관리해 주며, 필요하다면 멀티플 뷰도 이용가능합니다.
</p><p>Qt는 또한 OpenGL과 OpenGL ES를 지원하므로, 개발자가 어플리케이션에 3D 그래픽을 도입할 수 있습니다. 물론 기존의 2D그래픽에도 최신 그래픽 하드웨어를 적용할 수 있으므로 2D 렌더링의 성능 향상 역시 가능합니다. 
</p><p>디바이스 독립적인 컬러(Device-independent color)은, ARGB, AHSV, ACMYK, 그 이외의 일반적인 규격으로 변환하도록 지원합니다. 사용되는 컬러 채널은 16비트 영역을 가지며 추가적으로 투명도를 가질 수 있습니다. 컬러 지정이 요청되면 Qt는 자동적으로 시스템 팔레트에서 할당하며, 제한된 컬러수를 갖는 디스플레이에서는 가장 비슷한 컬러를 할당합니다. (역자 주&#160;: 여기는 번역하기가 쉽지 않네요)
</p>
<h2><span class="mw-headline" id=".ED.8E.98.EC.9D.B8.ED.8C.85">페인팅</span></h2>
<p>Qt는 위젯이나 다른 페인트 디바이스를 페인팅하는 데 있어서 플랫폼 독립적인 API를 제공합니다. 기본적인 드로잉 기능은 물론 변형(Transformation)이나 클리핑 같은 고급 기능도 제공합니다. Qt에서 기본적으로 제공하는 위젯들은 전부 <b>QPainter</b> 를 이용하여 페인팅되었습니다. 만약 개발자가 커스텀 위젯을 만들고 싶을 때에도 마찬가지로 QPainter를 이용해야 합니다. 
</p><p><b>QPainter</b> 는 점, 선, 원, 곡선, 베지어 곡선 등을 그리기 위한 기능을 기본적으로 제공합니다. 폴리곤이나 벡터 패스 같은 복잡하고도 세밀한 페인팅 기능도 이미 제공하고 있으며 이러한 기능들도 함수 한 번의 호출로 간단히 사용할 수 있습니다. 텍스트 페인터를 이용하여 바로바로 페인팅할 수도 있고, 모아 두었다 나중에 한 꺼번에 페인팅할 수도 있습니다.
</p><p>또한 Qt의 페인팅 시스템은 렌더링 퀄리티를 전반적으로 향상시키기 위한 다양한 기능들을 제공합니다. 알파 블렌딩, Porter-Duff 합성 모드, 안티알리아싱, 다양한(linear, radial, conical) 그라데이션 등을 제공합니다.
</p>
<h2><span class="mw-headline" id=".EC.9D.B4.EB.AF.B8.EC.A7.80">이미지</span></h2>
<p>Qt는 BMP, GIF, JPEG, MNG, PNG, PNM, TIFF, XBM, XPM 등의 이미지 포맷에 대해 입력, 출력, 편집 기능을 제공합니다. 이러한 클래스들은 인터랙티브 그래픽 어플리케이션 상에서 일종의 페인트 디바이스로써도 사용가능하며, 또한 유저 인터페이스 컴포넌트 상에서 이미지 전처리(preprocess)를 위해 사용되기도 합니다. 
</p><p><b>QImage</b> 는 이미지를 편집하기 위해서 사용되거나 다양한 컬러 뎁스, 픽셀 포맷들간의 변환을 위해서 사용됩니다. 프로그래머는 픽셀값이나 팔레트 데이터를 편집할 수 있으며 회전(rotations)이나 기울이기(shears)같은 변형을 적용할 수 있습니다. 또한 원한다면 컬러 뎁스를 줄이면서 디더링을 적용하는 것도 가능합니다. 알파 채널을 이용하면 어플리케이션 상에서 이미지 합성 등을 위해 반투명 기능이나 알파 블렌딩을 이용할 수 있습니다.
</p><p>확장 플러그인 구조를 이용하면 Qt에서 이용 가능한 그래픽 파일 포맷을 추가시킬 수 있습니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/graphicsview-map.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/graphicsview-map.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/graphicsview-map.png</a>
</p><p><i>Graphics View 프레임워크를 이용하면 유저 인터랙션을 위한 다양한 기능을 가지면서도 높은 렌더링 퀄리티를 지원하는 어플리케이션을 제작할 수 있습니다.</i>
</p>
<h2><span class="mw-headline" id=".ED.8E.98.EC.9D.B8.ED.8A.B8_.EB.94.94.EB.B0.94.EC.9D.B4.EC.8A.A4.EC.99.80_.ED.94.84.EB.A6.B0.ED.8C.85">페인트 디바이스와 프린팅</span></h2>
<p><b>QPainter</b> 를 통해 종류에 상관 없이 페인트 디바이스를 제어할 수 있습니다. Qt를 지원하는 디바이스라면, 동일한 코드를 통해 페인팅을 수행합니다.
</p><p>모든 위젯은 페인트 디바이스라고 할 수 있습니다. Qt는 <i>백킹 스토어</i> 기능(주:더블 버퍼링?)을 이용하여 페인팅 처리시 발생하는 깜빡임 현상을 줄여줍니다. 시스템 환경 설정이 제대로 설정되어 있다면, 반투명의 다양한 모양을 가진 윈도우도 생성 가능합니다.
</p><p>OpenGL 서피스는 <b>QGLWidget</b> 를 통해 구현된 페인트 디바이스입니다. 표준 <b>QPainter</b> 인터페이스는 OpenGL함수 호출로 변환되어, 하드웨어에서 지원하는 2차원 그래픽 가속 기능을 사용할 수 있도록 해 줍니다.
</p><p>이미지 생성시에는, 디바이스 독립적인 <b>QImage</b> 혹은 디스플레이에 최적화된 <b>QPixmap</b> 오브젝트를 이용합니다. 원하는 컬러 뎁스와 픽셀 포맷에 맞추어서 표준 이미지 포맷을 이미지에 렌더링할 수 있습니다. 다양한 반투명도를 가지고 이미지를 생성 가능하며, 몇가지 이펙트를 적용하여 커스텀 위젯 상에서 페인팅할 수 있습니다.
</p><p>벡터 그래픽과 메타파일 포맷도 페인트 시스템에서 지원합니다. <b>QSvgGenerator</b> 는 Scalable Vector Graphics (SVG) 이미지를 생성할 수 있습니다. 적절한 페인팅 커맨드를 SVG파일 포맷상의 관련 구조체에 전달하는 과정을 거칩니다. 일련의 페인팅 커맨드들을 처리하려면 <b>QPicture</b> 를 사용합니다. 커맨드들을 다른 페인팅 디바이스에서 그대로 재현시키거나 파일에 저장할 경우에 사용됩니다.
</p><p>프린터에 출력할 경우에도, 실제 프린터가 <b>QPrinter</b> 에 구현되어 있기 때문에, <b>QPrinter</b> 에 렌더링 명령을 호출함으로써 이루어집니다. Windows의 경우, 프린터 명령은 Windows 프린터 엔진에 보내지게 되며, 이 엔진은 Windows에 설치된 프린터 드라이브를 제어합니다. Unix의 경우, PostScript® 혹은 Portable Document Format (PDF) 데이터가 프린트 데몬으로 보내집니다. 참고로 프린터 데몬은 최신 시스템의 경우 Common Unix Printing System에서 제어합니다. (CUPS)
</p><p>Qt의 범용 페인팅 API를 이용하면, 어플리케이션은 모든 플랫폼상에서 PDF와 PostScript 파일을 생성함으로서 고품질의 문서를 작성할 수 있습니다. 이들 문서는 적절한 뷰어 어플리케이션을 통해 열어볼 수 있습니다.
</p>
<h2><span class="mw-headline" id=".EA.B7.B8.EB.9E.98.ED.94.BD.EC.8A.A4_.EB.B7.B0_.ED.94.84.EB.A0.88.EC.9E.84.EC.9B.8C.ED.81.AC">그래픽스 뷰 프레임워크</span></h2>
<p>Qt는 대량의 2차원 그래픽 오브젝트를 다루는 인터랙티브 그래픽 어플리케이션을 제작할 수 있도록 새로운 프레임워크를 도입하였습니다. 그래픽스 뷰는 2차원 신 안에서 새로운 아이템을 추가할 수 있도록 하는 오브젝트 기반의 API를 제공함은 물론, 미리 정의되어 있는 아이템을 생성하기 위한 편리한 기능들을 담고 있는 기존의 캔버스 기반의 API 역시 제공합니다.
</p><p>일단 아이템을 생성하면, 신 안에서 아이템을 자유자재로 이동, 회전, 확대/축소할 수 있습니다. 아이템을 표시하는 기능과 내부에서 아이템을 관리하는 기능은 <b>QGraphicsView</b> 와 <b>QGraphicsScene</b> 클래스로 나누어져 구현되어 있습니다. 이로 인해 동일한 신을 다른 방식으로 렌더링하는 뷰를 여러 개 구현할 수 있습니다.
</p><p>몇 개의 표준 아이템 타입이 이미 제공되어 있으며 이러한 아이템을 서브클래싱함으로써 독자적인 아이템 타입을 구현할 수 있습니다. 신의 일부분을 보다 효율적으로 관리하기 위해 아이템들은 그룹으로 묶을 수 있습니다. 각각의 신, 뷰, 아이템들은 서로 다른 좌표계를 사용하더라도 다른 좌표계로 편하게 변환할 수 있도록 하는 기능들을 제공하고 있습니다. 유저가 아이템을 선택하거나 이동하게 하는 등의 기본적인 인터액티브 기능을 코드 몇 줄로 간단하게 구현할 수 있습니다. 
</p><p>그래픽스 뷰는 처음부터 애니메이션을 염두해 두고 설계되었기 때문에 아이템을 이용하여 애니메이션 오브젝트를 구현할 수 있습니다. 애니메이션 오브젝트란 어느 시간대에 어떤 모습으로 변형(Transformation)될 것인지를 미리 설정해 놓은 오브젝트를 말합니다.
</p><p>기본으로 제공하는 아이템 중 리치 텍스트 에디터, 웹 브라우징, SVG 같은 아이템들은 그래픽스 뷰 프레임워크가 아닌 Qt내의 다른 부분으로부터 제공받아서 동작합니다. 신에 있는 아이템은, 신과 연결된 뷰의 특성에 맞추어서 렌더링할 수 있는 구조로 되어 있으며, 이로 인해 신은 이미지 파일이나 PDF 파일, 프린터 등으로 다양하게 렌더링 할 수 있습니다.
</p><p>그래픽스 뷰 프레임워크는 이벤트 핸들링 역시 완벽하게 지원하며, 특히 이벤트 핸들링을 원하는 아이템에게만 이벤트를 처리하게 하는 것이 가능합니다. 아이템은 기본적으로 프레임워크상에서 다루어지기 때문에, 아이템은 특정 이벤트가 현 상황에서 필요한지 아닌지에 대해서만 응답하면 됩니다.
</p><p>만약 기존의 QWidget 기반의 UI를 이용해야 한다면 <b>QGraphicsProxyWidget</b> 을 이용하여 기존 위젯에 연결할 수 있으며, 기존 위젯과 유사한 기능을 제공하는 <b>QGraphicsWidget</b> 을 이용할 수도 있습니다. 보다 편리한 유저 인터페이스를 위해, 신 안에서 아이템과 위젯을 효과적으로 배치할 수 있도록, 레이아웃 매니저를 이용할 수 있습니다.
</p><p><br />
<a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/svgviewer-example.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/svgviewer-example.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/svgviewer-example.png</a>
</p><p><i>Qt에서 제공하는 페인트 디바이스상에서 SVG 이미지를 렌더링 할 수 있습니다.</i>
</p>
<h2><span class="mw-headline" id="Scalable_Vector_Graphics_.28SVG.29">Scalable Vector Graphics (SVG)</span></h2>
<p>SVG란 웹상에서 2차원 그래픽 객체를 다루기 위해 작성된 XML 형식의 파일 포맷입니다. Qt에서는 World Wide Web Consortium (W3C®) Recommendation 규격인 SVG 1.1 표준을 지원하며, 또한 추가적으로 SVG 1.1과 1.2의 Tiny 프로파일을 지원합니다.
</p><p>Qt에서는 이미지나 OpenGL위젯을 비롯, 페인터 디바이스로 구현된 곳이라면 어디든지 SVG 형식을 렌더링할 수 있습니다. 이러한 유연성으로 인해 개발자는 필요에 맞게 퀄리티와 성능을 조절하여 사용할 수 있습니다. 기본적인 UI콘트롤인 아이콘을 여러 사이즈에 대응시키기 위해서, 비트맵에서는 미리 특정 사이즈 몇 개를 준비해 놓을 필요성이 있었지만, SVG형식에서는 이러한 수고를 덜 수 있어서 매우 편리합니다.
</p><p>SVG 페인트 디바이스에 특화된 <b>QPainter</b> 를 이용하면, 어플리케이션상에서 사용되는 그래픽 오브젝트들을 간단하게 SVG로 익스포트 할 수 있습니다.
</p>
<h2><span class="mw-headline" id="3D_.EA.B7.B8.EB.9E.98.ED.94.BD.EC.8A.A4">3D 그래픽스</span></h2>
<p>OpenGL은 Qt 어플리케이션상에서 3D 그래픽을 이용하기 위해 사용되는 표준 API입니다. Windows, X11, and Mac OS X상에서 Qt의OpenGL모듈을 사용할 수 있으며 이 모듈은 각각의 시스템상의 네이티브 OpenGL라이브러리를 사용합니다.
</p><p>Qt어플리케이션에서 OpenGL을 이용하기 위해서, 개발자들은 단지 <b>QGLWidget</b> 를 서브클래싱하여 OpenGL 표준 함수를 사용하기만 하면 됩니다. 개발자들이 어플리케이션을 보다 편하게 개발할 수 있도록, Qt에서 사용하는 컬러값을 OpenGL의 컬러포맷으로 변환하는 기능을 제공합니다. 
</p><p>이외에도 Qt는 OpenGL의 기본기능과 확장성을 고려한 편리한 기능들을 제공합니다. 이미지로 부터 텍스쳐를 생성하거나, 픽셀버퍼와 프레임버퍼 오브젝트를 지원하는 클래스들을 제공하며, 몇몇 플랫폼에서는 버퍼의 샘플링 기능을 지원하기도 합니다.
</p><p>2D 그래픽을 사용함에 있어서도 <b>QGLWidget</b> 를 사용하여 하드웨어의 지원을 받아 렌더링 성능을 향상시킬 수 있습니다. 이 경우 <b>QPainter</b> 의 기본 기능들은 내부적으로 OpenGL 함수를 호출하도록 하며, 이로 인해 순수 OpenGL을 이용한 3D 화면에서도 2D 컨트롤들을 합성시킬 수 있습니다. 임베디드 플랫폼은 하드웨어 가속기능에 제한이 있기는 하지만, 다양한 디바이스에서 문제없이 동작할 수 있도록, OpenGL ES 2.0상에서 페인팅 엔진이 구현되어 있습니다. 
</p><p>고성능의 하드웨어에서는 안티 알리아싱 렌더링 기능을 제공하며, OpenGL 페인팅 엔진이 고성능 고퀄리티의 그래픽을 렌더링 할 수 있게 해 줍니다. 그렇지 못한 하드웨어의 경우에는 개발자들은 유저가 퀄리티와 성능 중 하나를 택일할 수 있도록 하는 옵션을 런타임에서 제공할 수 있습니다.
</p>
<h2><span class="mw-headline" id=".EB.A9.80.ED.8B.B0.EB.AF.B8.EB.94.94.EC.96.B4">멀티미디어</span></h2>
<p>Qt는 Phonon이라는 멀티미디오 프레임워크를 이용합니다. Phonon이란 오픈소스 프로젝트인 KDE에서 파생하였으며, 멀티미디어의 재생 기능을 일관성있게 크로스 플랫폼으로 제공합니다. Qt는 Linux/Unix, Windows, Mac OS X 각각의 플랫폼에 있는 멀티미디어 프레임워크를 직접적으로 어플리케이션이 사용할 수 있도록 하고 있습니다. 다시 말해, 어플리케이션은 플랫폼에서 독자적으로 지원하는 오디오, 비디오 코덱이나 포맷을 이용할 수 있게 해 줍니다.
</p><p>Phonon은 Qt에서 제공하는 다른 기술과도 연결되어 사용되고 있습니다. 예를 들어 무비 위젯은 웹킷 브라우저를 사용하여 웹 페이지를 표시하기 위해 사용되며, 그래픽스 뷰 프레임워크에서도 신을 레더링하기 위해 사용됩니다.
</p><p>이외에도 멀티미디어와 관련된 기능을 추가적으로 지원하기 위한 클래스가 QtMultimedia 모듈에서 포함되어 있습니다. 이 클래스들은 주로 오디오와 비디오 데이터에 대한 저수준의 접근방법을 제공합니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_5">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qpainter.html">http://qt.nokia.com/doc/latest/qpainter.html</a> <a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/graphicsview.html">http://qt.nokia.com/doc/latest/graphicsview.html</a>
</p><p><br />
<a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/opengl.html">http://qt.nokia.com/doc/latest/opengl.html</a> <a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtmultimedia.html">http://qt.nokia.com/doc/latest/qtmultimedia.html</a>
</p><p><br />
<a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtsvg.html">http://qt.nokia.com/doc/latest/qtsvg.html</a> <a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/phonon-overview.html">http://qt.nokia.com/doc/latest/phonon-overview.html</a> 
</p>
<h1><span class="mw-headline" id=".EC.95.84.EC.9D.B4.ED.85.9C_.EB.B7.B0">아이템 뷰</span></h1>
<p><i>Qt의 아이템 뷰 위젯은 다량의 데이터를 표시하거나 편집하기 위한 기본적인 GUI 컨트롤들을 제공합니다. 아래에 나와 있는 모델/뷰 프레임워크는 데이터를 저장하는 기능과 데이터를 유저에게 보여주기 위한 기능을 분리하여 구현하고 있습니다. 이로 인해, 동일한 데이터를 가지고 전송(sharing), 정렬, 필터링하거나, 멀티 뷰 기능, 데이터 표현 방법을 다양하게 하는 기능들을 쉽게 구현할 수 있습니다.</i> 
</p><p>대량의 데이터를 처리하는 어플리케이션을 만들 경우, 개발자들은 일반적으로 "item view" 위젯을 이용하여 데이터를 빠르고 효율적으로 표시할 수 있습니다. 최근에 나온 GUI 툴킷들은, 기본적으로 리스트뷰, 트리 뷰, 테이블 뷰를 제공합니다. 리스트뷰는 아이템 리스트를 간단히 표시하기 위한 뷰이며, 트리 뷰는 아이템을 계층적으로 표현하기 위한 뷰이며, 테이블 뷰는 스프레드시트 어플리케이션같은 레이아웃을 제공하기위한 뷰입니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/cleanlooks-treeview.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/cleanlooks-treeview.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/cleanlooks-treeview.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/plastique-listview.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/plastique-listview.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/plastique-listview.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-tableview.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-tableview.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-tableview.png</a>
</p><p><i>Qt에서 기본적으로 제공하는 아이템 뷰에는 트리 뷰, 리스트 뷰, 테이블 뷰가 있습니다.</i>
</p><p>Qt의 아이템 뷰 클래스들을 기존의 아이템 뷰 위젯 형태로, 혹은 모델/뷰 컴포넌트 형태로, 이렇게 두 가지 형태로 사용할 수 있습니다. 기존의 리스트, 테이블, 트리 위젯은 데이터를 관리하는 기능을 자체 내장한 아이템 뷰입니다. 개발자가 만든 아이템 오브젝트를 직접 관리합니다.
</p><p><b>QListView</b>, <b>QTableView</b>, <b>QTreeView</b> 는 기존의 아이템 뷰가 제공하는 동등한 기능을 모델/뷰 컴포넌트 형태로 제공한 것입니다. 이러한 모델/컴포넌트는 클리너라고 불리는, 복수의 데이터 그룹을 다루기 위한 컴포넌트 중심의 방법을 제공합니다. 또한, 개발자들이 데이터를 편리하게 처리할 수 있도록, 기본적인 모델들을 제공합니다. 
</p>
<h2><span class="mw-headline" id=".EA.B8.B0.EB.B3.B8_.EC.95.84.EC.9D.B4.ED.85.9C_.EB.B7.B0">기본 아이템 뷰</span></h2>
<p>Qt에서는 기본적으로 리스트위젯, 아이콘 뷰, 트리 위젯, 테이블을 형태의 아이템 뷰를 지원합니다. 이러한 뷰들은 드래그-앤-드롭 기능을 제공하며, 뷰 내에서 뿐만 아니라 다른 뷰 사이에서도 이용 가능합니다. 다른 Qt 위젯과 마찬가지로, Qt의 리소스 시스템과 완벽히 통합되어 있습니다.
</p><p>아이템 뷰 클래스들은 대개 Qt의 다이얼로그 상에서 사용됩니다. 하지만, <i>Qt Designer</i>, <i>Qt Assistant</i>, <i>Qt Linguist</i> 등에서 폭넓게 사용할 수 있습니다.
</p><p>기존의 아이템 뷰들은 데이터 하나 하나를 캡슐화 하여 오브젝트 역시 그 갯수에 맞게 생성하는 아키텍쳐를 채용하였기 때문에, 대개 수백 개의 데이터를 관리하고 표시하는 데에 적합했습니다. 이러한 방법은 기존의 Qt개발자들에게 매우 익숙한 방법이며, 제한된 용량의 데이터를 다루는 인터페이스를 신속하게 만들 필요가 있을 경우 매우 편리합니다. 
</p><p>기존의 아이템뷰들은 호환성과 유지보수성을 잃지 않으면서, Qt의 모델/뷰 프레임웤으로 재구축 되었습니다. 이로 인해 보다 대량의 데이터를 관리할 수 있게 됨은 물론, 데이터 관리를 커스터마이징하기도 수월해 졌습니다. 
</p>
<h2><span class="mw-headline" id="Qt.EC.9D.98_.EB.AA.A8.EB.8D.B8.2F.EB.B7.B0_.ED.94.84.EB.A0.88.EC.9E.84.EC.9B.8C.ED.81.AC">Qt의 모델/뷰 프레임워크</span></h2>
<p>Qt에서 제공하는 모델/뷰 프레임워크는 유명한 <i>모델-뷰-컨트롤러</i> 패턴으로부터 파생한 것으로, Qt의 아이템 뷰에 맞게 최적화시킨 것입니다. 모델은 다른 컴포넌트에 데이터를 제공하며, 뷰는 유저에게 데이터의 아이템을 출력합니다. 또한 델리게이트는 아이템의 구체적인 표시방법과 데이터를 수정하는 인터랙션 부분을 담당합니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/modelview-delegates.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/modelview-delegates.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/modelview-delegates.png</a>
</p><p><i>모델/뷰 프레임워크는 컴포넌트 지향의 아키텍쳐를 채용하였기 때문에 아이템 뷰를 커스터마이징 하기가 매우 편리합니다.</i>
</p><p>모델이란 데이터를 처리하는 부분을 래핑한 것입니다. 모델은 <b>QAbstractItemModel</b> 가 제공하는 표준 인터페이스에 맞게 구현되었습니다. 이 인터페이스를 통해서, 원본 데이터의 형식에 관계 없이, <b>QAbstractItemView</b> 로부터 파생된 위젯이라면 어느 것이든 모델이 제공하는 데이터에 접근할 수 있습니다. 
</p><p>데이터와 그 표현 방법을 분리하는 개념으로 인해, 기존의 아이템 뷰의 기능을 다양하게 확장할 수 있습니다.
</p>
<ul>
<li> 모델은 데이터에 접근하기 위한 표준 인터페이스를 제공하기 때문에, 모델을 설계하고 작성하기 위해 다른 컴포넌트를 의식할 필요가 없으며, 필요에 따라서는 기존 모델을 다른 것으로 대체할 수도 있습니다.
</li>
<li> 모델을 통해 얻은 데이터는 여러 뷰가 공유할 수 있습니다. 이로 인해, 어플리케이션이 동일한 데이터를 여러 뷰에 전달할 수 있습니다. 즉, 데이터를 여러가지 다른 방식으로 표현하는 것이 가능합니다.
</li>
<li> 특정 뷰에서 선택기능을 사용할 경우에도, 선택기능을 통해 얻은 데이터를 다른 뷰가 접근할 수 있을지를 결정할 수 있습니다.
</li>
<li> 표준 리스트, 트리, 테이블 뷰의 경우, 데이터의 표시는 델리게이트가 처리합니다. 커스터마이즈 시에 새로 작성해야 하는 코드의 양을 획기적으로 줄이고, 보다 간단히 커스터마이징을 할 수 있습니다.
</li>
<li> <i>proxy models</i> 을 이용하면, 모델로부터 제공된 데이터가 뷰에 전달되기 전에 데이터를 가공하는 것이 가능합니다. 어플리케이션이 여러 뷰들에게 동시에, 데이터의 정렬이나 필터링을 사용한 결과를 제공할 수 잇습니다.
</li>
</ul>
<p>모델/뷰 시스템은 Qt의 SQL 모델에서도 사용됩니다. 데이터베이스 개발 경험이 없는 개발자들도 간단히 데이터베이스를 어플리케이션에 적용시킬 수 있습니다. 
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_6">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/model-view-programming.html">http://qt.nokia.com/doc/latest/model-view-programming.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/examples.html">http://qt.nokia.com/doc/latest/examples.html</a> 
</p>
<h1><span class="mw-headline" id=".ED.85.8D.EC.8A.A4.ED.8A.B8_.EC.B2.98.EB.A6.AC">텍스트 처리</span></h1>
<p><i>Qt는 뛰어난 텍스트 에디터 위젯을 제공합니다. 텍스트 위젯을 이용하면, 유저가 리치 텍스트 문서를 작성할 수 있으며 또한 인쇄도 가능합니다. 에디터가 사용하는 기본 도큐먼트 구조체를 개발자는 제한없이 이용할 수 있으며, 구조체의 내용을 변경함은 물론, 그 내부 구조도 변경할 수 있습니다.</i>
</p><p>리치 텍스트 문서는 대개 다양한 폰트와 문서, 글자크기를 한 문단내에 포함시킬 수 있는 텍스트를 말합니다. 텍스트는 리스트나 테이블 구조를 가지며, 프레임을 이용할 경우 문서의 본문과는 시각적으로 분리된 구조를 가질 수도 있습니다. 각 도큐먼트 요소들은, 리치 텍스트 API를 이용해 개발자들이 수많은 변수를 조절하면, 그에 맞춰서 정확하게 화면에 표시됩니다. 
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/textedit-demo.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/textedit-demo.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/textedit-demo.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/textedit-OpenOffice.org.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/textedit-OpenOffice.org.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/textedit-OpenOffice.org.png</a>
</p><p><i>Qt의 뛰어난 리치 텍스트 문서 기능을 가진 <b>QTextEdit</b> (왼쪽) 를 이용하면, 복잡한 문서들을 생성, 편집할 수 있습니다. 문서들은 필요에 따라 OpenDocument 포맷으로 변환할 수 있습니다 (오른쪽).</i>
</p>
<h2><span class="mw-headline" id=".EB.A6.AC.EC.B9.98_.ED.85.8D.EC.8A.A4.ED.8A.B8_.ED.8E.B8.EC.A7.91">리치 텍스트 편집</span></h2>
<p>인터랙티브한 리치텍스트를 표시하거나 편집하는 기능은 각각 <b>QTextBrowser</b> 와 <b>QTextEdit</b> 위젯에서 담당합니다. 이러한 위젯들은 유니코드를 완벽히 지원하며, <b>QTextDocument</b> 가 제공하는 구조화된 문서형식에 기반 하였습니다. <b>QTextDocument</b> 는 리치 텍스트를 작성하기 위해 마크업 언어를 사용할 필요가 없으며, HTML 4.0 에 거의 준하는 형식으로 임포팅, 익스포팅이 가능합니다. 완벽하게 undo/redo 기능(작업을 그룹화 하는 기능을 포함)을 지원하며, 텍스트 이외의 리소스 역시 지원합니다. 
</p><p>개발자들이 문서의 구조를 보다 고수준에서 파악할 수 있도록, Qt에서는 오브젝트 기반의 도큐먼트 API를 제공하며, 문서의 탐색과 번역을 편리하게 할 수 있도록 커서 기반의 API도 제공합니다. 뿐만 아니라 문서의 구성요소들을 표시하기 위해 쓰이는 수많은 클래스가 존재합니다. 이들 클래스들은 테이블, 리스트, 프레임, 문단의 텍스트 스타일을 원하는 대로 표시할 수 있게 하는 커스터마이징을 가능하게 해 줍니다. 
</p><p><b>QTextEdit</b> 위젯에서 생성된 문서는 언제든지 편집가능하며 또한, undo/redo 이력을 온전히 보존합니다. 유저는 기본적인 편집 기능을 사용할 수 있을 뿐만 아니라, 개발자가 추가로 커스터마이징한 구조나 내용을 사용할 수 있습니다.
</p>
<h2><span class="mw-headline" id=".EB.AC.B8.EC.84.9C.EC.9D.98_.EC.BB.A4.EC.8A.A4.ED.84.B0.EB.A7.88.EC.9D.B4.EC.A7.95.2C_.EC.9D.B8.EC.87.84.2C_.EC.9D.B5.EC.8A.A4.ED.8F.AC.ED.8A.B8">문서의 커스터마이징, 인쇄, 익스포트</span></h2>
<p>Qt의 텍스트 처리 기능은 커스텀 위젯, 커스텀 리치 텍스트 문서에 특화된 텍스트 포맷을 제공하는 데에도 쓰입니다. 한 줄 한줄을 어떻게 배치할 지를 설정할 수 있는 <b>QTextLayout</b> 과 같은 저수준 클래스를 통해 이러한 커스터마이징을 구현 가능하며, 이들 기능은 <b>QTextEdit</b> 에서도 이용할 수 있도록, <b>QTextDocument</b> 에서 제공하는 텍스트 레이아웃 시스템의 확장 기능으로써 통합시킬 수 있습니다.
</p><p><b>QSyntaxHighlighter</b> 클래스를 사용하면 리치 텍스트 문서에 신텍스 하이라이팅 규칙을 설정 가능합니다.
이 기능을 이용하면 <b>QTextEdit</b> 를 코드 에디터로 활용할 수 있으며, 문서의 검색 툴에 하이라이팅 기능을 부가할 수도 있습니다.
</p><p>문서는 <b>QPrintDialog</b> 에서 제공하는 정보에 맞춰진 형식을 제공 가능하며, 이 형식은 인쇄를 실행시키기 위한 <b>QPrinter</b> 에 맞도록, 문서를 페이지 단위로 분할됩니다.
</p><p><b>QTextDocumentWriter</b> 클래스는 HTML, 무형식 텍스트, OpenDocument Format (ODF) 파일을 지원합니다. 이 클래스의 기능들을 이용할 수 있도록 광범위한 API가 제공되며, 향후 다른 형식을 지원할 수 있도록 확장성을 갖추었습니다. 
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_7">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qt4-scribe.html">http://qt.nokia.com/doc/latest/qt4-scribe.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/richtext.html">http://qt.nokia.com/doc/latest/richtext.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtextdocumentwriter.html">http://qt.nokia.com/doc/latest/qtextdocumentwriter.html</a> 
</p>
<h1><span class="mw-headline" id=".EC.9B.B9.ED.82.B7.EC.9D.84_.EC.9D.B4.EC.9A.A9.ED.95.9C_.EC.9B.B9.EA.B3.BC.EC.9D.98_.ED.86.B5.ED.95.A9">웹킷을 이용한 웹과의 통합</span></h1>
<p><i>Qt가 웹킷 브라우저 엔진과 통합되었습니다. 웹 컨텐츠를 표시하고 조작하기 위해 Qt식의 API와 패러다임을 제공함으로써, 개발자들은 웹에서 사용하는 기능들을 어플리케이션에 도입할 수 있게 되었습니다.</i>
</p><p>Qt는 웹킷이라고 하는, 안정성과 성능을 동시에 추구하는, 오픈소스 기반의 웹 렌더링 엔진을 통합시켰습니다. Qt에 통합된 웹킷 버전은 HTML 4.01, XHTML 1.1, CSS 2.1, JavaScript 1.5 을 포함해, 다양한 웹 표준을 지원하며, 보다 최신의 기능 역시 지원 가능합니다. 이와 관련한 보다 자세한 내용은 <a rel="nofollow" class="external text" href="http://qt.nokia.com/forms/whitepapers/reg-whitepaper-hybrid/">WebKit in Qt</a> 백서를 참조하세요.
</p><p>웹킷의 네트워크 부분은 Qt의 네트워크 관련 클래스를 그대로 사용합니다. 이 클래스들은
Secure Sockets Layer (SSL) 통신과 프록시를 지원해야 하는 HTTP 1.1 사양을 완벽하게 구현하였습니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/webkit-plus-graphics-view.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/webkit-plus-graphics-view.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/webkit-plus-graphics-view.png</a>
</p><p><i>Qt와 통합된 엡킷 상에서 웹 페이지의 위젯은 Qt 위젯을 사용합니다. 정확히 말하자면, 웹 페이지 자체가 Graphics View의 아이템 일부로써 표시됩니다.</i> 
</p>
<h2><span class="mw-headline" id=".EB.84.A4.EC.9D.B4.ED.8B.B0.EB.B8.8C_.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EA.B3.BC.EC.9D.98_.ED.86.B5.ED.95.A9">네이티브 어플리케이션과의 통합</span></h2>
<p>Qt는 단순히 HTML을 렌더링하기 위해 웹킷을 지원하는 것이 아닙니다. Qt의 패러다임이 적용된 웹킷 기능을 어플리케이션에서도 이용할 수 있습니다. 예를 들어, Qt의 시그널-슬롯 통신 메커니즘을 이용하면 개발자들은 웹 관련 컴포넌트를 어플리케이션 내의 다른 오브젝트와 간단히 연결시킬 수 있습니다.
</p><p>반대로, Qt와 브라우저가 통합됨으로써 네이티브 Qt 기능들을 웹 페이지안에서 사용할 수도 있습니다. 이로 인해 매우 동적인 네이티브 유저 인터페이스를 웹페이지에서 작성할 수 있게 되었습니다.
</p><p>웹킷의 네이티브 스토리지 기능을 이용하면, 웹 어플리케이션이 영구적으로 데이터를 저장할 수 있는데, 이러한 기능을 Qt에서도 사용할 수 있습니다. 개발자는 리모트 서비스와 연계되는 어플리케이션을 개발하기 위해 네이티브 스토리지를 이용할 수 있으며, 이 때 유저의 시스템에서 설정된 저장 위치나 한도를 참조 할 수 있습니다.
</p>
<h2><span class="mw-headline" id="DOM_.EC.B0.B8.EC.A1.B0.EC.9A.A9_API">DOM 참조용 API</span></h2>
<p>웹페이지 구조를 다루기 위한 표준적인 방법은 Document Object Model (DOM) API를 이용하는 것입니다. W3C는 DOM으로 된 구조를 탐색하거나 수정하기가 용이하도록 하기 위한 셀렉터 API 를 정의해 놓고 있습니다. Qt와 통합된 웹킷은 셀렉터 API를 구현해 놓았습니다. 
</p><p>이러한 API로 인해, 개발자들은 CSS 셀렉터 지식을 활용하여 DOM에 직관적으로 접근할 수 있습니다. 또한 유지보수나 풋프린트와 관련된 오버헤드를 줄일 수 있습니다. 
</p>
<h2><span class="mw-headline" id=".EB.84.B7.EC.8A.A4.EC.BC.80.EC.9D.B4.ED.94.84_.ED.94.8C.EB.9F.AC.EA.B7.B8.EC.9D.B8_.EC.A7.80.EC.9B.90">넷스케이프 플러그인 지원</span></h2>
<p>서드파티용 브라우저 컴포넌트 API로써 사실상 표준(de-facto standard)으로 인정받는, 넷스케이프 플러그인 API를 준수하는 플러그인을, 통합 Qt웹킷 기반의 웹 페이지에 포함시키거나 표시할 수 있습니다. 이러한 기능들을 설정하는 작업은 Qt의 플러그인 설정 관련 클래스를 통해 이루어집니다. 이러한 설정관련 플러그인에 사용되는 클래스들은, 어플리케이션용 기능을 웹 환경에서도 사용할 수 있도록 하는 위젯 플러그인 등에 사용되었던 것들이 웹킷에 적용된 것입니다. 
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/webkit-netscape-plugin.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/webkit-netscape-plugin.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/webkit-netscape-plugin.png</a>
</p><p><i>통합된 Qt 웹킷은, 넷스케이프 플러그인 API를 사용하는 서드 파티 브라우저 플러그인을 지원합니다.</i>
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_8">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtwebkit.html">http://qt.nokia.com/doc/latest/qtwebkit.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/demos-browser.html">http://qt.nokia.com/doc/latest/demos-browser.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/forms/whitepapers/reg-whitepaper-hybrid/">http://qt.nokia.com/forms/whitepapers/reg-whitepaper-hybrid/</a> 
</p>
<h1><span class="mw-headline" id=".EB.8D.B0.EC.9D.B4.ED.84.B0.EB.B2.A0.EC.9D.B4.EC.8A.A4">데이터베이스</span></h1>
<p><i>Qt SQL 모듈을 이용하면, GUI와 데이터 베이스가 연계된 크로스 플랫폼 어플리케이션을 쉽게 개발할 수 있습니다. 프로그래머는 간편하게 SQL 쿼리문을 실행할 수 있습니다. 데이터베이스 모델을 이용하여 아이템 뷰에 적절한 정보를 제공함으로써 정보를 표시하거나 데이터 입력을 받을 수도 있습니다. 또한 위젯 맵퍼를 이용하여, 폼 기반의 유저 인터페이스 상에서 특정 위젯에 데이터베이스 테이블을 맵핑할 수 있습니다.</i>
</p><p>Qt SQL 모듈은 SQL 데이터베이스에 접근하기 위한 크로스 플랫폼 인터페이스를 제공합니다. 또한 이 묘듈은 Oracle, Microsoft SQL Server, Sybase Adaptive Server, IBM DB2, PostgreSQL, MySQL, Borland Interbase, SQLite, ODBC 연계를 위한 네이티브 드라이버가 들어 있습니다. 클라이언트에서 관련 라이브러리가 제대로 동작한다면 Qt가 지원하는 모든 플랫폼상에서, 이들 드라이버를 사용할 수 있습니다. 동시에 한 어플리케이션이 여러 데이터베이스를 이용할 수도 있습니다. Qt 배포판은 기본적으로 SQLite 데이터베이스를 포함하고 있으며, Qt SQL 모듈은 기본 데이터베이스로써 SQLite를 지원합니다.
</p><p>개발자는 간단히 SQL 쿼리문을 실행할 수 있으며, Qt에서 제공하는 고수준의 C<i>+ 인터페이스를 이용하여 적절한 SQL 쿼리문을 자동으로 생성할 수 있습니다.</i>
</p><p>Qt는 모델/뷰 컴포넌트 구조에서 사용가능한 SQL 모델을 제공합니다. SQL 모델을 이용하면 뷰 위젯이 데이터 베이스 쿼리 결과가 반환될 때 자동으로 갱신되며, 데이터베이스에 문외한인 개발자나 사용자도 간단히 편집작업을 할 수 있습니다.
</p><p>SQL 모듈이 제공하는 편리한 기능들을 이용하면, 데이터베이스 사용하는 어플리케이션을 바로 만들 수 있습니다. 외부키를 통한 탐색 기능과 master-detail 관계를 나타내는 기능을 사용가능합니다.
</p>
<h2><span class="mw-headline" id="SQL_.EB.AA.85.EB.A0.B9_.EC.8B.A4.ED.96.89.ED.95.98.EA.B8.B0">SQL 명령 실행하기</span></h2>
<b>QSqlQuery</b> 클래스를 사용하면, 직접 SQL문을 실행할 수 있으며, <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">SELECT</pre></div></div> 쿼리 결과를 살펴볼 수도 있습니다. 물론, <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">INSERT</pre></div></div>, <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">UPDATE</pre></div></div>, <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">DELETE</pre></div></div> 쿼리도 간단히 사용할 수 있습니다.
<p>Qt SQL 모듈은 값 바인딩(value binding)과 준비된 쿼리(prepared queries)를 지원합니다. 값 바인딩은 named binding, named placeholders, positional binding with named, positional placeholders을 통해 이루어집니다. Qt의 바인딩 관련 문법은 Qt에서 지원하는 모든 데이터베이스에서 작동합니다. Qt에서 지원하는 데이터베이스 중에는 바인딩 기능이 제공되지 않는 것도 있으나, 에뮬레이션을 통해 Qt에서 지원할 수 있도록 구현하였습니다.
</p>
<h2><span class="mw-headline" id="SQL_.EB.AA.A8.EB.8D.B8">SQL 모델</span></h2>
<p>Qt는 또한 모델/뷰 프레임워크 상에서 다른 컴포넌트와 함게 사용할 수 있는 모델 클래스들을 제공합니다. 이러한 모델 클래스들을 이용하면, 개발자가 SQL 쿼리를 실행하기만 해도 자동적으로 그 결과가 테이블 뷰에 반영됩니다.
</p><p>개발자는 최소한의 코딩으로 이와 같은 기능을 구현할 수 있습니다. 쿼리 모델을 설정할 때에는, 쿼리문을 지정하고, 어느 헤더가 필요한지를 정합니다. 그 다음, 반환된 쿼리 결과를 표시할 테이블 뷰를 설정합니다.
</p><p>Qt는 다양한 방식의 SQL 테이블 관련 모델을 제공합니다. SQL쿼리 결과를 읽기 전용으로 다루는 데이터 모델, 단일 테이블 상에서 편집 가능한 데이터 모델, 외부 키를 가지는 관계형 모델이 존재합니다. Qt Books 데모에서는 관계형 데이터베이스 모델이 테이블 상에서 관련 정보를 어떻게 찾는지를 볼 수 있습니다.
</p><p>모델/뷰 프레임워크에는 데이터베이스와 연계된 요청들을 처리하기 위한 수많은 기능들이 들어 있습니다. 트랜잭션 기능, 데이터베이스의 라운드 트립을 피하기 위해 행 단위로 데이터를 편집할 수 있는 기능들이 포함됩니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/books-demo.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/books-demo.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/books-demo.png</a>
</p><p><i>Qt Books 데모에서는 Qt의 SQL 클래스와 모델/뷰 프레임워크가 연계된 모습을 볼 수 있습니다.</i>
</p>
<h2><span class="mw-headline" id=".EB.8D.B0.EC.9D.B4.ED.84.B0_.EB.B3.80.EA.B2.BD.EC.97.90_.EB.B0.98.EC.9D.91.ED.95.98.EB.8A.94_.EC.9C.84.EC.A0.AF_Data-Aware_Widgets">데이터 변경에 반응하는 위젯 Data-Aware Widgets</span></h2>
<p>SQL 모델을 비롯, 모델로부터 얻은 데이터는 윈도우상의 특정 위젯과 연결됨으로써, 데이터의 특정 부분을 유저에게 표시할 수 있습니다. 이것을 이용하면, 폼 기반으로 데이터를 입력할 수 있는 편리한 인터페이스를 보다 쉽게 개발할 수 있습니다.
</p><p>유저가 선택한 위젯과 모델 사이에서 맵핑을 설정해야 할 때는 <b>QDataWidgetMapper</b> 가 사용됩니다. Books 데모에서는, 데이터 맵퍼가 생성되어 모델에 연결되면, 위젯들과 데이터 베이스 컬럼들이 일 대 일로 매칭되어, 데이터베이스의 필드를 위젯에서 수정할 수 있습니다.
</p><p>이처럼 데이터 맵퍼를 이용해 컬럼에 있는 항목들을 특정 위젯에 매핑시키고, 이들 데이터를 시각화 함으로써, 모델의 한 행을 직접적으로 제어할 수 있게 됩니다. 또한 '쉬운 탐색 컨트롤(위젯?)'을 맵퍼에 연결시킴으로써 보다 간단히 탐색 기능을 구현할 수 있습니다.
</p><p>이러한 클래스들은 아이템 뷰 클래스와 비슷한 API를 가지고 있기 때문에, 맵퍼의 설정을 바꿈으로써 간단히 모델의 다른 역역에 있는 데이터를 가져올 수가 있습니다. 모델/뷰 API를 적절히 활용하면, 데이터 모델이 바뀔 시점에 데이터 맵퍼가 반응하도록 할 수 있습니다. Books 데모에서는, 유저가 테이블뷰 내에서 행 선택을 바꿀(이러한 동작은 시그널/슬롯 연결을 통해 간단히 구현됩니다.) 때 마다 그에 맞춰서 매핑이 달라지는 것을 볼 수 있습니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_9">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtsql.html">http://qt.nokia.com/doc/latest/qtsql.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qt4-sql.html">http://qt.nokia.com/doc/latest/qt4-sql.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/examples.html">http://qt.nokia.com/doc/latest/examples.html</a>
</p>
<h1><span class="mw-headline" id=".EA.B5.AD.EC.A0.9C.ED.99.94">국제화</span></h1>
<p><i>Qt는 국제 표준규격인 유니코드를 완벽히 지원합니다. 프로그래머는 아랍어, 영어, 히브리어, 일본어, 러시아어 등 여러 언어를 어플리케이션 상에서 혼합하여 사용할 수 있습니다. 또한 Qt는 어플리케이션의 언어 변환과 로컬화 기능을 지원합니다.</i>
</p><p>Qt는 유니코드 5.0 버전 캐릭터 엔코딩을 지원하며, Qt는 외부 API는 물론 내부적으로도 <b>QString</b> 을 사용하여 유니코드 문자열을 취급합니다.
</p><p>이 외에도 중국어 Big5, GBK용 코덱, 일본어 EUC-JP, JIS, Shift-JIS용 코덱, 러시아 KOI8-R용 코덱 등, ISO-8859에서 채택된 코드의 인코딩을 지원합니다^1. Qt에서는 이러한 코덱을 폰트 입력과 출력, 입력기 기능을 구현하는 데에 사용합니다.
</p><p>Qt가 기본으로 제공하는 로컬화 기능을 이용하면, 유저가 살고 있는 지역이나 사용하는 언어환경에 맞춰서 숫자-문자열, 문자열-숫자 변환이 가능합니다.
</p><p>Qt는 언어 변환 기능을 보다 편하게 할 수 있도록 몇 가지 툴들을 제공하고 있습니다. XML Localization Interchange File Format (XLIFF), GNU Gettext PO 포맷, Qt 독자 포맷인 Translation Source (TS) 파일을 지원합니다.
</p>
<h2><span class="mw-headline" id=".ED.85.8D.EC.8A.A4.ED.8A.B8_.EC.9E.85.EB.A0.A5.EA.B3.BC_.EB.A0.8C.EB.8D.94.EB.A7.81">텍스트 입력과 렌더링</span></h2>
<p>동아시아 국가의 문자 입력을 위해서는 키보드의 키 보다 더 많은 문자를 필요로 합니다. 일련의 키 입력 조합으로 문자를 표시하는 기능은 <i>입력기(Input methods)</i> 를 통해 윈도우 시스템 층에서 수행됩니다. Qt는 유저의 시스템 설정에 맞게 자동적으로 입력기를 설치하는 기능을 제공합니다.
</p><p>Qt는 매우 강력한 텍스트 렌더링 엔진을 제공합니다. 줄바꿈 처리 기능, 양방향 텍스트 입력, 발음 구별 기호 입력 기능 등을 지원합니다. Qt는 아랍어, 중국어, 키릴어, 그리스어, 히브루어, 일본어, 한국어, 라틴어, 베트남어 등 거의 모든 문자를 표현 가능합니다. 또한 Qt는 다언어 텍스트를 렌더링 하기 위해, 현재 설치되어 있는 폰트 중에서 언어에 맞게 자동적으로 선택하여 혼합시켜 렌더링 해 줍니다.
</p>
<h2><span class="mw-headline" id=".EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EC.9D.98_.EC.96.B8.EC.96.B4_.EB.B2.88.EC.97.AD">어플리케이션의 언어 번역</span></h2>
<p>Qt는 유저가 원하는 언어에 맞게 어플리케이션을 사용할 수 있도록, 개발자들에게 관련 툴과 기능들을 제공합니다. Qt는 프랑스어, 독일어, 중구어 간자체의 번역을 보다 쉽게 할 수 있도록, 내부적으로 몇 백개의 유저를 위한 관련 어휘 스트링을 미리 담고 있습니다.
</p>
스트링의 번역을 실행하기 위해서는 개발자들은 단순히 코드 안의 스트링을 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">tr<span class="br0">&#40;</span><span class="br0">&#41;</span></pre></div></div> 함수로 감싸기만 하면 됩니다. 번역자에게 보다 유용한 추가 정보를 제공할 수 있도록 특수한 코드 주석 작성법을 제공합니다.
<p>&lt;/code&gt;//: This name refers to a host name.
</p><p>hostNameLabel-&gt;setText(tr("Name:"));
</p><p>/*: This text refers to a C++ code example. */
</p>
QString example = tr("Example");<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">위 문맥에서<span class="sy0">,</span> 주석 정보를 통해 번역자가 보다 유저 친화적인 스트링을 정확하게 번역할 수 있도록 해 줍니다. 여러 폼을 번역하기 쉽게할 수 있도록 추가적인 인자를 사용할 수도 있습니다.
&#160;
<span class="kw5">Qt</span>는 프로젝트 소스에서 텍스트 파일을 추출하고<span class="sy0">,</span> 이를 표준 번역 포맷으로 변환하여<span class="sy0">,</span> 어플리케이션에 탑재할 수 있도록 메시지 파일을 압축해 주는 툴을 제공합니다. 이러한 텍스트 추출<span class="sy0">,</span> 업데이트 과정은 <span class="kw5">Qt</span> 어플리케이션의 빌드 시스템에 통합되어 있으며 만약 다른 번역 작업 절차를 사용할 경우에는 수정도 가능합니다.
&#160;
런타임 상에서 번역 파일을 로드할 때에는 <span class="st0">''</span><span class="st0">'QTranslator'</span><span class="st0">''</span> 오브젝트를 이용합니다. 각각의 파일은 오직 특정 언어 하나를 위한 번역 내용을 담고 있습니다. 시스템의 로케일 설정<span class="sy0">,</span> 혹은 유저의 선택에 따라 런타임에서 언어를 설정 가능합니다.
&#160;
<span class="st0">''</span><span class="kw5">Qt</span> Linguist<span class="st0">''</span> 라는 번역 작업용 GUI 어플리케이션을 이용하면 번역자들은 보다 편리하게 번역 파일을 편집가능합니다. 번역 문맥의 리스트는 어플리케이션의 좌측에 배치되며 현재 선택된 문맥의 원본 텍스트는 오른쪽 윗부분에 현재 번역 상태<span class="br0">&#40;</span>미완료<span class="sy0">,</span> 미착수<span class="sy0">,</span> 완료<span class="br0">&#41;</span>와 함께 표시됩니다. 유저 인터페이스는 키보드를 통해 조작 가능하며<span class="sy0">,</span> 위도우의 배치는 번역자가 자유로이 설정 가능합니다.
&#160;
때로는 어플리케이션상에서 다른 텍스트 소스가 같은 구절로 반복되어 사용되는 경우가 있습니다. <span class="st0">''</span><span class="kw5">Qt</span> Linguist<span class="st0">''</span> 는 이전에 번역된 스트링과 미리 정의된 번역내용을 기반으로 지능적으로 예측 후보를 리스트에 표시합니다. 이러한 기능은 새 번역 작업을 시작할 때 매우 요긴하게 쓰입니다. 기본 제공되는 번역 정보 역시 구절 데이터베이스에 저장 가능하며<span class="sy0">,</span> 이를 통해 향후 어플리케이션의 번역 작업을 보다 효율적으로 수행할 수 있습니다. 또한 <span class="st0">''</span><span class="kw5">Qt</span> Linguist<span class="st0">''</span> 는 단축키 설정이나 마침표 등이 제대로 번역되었는지를 검증하는 기능도 가지고 있습니다.
&#160;
<span class="st0">''</span><span class="kw5">Qt</span> Linguist<span class="st0">''</span> 의 종합 매뉴얼은 릴리즈 매니저<span class="sy0">,</span> 번역자<span class="sy0">,</span> 프로그래머가 어떻게 번역 작업 절차를 수행할 것인지에 관해 유용한 정보를 제공합니다.
&#160;
<span class="br0">&#91;</span><span class="br0">&#91;</span>Image<span class="sy0">:</span>http<span class="sy0">:</span><span class="co1">//doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qt-linguist.png|http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qt-linguist.png]]</span>
&#160;
<span class="st0">''</span><span class="kw5">Qt</span> Linguist를 이용해 프랑스어와 중궁어 간자체 번역을 동시에 작업 중.<span class="st0">''</span>
&#160;
<span class="sy0">===</span> 온라인 리퍼런스 <span class="sy0">===</span>
&#160;
<span class="br0">&#91;</span>http<span class="sy0">:</span><span class="co1">//qt.nokia.com/doc/latest/i18n.html http://qt.nokia.com/doc/latest/i18n.html] [http://qt.nokia.com/doc/latest/linguist-manual.html http://qt.nokia.com/doc/latest/linguist-manual.html]</span>
&#160;
<span class="br0">&#91;</span>http<span class="sy0">:</span><span class="co1">//qt.nokia.com/doc/latest/unicode.html http://qt.nokia.com/doc/latest/unicode.html] [http://qt.nokia.com/doc/latest/qtextcodec.html http://qt.nokia.com/doc/latest/qtextcodec.html]</span>
&#160;
<span class="sy0">=</span> <span class="kw5">Qt</span> 스크립트 <span class="sy0">=</span>
&#160;
<span class="st0">''</span><span class="kw5">Qt</span> 스크립트는 <span class="kw5">Qt</span>로 어플리케이션용 스크립트로써 ECMA스크립트 기반의 인터프리터 언어입니다. <span class="kw5">Qt</span> 스크립트 모듈은 어플리케이션의 기능들을 간단히 스크립팅 환경에 노출시킬 수 있도록 하는 API를 제공합니다. 이들 API에는 <span class="kw5">Qt</span>의 표준 기능과 시그널<span class="sy0">-</span>슬롯 통신을 포함하고 있습니다.<span class="st0">''</span>
&#160;
어플리케이션 스크립팅 기능을 통해 유저는 커스터마이징이나 어플리케이션의 기능을 확장시킬 수 있으며<span class="sy0">,</span> 이것은 유저용 스크립팅 언어를 위한 API를 호출함으로써 가능합니다. 지금까지 <span class="kw5">Qt</span> 개발자들은 스크립트 기능을 지원하기 위하여 다양한 방법을 독자적으로 구축하여 왔습니다. <span class="kw5">QtScript</span>를 <span class="kw5">Qt</span> 모듈군에 포함시킨 이유는<span class="sy0">,</span> 스크립트라는 강력한 기능이 필요한 개발자들이<span class="sy0">,</span> 구현 절차를 보다 단순화 시키킴으로써<span class="sy0">,</span> 구현에 필요한 노력을 단축시키기 위함입니다.
&#160;
<span class="sy0">==</span> 스크립팅 아키텍쳐 <span class="sy0">==</span>
&#160;
<span class="kw5">QtScript</span> 모듈은 <span class="st0">''</span><span class="st0">'QScriptEngine'</span><span class="st0">''</span> 나 <span class="st0">''</span><span class="st0">'QScriptValue'</span><span class="st0">''</span> 와 같은 클래스를 기반으로 한 API를 제공합니다. 이러한 API는 실행 기능이나 데이터 마샬링을 제공합니다.
&#160;
<span class="st0">''</span><span class="st0">'QScriptEngine'</span><span class="st0">''</span> 의 인스턴스의 역할은 <span class="kw5">Qt</span> 스크립트 코드를 스크립팅 환경에서 실행시키는 것이며<span class="sy0">,</span> 스크립트 환경에서 <span class="st0">''</span><span class="st0">'QObject'</span><span class="st0">''</span> 기반의 클래스 인스턴스를 노출시키도록 해 줍니다. 또한 <span class="st0">''</span><span class="st0">'QScriptEngine'</span><span class="st0">''</span> 을 통해 C<span class="sy0">++</span> 데이터 타입을 <span class="kw5">Qt</span> 스크립트에서 호환 가능한 타입으로 변환시켜서 스크립팅 환경에 추가시킵니다. <span class="kw5">Qt</span> 스크립트 데이터 타입은 C<span class="sy0">+</span><span class="st0">''</span>에서는 <span class="st0">''</span><span class="st0">'QScriptValue'</span><span class="st0">''</span> 형식의 인스턴스로 표현되며 이들은 C<span class="st0">''</span><span class="sy0">+</span> 기본 데이터 타입을 스크립팅 용으로 변환시키는 기능을 가지고 있습니다.
&#160;
또한 시그널 슬롯 역시 <span class="kw5">Qt</span> 스크립트와 어플리케이션 사이에서 동작할 수 있습니다. <span class="kw5">Qt</span> 스크립트 오브젝트는 시그널을 발생시킬 수 있으며<span class="sy0">,</span> <span class="kw5">Qt</span> 스크립트의 함수는 모두 슬롯으로써 기능할 수 있습니다. 스크립트 작성자가 다이나믹 스크립트 언어에서 원하는 기능을 다양한 레벨의 유연성을 가지면서 제공할 수 있습니다.
&#160;
<span class="kw5">QtScript</span> 모듈을 이용한 샘플중 가장 단순한 것은<span class="sy0">,</span> 유저가 작성한 코드를 실행하는 <span class="kw5">Qt</span> 스크립트 인터프리터입니다.</pre></div></div>QScriptEngine engine;
QScriptValue result = engine.evaluate(userCode);<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="st0">''</span><span class="st0">'QScriptEngine'</span><span class="st0">''</span> 인스턴스는 구문 오류와 런타임 에러를 보고해 줍니다.
&#160;
위 사진은 <span class="kw5">Qt</span> 스크립트를 어플리케이션에 통합하기 위해 <span class="kw5">QtScript</span> 모듈의 기능을 이용한 예입니다. <span class="st0">''</span><span class="st0">'QObject'</span><span class="st0">''</span> 기반의 이미지 관련 클래스 래퍼는 다양한 함수와 프로퍼티를 제공한 클래스로써<span class="sy0">,</span> 이 클래스는 아래와 같은 방법을 통해 스크립팅 환경에 노출됩니다.</pre></div></div>image = new ImageWrapper(this);
<p>QScriptValue imageObject = engine.newQObject(image);
</p>
engine.globalObject().setProperty("image", imageObject);<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">일단 스크립팅 환경에 클래스를 정의시켜 놓으면<span class="sy0">,</span> 유저는 하위 부분을 캡슐화 시킨 단순한 API를 이용하여 간단히 이미지를 조작할 수 있게 됩니다.
&#160;
<span class="br0">&#91;</span><span class="br0">&#91;</span>Image<span class="sy0">:</span>http<span class="sy0">:</span><span class="co1">//doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qtscript-debugger.png|http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qtscript-debugger.png]]</span>
&#160;
<span class="st0">''</span><span class="kw5">Qt</span> 스크립트의 디버거 유저 인터페이스를 이용하여 함수를 디버깅.<span class="st0">''</span>
&#160;
<span class="sy0">==</span> 디버깅 <span class="sy0">==</span>
&#160;
<span class="kw5">QtScriptTools</span> 모듈을 통해 스크립트를 디버깅할 수 있습니다. 이 모듈은 스크립트 기능을 가진 어플리케이션을 만들 때 사용하는 다양한 그래픽 컴포넌트가 들어가 있습니다.
&#160;
<span class="st0">''</span><span class="st0">'QScriptEngineDebugger'</span><span class="st0">''</span> 클래스는 매우 사용하기 쉽도록 설계되엇습니다. 디버거의 구현과 스크립트를 분리되어 있어서<span class="sy0">,</span> 디버거를 적용 시키는 작업이 매우 간단하고 독립적입니다. 즉<span class="sy0">,</span> 스크립트 엔진에 디버거를 적용하기 위한 코드가 자체적으로 내장되어 있으며<span class="sy0">,</span> 필요없을 경우 간단히 삭제 가능합니다.
&#160;
스크립트 디버거는 소스코드와 브레이크 포인트<span class="sy0">,</span> 변수<span class="sy0">,</span> 그 밖에 스크립트 실행시에 얻을 수 있는 유용한 정보 등을 표시하기 위한 위젯을 기본적으로 내장하고 있습니다. 이러한 위젯들은 자유롭게 재배치가 가능합니다.
&#160;
스크립트 디버거는 이 외에도 디버깅 인터페이스를 커스터마이즈 할 수 있는 메뉴와 툴바를 기본으로 제공하고 있습니다. 툴바에서는 액션과 연결되어 있는 버튼들이 들어가 있으며<span class="sy0">,</span> 이러한 액션은 스크립트의 실행을 제어하기 위해 의도적으로 트리거 될 수 있습니다.
&#160;
디버거는 유저 인터페이스 없이도 실행할 수 있습니다. 개발자는 에러가 발생하거나 브레이크 포인트에 도달하기 전까지는 유저인터페이스를 표시하지 않도록 옵션을 설정할 수 있습니다.
&#160;
유저 매뉴얼에서는 디버거 유저 인터페이스의 이용법이 기술되어 있으며 디버깅 콘솔에서 사용가능한 명령어들에 대한 설명을 담고 있습니다.
&#160;
<span class="sy0">===</span> 온라인 리퍼런스 <span class="sy0">===</span>
&#160;
<span class="br0">&#91;</span>http<span class="sy0">:</span><span class="co1">//qt.nokia.com/doc/latest/qtscript.html http://qt.nokia.com/doc/latest/qtscript.html]</span>
&#160;
<span class="br0">&#91;</span>http<span class="sy0">:</span><span class="co1">//qt.nokia.com/doc/latest/qtscripttools.html http://qt.nokia.com/doc/latest/qtscripttools.html]</span>
&#160;
<span class="sy0">=</span> 스타일과 테마 <span class="sy0">=</span>
&#160;
<span class="st0">''</span><span class="kw5">Qt</span> 어플리케이션의 룩앤필은 자동적으로 네이티브 데스크탑 스타일을 따릅니다. <span class="kw5">Qt</span> 어플리케이션은 유저가 설정한 색상<span class="sy0">,</span> 폰트<span class="sy0">,</span> 사운드를 사용할 수도 다른 데스크탑 설정을 사용할 수도 있습니다. <span class="kw5">Qt</span> 프로그래머는 기본적으로 제공하는 스타일을 자유롭게 사용 가능하며 이들 기능을 무시하는 것도 가능합니다. 프로그래머들은 기존의 스타일을 변경하거나 <span class="kw5">Qt</span>의 강력한 스타일 엔진을 이용하여 완전 독자적인 스타일을 만들 수도 있습니다.<span class="st0">''</span>
&#160;
스타일은 특정 플랫폼의 유저인터페이스 룩앤필을 구현합니다. 스타일은 <span class="st0">''</span><span class="st0">'QStyle'</span><span class="st0">''</span> 라는<span class="sy0">,</span> 프레임<span class="sy0">,</span> 버튼<span class="sy0">,</span> 이미지간은 기능을 표시하는 기능을 가진 클래스의 상속 클래스입니다. <span class="kw5">Qt</span>의 모든 위젯은 속도와 유연성을 위해<span class="sy0">,</span> 렌더링을 자체적으로 구현하였습니다.
&#160;
<span class="sy0">==</span> 기본으로 제공되는 스타일 <span class="sy0">==</span>
&#160;
<span class="kw5">Qt</span>에서 기본으로 제공되는 스타일은 다음과 같습니다 <span class="sy0">-</span> CDE<span class="sy0">,</span> Cleanlooks<span class="sy0">,</span> GTK<span class="sy0">,</span> Motif<span class="sy0">,</span> Mac OS X<span class="sy0">,</span> Plastique<span class="sy0">,</span> Windows<span class="sy0">,</span> Windows XP<span class="sy0">,</span> Windows Vista. 기본적으로<span class="sy0">,</span> <span class="kw5">Qt</span>는 유저의 플랫폼과 데스크탑 환경에 맞는 스타일을 적용합니다. 물론 스타일은 <span class="sy0">&lt;</span>code<span class="sy0">&gt;-</span>style</pre></div></div> 명령 옵션을 통해, 어플리케이션 개발자나 유저가 직접 변경 가능합니다.
<p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qstyle-comboboxes.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qstyle-comboboxes.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qstyle-comboboxes.png</a>
</p><p><i>다른 네이티브 스타일이 적용된 콤보 박스.</i>
</p><p>유저가 데스크탑 설정에서 색상, 폰트, 사운드 등을 변경하면 스타일도 이에 맞게 설정됩니다. Qt는 자동적으로 컴퓨터의 액티브 테마에 맞춰집니다. 예를 들어 Qt는 메뉴와 툴팁의 스크롤과 페이드 전환을 지원합니다.
</p><p>Windows와 Mac OS X 스타일은 스타일 매니저와는 상관 없이 빌드되었기 때문에, 이들 스타일은 다른 플랫폼에서는 사용할 수 없습니다. 다른 스타일은 Qt에서 에뮬레이션한 경우로, 플랫폼의 제약 없이 사용 가능합니다.
</p><p>최신 X11 플랫폼에서 사용하는 기본 스타일은 <i>Plastique</i> 으로, KDE와 <i>GTK</i> 용 Plastik 위젯 스타일로부터 영향을 받았습니다. GTK 기반의 또 다른 스타일인 Cleanlooks는 GNOME용 Clearlooks 테마를 모방한 것입니다.
</p><p>Qt가 기본으로 제공하는 위젯들은 스타일 변경이 런타임에 가능합니다. 커스텀 위젯과 다이얼로그는 기본 위젯이나 레이아웃과 섞여서 사용되는 것이 일반적입니다만, 이런 경우에도 현재 사용중인 스타일에 맞춰줍니다. 때로는, 간편히 커스텀 위젯을 만들기 위해, 기존의 그래픽 요소를 직접 사용하여 렌더링하기 보다, Qt의 스타일 API를 이용하기도 합니다.
</p><p>기본적으로 위젯은 오른쪽 방향으로 위젯을 배치합니다만, 번역파일의 언어를 참조하여 필요할 경우 자동적으로 레이아웃을 왼쪽 방향으로 바꾸기도 합니다. 또한 반전 모드를 사용하면, 유저의 데스크탑 환경에 맞게 위젯의 조명과 그림자 효과를 줄 수도 있습니다.
</p>
<h2><span class="mw-headline" id=".EC.9C.84.EC.A0.AF_.EC.8A.A4.ED.83.80.EC.9D.BC_.EC.8B.9C.ED.8A.B8">위젯 스타일 시트</span></h2>
Qt는 거의 모든 기본 위젯들에 위젯 스타일 시트를 적용 가능합니다. 텍스트 형식으로 되어 있으며 CSS와 비슷한 문법을 가지고 있습니다. 웹 브라우저의 HTML을 커스터마이즈 하기 위해 CSS를 사용한 것과 같은 방법으로 위젯의 모양을 커스터마이즈 할 수 있습니다. <b>QWidget</b> 과 그 서브 클래스들의 스타일 시트는 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">styleSheet</pre></div></div> 프로퍼티를 통해 사용가능합니다. 또한 런타임에도 변경이 가능합니다. 이러한 프로퍼티들은 <i>Qt Designer</i> 에서도 사용가능하기 때문에, 그래픽 디자이너들은 직관적으로 어플리케이션의 룩앤필을 개발 가능합니다. 기본 위젯의 커스터마이징 작업은 대개, 스타일 시트를 이용해도 충분한 경우가 많기 때문에, 네이티브 코드 작성의 필요성이 현저하게 줄어듭니다.
<p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-coffee.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-coffee.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-coffee.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-pagefold.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-pagefold.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-pagefold.png</a>
</p><p><i>Style Sheet 예제를 통해 스타일 시트의 효과를 즉각적으로 시험해 볼 수 있습니다.</i>
</p>
<h2><span class="mw-headline" id=".EC.BB.A4.EC.8A.A4.ED.85.80_.EC.8A.A4.ED.83.80.EC.9D.BC">커스텀 스타일</span></h2>
<p>차별화된 어플리케이션 룩앤필이 필요할 때 커스텀 스타일을 이용합니다. 커스텀 스타일은 <b>QStyle</b> 을 직간접적으로 상속함으로써 정의됩니다. 기본 클래스의 버추얼 메소드를 재구현함으로써 간단히 스타일의 변경이 가능합니다.
</p><p>스타일 API는 위젯을 렌더링하는 구성요소들에 관한 정보들을 제공하며, 이들을 통해 보다 고난이도의 스타일이 성능 저하 없이 생성됩니다.
</p>
스타일은 플러그인 형식으로도 컴파일 할 수도 있습니다. 플러그인 형태로 된 스타일은 어플리케이션을 빌드하지 않고도 <i>Qt Designer</i> 를 이용 중에도 프리뷰가 가능합니다. Qt 스타일 예제와 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">qtconfig</pre></div></div> 같은 프로그램에서는 각각의 설정가능한 스타일의 프리뷰를 통해 설정이 바로 변경되는 모습을 확인할 수 있습니다.
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_10">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/widgets-styles.html">http://qt.nokia.com/doc/latest/widgets-styles.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/stylesheet.html">http://qt.nokia.com/doc/latest/stylesheet.html</a>
</p>
<h1><span class="mw-headline" id=".EC.9E.85.EC.B6.9C.EB.A0.A5.EA.B3.BC_.EB.84.A4.ED.8A.B8.EC.9B.8C.ED.82.B9">입출력과 네트워킹</span></h1>
<p><i>Qt는 형식없는 텍스트, XML, 바이너리 포맷의 로드와 세이브가 가능합니다. Qt가 제공하는 클래스를 이용하여 로컬영역의 파일을 다룰 수 있으며, FTP나 HTTP 프로토콜을 이용하여 리모트 파일을 다룰 수도 있습니다. 프로세스간 통신과 소켓 기반의 TCP와 UDP 네트워킹 기능을 완벽히 지원하며, 네트워크 인터페이스와 관련된 정보를 간단히 얻을 수 있습니다.</i>
</p>
<h2><span class="mw-headline" id=".ED.8C.8C.EC.9D.BC_.EB.8B.A4.EB.A3.A8.EA.B8.B0">파일 다루기</span></h2>
<p>Qt의 디바이스를 다루기 위한 기능들의 핵심은 <b>QIODevice</b> 입니다. 이 클래스는 파일, 소켓 혹은 다른 디바이스의 기반이 되는 클래스입니다. 물론 커스텀 디바이스를 지원할 수 있도록 클래스를 상속하여 사용할 수 있습니다. 모든 디바이스는 시그널과 슬롯을 이용하여 커뮤니케이션합니다. 이로 인해, 파일과 네트워크 관련 처리가 어플리케이션에 밀접하게 통합될 수 있도록 하여 줍니다.
</p><p><b>QFile</b> 클래스는 대용량 파일, 긴 파일이름, 다언어 파일 이름을 지원합니다. 디렉토리의 탐색, 생성, 삭제, 이름 변경 등의 기능을 사용하려면 <b>QDir</b> 와 <b>QDirIterator</b> 클래스를 이용합니다. 파일의 크기, 권한, 최종 수정 시간 등의 세부 정보는 <b>QFileInfo</b> 클래스를 통해 제공됩니다.
</p>
Qt는 표준 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">iostream</pre></div></div> 가 어느 디바이스에서도 작동되는 것 과 마찬가지로 비슷한 기능을 하는 클래스를 가지고 있습니다. 이들 클래스들은 텍스트나 데이터 스트림을 디바이스 상에서 스트리밍 시키기 위해 사용하며, 이들은 <b>QTextCodec</b> 클래스를 통해 엔코딩 기능을 지원합니다. 데이터 스트림은 바이너리 포맷 속의 기본 C++ 타입이나 다양한 Qt 타입들을 시리얼라이즈 하기 위해 사용됩니다. 바이너리 포맷은 플랫폼 독립적인 특성을 가집니다.
<p>통합된 네트워크 억세스 API를 이용하면, 원격 파일에도 간단히 억세스 가능합니다. 물론 Qt의 네트워크 클래스로 구축된 HTTP와 FTP 프로토콜을 위한 특화된 클래스도 제공합니다. <b>QUrl</b> 를 이용하면 URL 정보를 간단히 파싱할 수 있습니다.
</p><p>어떤 파일의 경우 <b>QFile</b> 을 사용하지 않고도 직접 읽을 수 있습니다. 예를 들어 이미지 파일은 <b>QImage</b> 클래스에 플러그인 확장기능을 추가함으로써 직접 읽을 수 있습니다. 텍스트와 이미지를 프린팅하기 위해서는 <b>QPrinter</b> 를 이용합니다.
</p><p>Qt는 다른 어플리케이션이나 서비스가 디렉토리나 파일을 변경했을 때 바로 감지할 수 있도록 하는 기능을 제공합니다. <b>QFileSystemWatcher</b> 에 변경 여부를 감시할 파일 패스를 등록하면, 변경시에 즉각적으로 시그널을 발생시킵니다.
</p>
<h2><span class="mw-headline" id="XML">XML</span></h2>
<p>Qt의 XML 모듈은 SAX와 DOM 파서를 제공합니다. 이들 파서는 well-formed 하고 non-validating한 XML을 읽을 수 있습니다. SAX (Simple API for XML)는 SAX2 Java의 구현시 쓰였던 설계과 네이밍 컨벤션을 따르고 있으며, DOM (Document Object Model) Level 2 는 W3C의 recommendation 규약을 따르고 있으며, 또한 네임스페이스를 지원합니다.
</p><p>Qt의 스트림 입출력 클래스는 XML 파일의 입출력에 새로운 방법을 제시하였습니다. XML의 토큰은 인풋스트림으로부터 "pulled" 되며, 아웃풋 스트림으로 "pushed" 되도록 하고 있습니다. 이러한 방식의 클래스 설계를 통해 XML 기반의 파일 포맷을 위한 경량의 고수준 파서를 개발하기가 매우 쉬워졌습니다.
</p><p>추가 모듈을 이용하면, XQuery 1.0와 XPath 2.0를 포함한 보다 높은 수준의 XML 조작 기능을 사용가능합니다. 기본 XML 처리 모듈과 분리하여 제공하는 이유는, 개발자들의 어플리케이션 개발시 어느 레벨로 XML 기능을 지원할지를 선택할 수 있도록 하기 위함입니다. 또한 기본적인 XML 기술에 익숙한 개발자들을 위해, XSLT 2.0 을 부분적으로 지원합니다.
</p><p>XML 문서의 Vaildation은 XML 스키마와 스키마 밸리데이터를 다루는 클래스를 통해 구현됩니다. W3C의 XML Schema 표준 1.0 버전을 따릅니다.
</p>
<h2><span class="mw-headline" id=".ED.94.84.EB.A1.9C.EC.84.B8.EC.8A.A4.EA.B0.84_.ED.86.B5.EC.8B.A0">프로세스간 통신</span></h2>
<p>Qt는 외부 프로그램을 기동시키고 이들과 플랫폼 독립적 방법으로 통신할 수 있는 기능을 가진 프로세스 클래스를 제공합니다. 프로세스간 통신은 외부 프로그램의 표준 입력 스트림으로 데이터를 출력시키거나 외부 프로그램의 표준 출력/에러 스트림으로부터 데이터를 입력받음으로써 이루어집니다. <b>QProcess</b> 클래스는 <b>QIODevice</b> 클래스를 상속받았기 때문에 텍스트나 데이터 스트림의 입출력 기능을 가지고 있습니다.
</p><p><b>QProcess</b> 는 비동기 방식으로 동작하며, 데이터 사용가능한 상태가 되면, 시그널을 발생시킵니다. 이 시그널을 Qt 어플리케이션에 연결시킴으로써, 데이터를 획득하는 타이밍을 얻어내며, 또한 다시 외부 프로그램에 회신 데이터를 보낼 수 있게 됩니다. Qt의 프로세스 관련 기능은 또한 블로킹 모드를 지원하며, 외부 프로그램으로부터의 입출력을 파일로 리다이렉션할 수도 있습니다.
</p><p>Unix같이 OS에서 D-Bus 프로토콜을 지원할 경우, 이를 이용한 보다 높은 수준의 어플리케이션, 컴포넌트, OS간 통신 기능을 제공합니다. QtDBus 모듈을 이용하면 어플리케이션이 XML 기반의 인터페이스 파일을 통해 서비스로써 시스템에 노출될 수 있습니다. 이들 인터페이스 파일은 Qt가 제공하는 툴을 이용하여 C++ 소스 코드에서 자동적으로 추출됩니다.
</p><p>공유메모리나 시스템 세마포어같은 저수준의 공유 리소스에 접근하는 기능도 전용 클래스를 통해 제공됩니다. 이들은 다른 메커니즘을 이용하여 프로세스간 통신을 위한 기본 기능을 제공합니다.
</p>
<h2><span class="mw-headline" id=".EB.84.A4.ED.8A.B8.EC.9B.8C.ED.82.B9">네트워킹</span></h2>
<p>Qt는 IPv4과 IPv6를 지원하는 TCP/IP 클라이언트와 서버를 구축하기 위해 필요한 크로스 플랫폼 인터페이스를 제공합니다. 모든 네트워킹 클래스들은 재진입이 가능하며, 모든 쓰레드에서 사용 가능합니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/ftp-example.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/ftp-example.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/ftp-example.png</a>
</p><p><i>Qt FTP 예제 프로그램은 Qt의 네트워킹 기능을 사용하여 간단한 FTP 브라우징 기능을 구현하였습니다.</i>
</p><p><b>QTcpSocket</b> 클래스는 비동기의 버퍼를 가진 TCP 접속 기능을 제공합니다. 다른 <b>QIODevice</b> 의 서브클래스와 마찬가지로, 텍스트와 데이터 스트리밍이 가능하며,, 이것은 소켓 레벨의 통신을 통해 이루어집니다. 마찬가지로 <b>QUdpSocket</b> 는 UDP 소켓 방식을 다룹니다. 두 방식 다 블로킹, 넌블로킹 모드를 지원합니다. Qt의 모든 네트워킹 클래스들은 재진입이 가능하며 모든 스레드에서 사용 가능합니다.
</p><p><b>QTcpServer</b> 를 상속하면 커스텀 TCP 서버를 구현 가능합니다. 이 클래스는 접속 처리와 클라이언트에 서비스하기 위한 비동기 프레임워크 기능을 제공합니다. 서버는 블로킹과 넌블로킹 모드를 둘 다 사용가능합니다.
</p><p><b>QNetworkProxy</b> 클래스를 이용하면 프록시 서버를 지원 가능합니다. 어플리케이션 범위나 소켓 단위의 프록싱 기능을 둘 다 제공합니다. HTTP, FTP, SOCKS 5 프록시 타입이 지원되며 캐싱 기능을 적용함으로써 성능 향상을 기대할 수 있습니다. 커스터마이즈 기능을 통해, 소켓타입, 프로토콜, 여타 다른 기준이 적용된, 어플리케이션 범위의 프록시 서버를 설정 가능합니다.
</p><p><b>QAbstractSocket</b> 네이티브 소켓 API를 플랫폼 독립 레벨에서 래핑한 클래스입니다. 이 클래스는 TCP, UDP, 로컬 도메인 소켓의 기반이 되는 기능을 제공합니다. <b>QNetworkProxy</b> 클래스를 이용하면 프록시 서버를 사용 가능합니다. 이 클래스는 어플리케이션 범위 혹은 소켓 단위의 설정이 가능합니다.
</p><p>네트워키 기능의 관리는 <b>QNetworkAccessManager</b> 를 통해 이루어집니다. 이 클래스는 HTTP나 FTP같은 범용 프로토콜의 리퀘스트를 받아서 회신하는 기능을 구현하기 위해 사용됩니다. 특수한 리퀘스트를 처리하기 위해 커스터마이징이 필요하면서, 범용적인 통신 방법으로 리퀘스트와 리플라이를 보다 쉽게 구현하기 위한 특화된 클래스를 제공합니다.
</p><p>시스템의 네트워크 인터페이스에 관한 정보를 제공하기 위해서는 <b>QNetworkInterface</b> 를 이용합니다. 이 클래스는 각 인터페이스의 세부 정보, 용량, IP 어드레스, 여타 관련된 정보들을 노출시킵니다. 예를 들어, 이더넷 인터페이스의 경우, 하드웨어로부터 얻을 수 있는 MAC 어드레스를 얻을 수 있으며, IP 어드레스와 함께 브로드캐스트 어드레스와 넷마스트 어드레스를 얻을 수 있습니다.
</p>
<h3><span class="mw-headline" id=".EC.95.94.ED.98.B8.ED.99.94.EB.90.9C_.ED.86.B5.EC.8B.A0">암호화된 통신</span></h3>
<p>Qt는 네트워크 통신 보안 기능을 가지고 있습니다. 이는 SSLv3나 TLSv1와 같은 Secure Socket Layer (SSL) 프로토콜에 기반한 암호화된 TCP 접속을 통해 가능합니다.
</p><p><b>QSslSocket</b> 는 SSL로 암호화된 소켓을 제공합니다. 클라이언트와 서버 양쪽에서 사용가능합니다. 사이퍼(ciphers), 키, 인증서 같은 암호화와 인증에 관련된 요소들도 클래스로 추상화하여 제공합니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_11">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qiodevice.html">http://qt.nokia.com/doc/latest/qiodevice.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtxml.html">http://qt.nokia.com/doc/latest/qtxml.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtnetwork.html">http://qt.nokia.com/doc/latest/qtnetwork.html</a>
</p>
<h1><span class="mw-headline" id=".EC.BB.AC.EB.A0.89.EC.85.98_.ED.81.B4.EB.9E.98.EC.8A.A4">컬렉션 클래스</span></h1>
<p><i>컬렉션 클래스는 메모리상에서 여러 개의 아이템을 저장하기 위해 사용됩니다. Qt는 Standard Template Library (STL)과 호환되면서, 컴파일러가 STL의 지원여부에 관계없이 작동할 수 있는 일련의 클래스들을 제공합니다. 보다 안전하고 편하게 컬렉션 클래스를 사용할 수 있도록 자바 스타일의 반복자(Iterator)를 제공합니다.</i>
</p><p>때로 어플리케이션은 여러 개의 이미지나 위젯, 혹은 커스텀 오브젝트같은 아이템을 메모리상에서 관리해 주어야 합니다. 많은 C++ 컴파일러들은 아이템 저장에 필요한 데이터 구조를 범용성 있게 제공해 주는 STL을 지원합니다. Qt는 리스트, 스택, 큐, STL 문법을 지원하는 딕셔너리를 제공합니다. Qt의 컬렉션 클래스들은 컴파일러가 STL을 지원하지 않더라도 문제없이 작동됩니다.
</p><p>Qt의 풍부한 컬렉션 클래스 (컨테이너)와 반복자들은 Qt 내부와 Qt API 일부에서 매우 요긴하게 쓰이고 있습니다. Qt의 컨테이너들은 속도와 메모리 효율성을 고려하여 최적화 되어 있습니다. 프로그래머들은 STL을 지원하는 플랫폼에서 STL를 사용할 수도 있습니다. 하지만 이 경우 최적화 기법은 직접 구현해야 합니다.
</p><p>다른 많은 템플릿 클래스의 경우 실행 코드의 메모리 사이즈가 급격히 증가하는 현상이 있습니다만, 이와는 달리 Qt의 템플릿 컬렉션 클래스들은 늘어나는 코드 사이즈를 최소화 하게끔 최적화되어 있습니다.
</p>
<h2><span class="mw-headline" id=".EC.BB.A8.ED.85.8C.EC.9D.B4.EB.84.88">컨테이너</span></h2>
<p>Qt는 리스트, 링크드 리스트, 벡터, 스택, 큐와 같은 일차원 컨테이너 클래스를 제공하며 이들의 인터페이스는 STL 컨테이너와 매유 유사할 뿐만 아니라 STL의 알고리즘 라이브러리와도 완벽하게 호환됩니다. 또한 Qt 자체적으로도 복사, 검색, 정렬를 위해 STL과 동등한 알고리즘들을 제공합니다. STL을 지원하는 플랫폼에서는, 자동적으로 STL과 Qt컨테이너간의 연산자 변환이 이루어집니다.
</p><p>또한, STL보다 자바 컨테이너에 익숙한 개발자들을 위해, Qt는 자바 스타일의 반복자를 제공합니다.
</p><p>Qt 는 맵, 해시, 셋 같은 관계형 컨테이너 클래스들을 제공합니다. "hash" 컨터이너는 검색 성능을 높이기 위해 해시 함수를 사용합니다. 일대일, 일대다 변종의 맵과 해시 컨테이너를 사용 가능합니다.
</p><p>Qt의 일차원, 관계형 컬렉션 클래스들은 값 기반 타입과 포인터 기반 타입 둘 다 사용가능합니다. 그렇기 때문에 <b>QWidget</b> 나 <b>QObject</b> 의 포인터를 컬렉션 클래스에 저장하여 사용 할 수 있습니다. 포인터 기반으로 사용할 경우, 컬렉션 오브젝트가 소멸될 때 내용물이 한 번에 삭제될 수 있도록 하는 함수도 제공합니다.
</p>
<h2><span class="mw-headline" id=".EC.95.94.EC.8B.9C.EC.A0.81_.EA.B3.B5.EC.9C.A0.28Implicit_Sharing.29">암시적 공유(Implicit Sharing)</span></h2>
<p>Qt의 값 클래스를 컬렉션 클래스에 저장할 경우에는 암시적 공유("내용이 바뀔 때 복사 됨")이 일어납니다. 이들 클래스가 복사된다 하더라도 일단은 메모리 내부에서 같은 데이터 영역을 공유합니다. 이러한 데이터 공유 처리는 자동적으로 이루어지며 만약 어플리케이션에서 이들 중 한 오브젝트의 데이터를 변경하려하면 그제서야 딥 카피 (데이터의 완전 복제)가 이루어져서 다른 개체는 값이 변경되지 않도록 합니다. 만약 한 개체가 복사될 경우 오직 포인터가 복사되면서 참조 카운트 값을 증가시킵니다. 이러한 방법은 실제 데이터를 복사하는 것보다 훨씬 빠를 뿐만 아니라 메모리를 절약시킵니다.
</p><p>이러한 공유 메커니즘은 값 기반으로 된 Qt 컬렉션 클래스나 여타 알고 있는 많은 클래스에서 빈번히 사용되고 있습니다. 프로그래머가 직접 포인터 기반으로 처리하는 코드를 최적화할 때 드는 수많은 리스크를 피할 수 있기에, 매우 안전하고 효율적으로 이들 클래스 개체의 복사를 수행할 수 있습니다. 특히, 암시적 공유 메커니즘으로 움직이는 <b>QString</b> 와 <b>QRegExp</b> 클래스는 스트링 처리를 매우 쉽고 빠르게 수행합니다.
</p><p>또한 Qt는 저수준의 비트, 바이트 배열과 같은 기본적인 데이터 타입을 보다 효율적으로 처리하기 위한 배열 클래스를 제공합니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_12">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/containers.html">http://qt.nokia.com/doc/latest/containers.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/implicit-sharing.html">http://qt.nokia.com/doc/latest/implicit-sharing.html</a>
</p>
<h1><span class="mw-headline" id=".ED.94.8C.EB.9F.AC.EA.B7.B8.EC.9D.B8.EA.B3.BC_.EB.A9.94.ED.83.80_.EC.98.A4.EB.B8.8C.EC.A0.9D.ED.8A.B8_.EC.8B.9C.EC.8A.A4.ED.85.9C">플러그인과 메타 오브젝트 시스템</span></h1>
<p><i>플랫폼 독립적인 API를 이용하여, Qt 어플리케이션은 다이내믹 라이브러리 기능을 사용 가능합니다. Qt는 또한 플리그인 기능을 지원하며 이를 통해 개발자들은 코덱, 데이터베이스 드라이버, 이미지 포맷 변환, 스타일, 커스텀 위젯을 독립적 컴포넌트로 분리하여 개발하고 배포할 수 있습니다.</i>
</p>
<h2><span class="mw-headline" id=".ED.94.8C.EB.9F.AC.EA.B7.B8.EC.9D.B8.EA.B3.BC_.EB.9D.BC.EC.9D.B4.EB.B8.8C.EB.9F.AC.EB.A6.AC">플러그인과 라이브러리</span></h2>
<p>Qt 컴포넌트를 플러그인으로 변환하기 위해서는 적절한 플러그인 기반 클래스를 서브클래싱한 다음, 몇 가지 메서드를 구현하고 매크로를 추가하면 됩니다. 이러한 방법으로 플러그인을 작성하면, 프로퍼티를 외부로 노출시키고, 시그널 슬롯 매커니즘을 통해 어플리케이션과 소통하는 것이 가능합니다.
</p><p>플러그인으로 된 컴포넌트는 어플리케이션이 자동으로 감지하여 사용합니다. 많은 서드파티들은 Qt 컴포넌트를 소스 형태나 프리컴파일된 다이내믹 라이브러리 형태로, 혹은 플러그인 형태로 제공하고 있습니다.
</p><p><b>QLibrary</b> 클래스는 다이나믹 라이브러리를 로딩하기 위한 API를 플랫폼 독립적인 형태로 제공합니다. C 언어 심벌로 익스포트된 함수 호출에 있어 타입 세이프한 방법을 제공합니다.
</p>
<h2><span class="mw-headline" id=".EB.A9.94.ED.83.80_.EC.98.A4.EB.B8.8C.EC.A0.9D.ED.8A.B8_.EC.8B.9C.EC.8A.A4.ED.85.9C">메타 오브젝트 시스템</span></h2>
<p>메타 오브젝트 시스템은 Qt 컴포넌트가 보다 강력한 런타임 타입 정보(RTTI) 기능이나 여타 다이내믹 기능을 제공할 수 있도록, 컴파일 타임에 관련 정보를 컴포넌트에 추가시키는 방식을 말합니다. 이러한 방식을 통해 Qt는 런타임 개체 투시(introspection), 국제화를 위한 번역 메커니즘, 시그널-슬롯, 보다 범용적인 방식의 함수와 메서드를 호출을 지원 가능합니다.
</p><p>다양한 타입의 오브젝트 시스템을 사용함으로써, 어플리케이션이 Qt 스크립트를 곧바로 사용할 있을 뿐만 아니라, 다른 프로그래밍 언어가 메타 오브젝트 시스템으로 포팅된다면, 간단히 해당 언어로 된 스크립트 기능을 지원할 수 있습니다.
</p><p>다시 한 번 말씀드립니다만, 이러한 기능들은 플러그인을 통해 어플리케이션에 노출시킬 수 있으며, 반대로 어플리케이션의 기능들이 플러그인에 노출될 수도 있습니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_13">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/plugins-howto.html">http://qt.nokia.com/doc/latest/plugins-howto.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/metaobjects.html">http://qt.nokia.com/doc/latest/metaobjects.html</a>
</p>
<h1><span class="mw-headline" id="Qt_.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EC.9D.98_.EB.B9.8C.EB.93.9C">Qt 어플리케이션의 빌드</span></h1>
<p><i>여러 플랫폼상에서 어플리케이션을 빌드하기 위한 프로세스를 단순하 시켜주는 툴들을 Qt 개발자들은 사용할 수 있습니다. 프로젝트 종류가 어플리케이션인지 라이브러리인지 플러그인인지를 프로젝트 파일에 기술하면 이 프로젝트 파일을 기반으로 각각의 플랫폼에 맞는 Makefiles가 생성됩니다.</i>
</p><p>간단한 커맨드 라인형 툴부터 유명한 IDE에 이르기까지, Qt는 여타의 다양한 개발 환경과 연동될 수 있도록 설계되었습니다. 뿐만 아니라, Qt 어플리케이션 개발에 특화된 크로스 플랫폼 IDE인 Qt 크리에이터를 제공합니다.
</p>
<h2><span class="mw-headline" id="Qt.EC.9D.98_.EB.B9.8C.EB.93.9C_.EC.8B.9C.EC.8A.A4.ED.85.9C">Qt의 빌드 시스템</span></h2>
프로젝트 관련 정보는 프로젝트 파일에 기술되며, 간결한 텍스트 형식으로 소스나 헤더 파일, <i>Qt Designer</i> 폼, 리소스 등을 기술합니다. 프로젝트 파일은 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">qmake</pre></div></div> 툴을 통해 타겟 플랫폼에 맞는 Makefiles를 생성합니다.
<p>모든 Qt 라이브러리, 툴, 예제들은 프로젝트 파일을 가지고 있습니다. 심지어 매우 간단한 예제라 하더라도 몇 줄이나마 선언 관련 내용이 기재되어 있습니다.
</p><p>또한 조건부 빌드를 지원함으로써, 특정 플랫폼에서만 동작하는 코드를 프로젝트 안에 삽입시켜, 해당 플랫폼을 빌드할 때에만 적용이 되도록 할 수 있습니다.
</p>
프로젝트 빌드를 위해 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">qmake</pre></div></div> 를 실행시키면, 다른 툴들도 자동적으로 실행시킵니다. <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">moc</pre></div></div> 는 헤더 파일에 시그널-슬롯 관련 정보를 삽입하며, <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">rcc</pre></div></div> 컴파일러는 특정 리소스를 컴파일 시키며, 또한 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">uic</pre></div></div> 는 <i>Qt Designer</i> 에서 작성된 UI 폼을 코드로 생성시켜 줍니다.
프리컴파일 헤더 지원과 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">pkg<span class="sy0">-</span>config</pre></div></div> 통합기능을 통해 Visual Studio 프로젝트 파일을 생성할 수 있으며, 또한 다른 강력한 기능들을 사용하면 개발자들은 크로스 플랫폼 빌드 시스템 상에서도 특정 플랫폼에서만 작동하는 툴들을 사용 가능합니다.
<h2><span class="mw-headline" id="Qt.EC.9D.98_.EB.A6.AC.EC.86.8C.EC.8A.A4_.EC.8B.9C.EC.8A.A4.ED.85.9C">Qt의 리소스 시스템</span></h2>
<p>Qt는 데이터 파일이 실행파일 안에 저장되도록 하는 리소스 시스템을 제공합니다. 이를 통해 어플리케이션이 필요로 하는 어떤 리소스도 런타임에 사용이 가능합니다. Qt 위젯은 특정 네이밍 룰을 지원함으로써, 이 룰에 따라 개발자들은 리소스에 직접적으로 접근하는 것이 가능합니다.
</p>
Qt Resource Collection 파일에는 어플리케이션에 저장되는 리소스 리스트가 담겨져 있습니다. 이 파일은 빌드 디렉토리 안에 있는 리소스의 파일 경로 리스트를 담고 있습니다. 이들 리소스 파일은 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">rcc</pre></div></div> 를 통해 컴파일 되어 어플리케이션 코드 안에 삽입됩니다. 이러한 방식은 프로그램의 배포나 설치시에 발생하는 리소스 결함 문제를 해소시킴으로써, 어플리케이션이 리소스에 문제 없이 억세스 할 수 있도록 보증해 줍니다.
<p><b>QResource</b> 를 이용하면 이러한 리소스 시스템을 런타임으로 확장할 수도 있습니다. 이를 통해 새로운 리소스 경로가 노출되며, 필요할 때 리소스가 로드 됩니다.(역자 주: augmenting those built into the application 번역 불가)
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qt-creator-overview.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qt-creator-overview.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/qt-creator-overview.png</a>
</p><p><i>Qt 크리에이터의 대략적 모습</i>
</p>
<h2><span class="mw-headline" id="Qt_.EC.96.B4.ED.94.8C.EB.A6.AC.EC.BC.80.EC.9D.B4.EC.85.98.EC.9D.98_.ED.85.8C.EC.8A.A4.ED.8C.85.EA.B3.BC_.EB.B2.A4.EC.B9.98.EB.A7.88.ED.81.AC">Qt 어플리케이션의 테스팅과 벤치마크</span></h2>
<p>유닛 테스팅 툴을 Qt의 표준 모듈로써 지원합니다. 유닛 테스트는 C+<i>로 작성되며, <b>QObject</b> 기반의 클래스에 테스팅 함수를 넣는 방식입니다. 다른 테스팅 프레임워크와는 달리, 이렇게 작성한 코드는 완벽한 실행 파일로 컴파일됩니다. Qt의 유닛 테스팅 라이브러리는 또한 GUI에서도 테스트할 수 있도록 하는 확장 기능을 제공합니다.</i>
</p><p>유닛 테스트는 또한 간단한 매크로를 이용하여 벤치마크 작업을 수행할 수 있도록 설정할 수 있습니다. 테스트 케이스의 성능을 측정하여 레포트 결과가 다른 백엔드에서 처리되도록 할 수 있으며, 이를 통해 일반적인 시각화 툴을 사용해 성능 측정 결과를 시각화 시킬 수 있도록 도와 줍니다.
</p>
<h2><span class="mw-headline" id="Qt_.ED.81.AC.EB.A6.AC.EC.97.90.EC.9D.B4.ED.84.B0">Qt 크리에이터</span></h2>
<p>Qt 크리에이터는 Qt 개발 프레임워크를 이용하여, C<i>+ 과 Qt 소프트웨어를 개발하기위한 경량의 IDE입니다. 사용법이 매우 간단하면서도, 여타의 IDE가 가지고 있는 모든 기능들이 다 담겨져 있습니다. 문법 강조, 코드 예측 변환, 클래스, 함수 기타 C++ 계층 구조의 빠른 탐색 이동, 통합된 디버깅 툴 등을 지원합니다.</i>
</p><p>Qt 개발에 특화된 독자적인 기능이 들어 있습니다. 시그널-슬롯 예측 변환이나 Qt 디자이너 툴의 통합, Qt 도큐먼트 내장 등을 담고 있습니다. <a rel="nofollow" class="external text" href="http://qt.nokia.com/files/pdf/qt-creator-1.3-whitepaper/">Qt 크리에이터 백서</a> 를 보시면 보다 자세한 내용을 확인할 수 있습니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_14">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qmake-manual.html">http://qt.nokia.com/doc/latest/qmake-manual.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/qtestlib-manual.html">http://qt.nokia.com/doc/latest/qtestlib-manual.html</a>
</p>
<h1><span class="mw-headline" id="Qt.EC.9D.98_.EC.95.84.ED.82.A4.ED.85.8D.EC.B3.90">Qt의 아키텍쳐</span></h1>
<p><i>Qt가 제공하는 기능들은 플랫폼에서 지원하는 저수준의 API상에서 구축되었습니다. 이로 인해 Qt는 유연성과 높은 생산성을 가지게 되었으며 Qt어플리케이션을 특정 플랫폼에서 최적화시키는 것도 가능하게 되었습니다.</i>
</p><p>Qt는 크로스 플랫폼이면서도 각각의 플랫폼에서 지원하는 휴먼 인터페이스 가이드라인을 정확히 준수할 수 있도록 플랫폼의 네이티브 스타일의 API를 사용합니다. 모든 위젯들은 Qt를 통해 렌더링되며 프로그래머는 이들의 가상함수를 오버라이딩함으로써 기능을 확장하거나 커스터마이징이 가능합니다. sec:Styles-and-Themes 에서 설명 드렸듯이, Qt의 위젯은 해당 플랫폼에서 지원하는 룩앤필을 아주 정확하게 에뮬레이션하였습니다. 이런 기술은 개발자들도 사용이 가능하기 때문에 어플리케이션 내에서 독자적인 룩앤필을 쉽게 구축 가능합니다.
</p><p>Qt는 각각의 플랫폼에서 제공하는 저수준의 API를 직접 이용합니다. 특정 플랫폼에서 제공하는 툴킷(Windows의 MFC나 X11의 Motif)을 단순 래핑하여 크로스 플랫폼을 구현한 기존의 "레이어드" 툴킷과는 근본적으로 다릅니다. 레이어드 툴킷에서 제공하는 기능들은 여러 계층의 API를 통해 구현된 것이기 때문에 상대적으로 Qt보다 느릴 수밖에 없습니다. 때로 레이어드 툴킷은 어플리케이션 상층부에서 발생할 수 있는 버그를 방지하기 위해, 툴킷 자체의 기능이나 기반 툴킷의 기능을 완벽히 지원하지 못하는 경우도 있습니다.
</p><p>Qt는 Microsoft Windows, X11, Mac OS X, Embedded Linux 상에서 이용이 가능하며, 프로페셔널 서포트 서비스를 받을 수 있습니다. Qt는 단일 소스 트리상에서 해당 플랫폼에 맞는 실행파일로 컴파일됩니다. 고객들 중에는 Qt가 크로스 플랫폼이라는 특징을 활용하지 않더라도, 특정 플랫폼 전용의 여타 툴킷보다 훨씬 배우기 쉬우면서 생산성이 높다고 평가하기도 합니다. 특별히 Qt의 완벽한 개체지향 특성을 선호하는 분들은 싱글 플랫폼의 개발 도구로써 Qt를 선택하기도 합니다.
</p>
<h2><span class="mw-headline" id="X11">X11</span></h2>
<p>X11용 Qt는 직접 Xlib을 이용합니다. Xt (X Toolkit), Motif, Athena 등의 툴킷에 의존하지 않습니다.
</p><p>Qt가 지원하는 Unix버전은 다음과 같습니다:AIX (R), FreeBSD®, HP-UX, Linux, NetBSD, OpenBSD, Solaris. 지원하는 시스템 버전이나 컴파일러 목록에 관한 정보는 Qt Development Frameworks의 웹사이트에서 확인하시기 바랍니다.
</p><p>Qt 어플리케이션은 자동적으로 유저의 윈도우 매니저나 데스크탑 환경에 맞춰서 실행되며, Motif, CDE, GNOME (TM), KDE (TM) 의 룩앤필을 자체 네이티브 레벨에서 지원합니다. 여타의 다른 Unix 툴킷이 고정된 자체 룩앤필만을 제공하는 것과는 큰 차이점입니다.
</p><p>Qt는 완벽하게 유니코드를 지원합니다. Qt는 유니코드와 비유니코드 폰트를 자동으로 선택하여 제공합니다. Qt는 한 텍스트에 다양한 언어가 있다 하더라도 여러 X 폰트를 혼합하여 렌더링해 줍니다. Qt의 폰트 처리 기능은 매우 지능적이어서, 만약 현재 선택된 폰트에서 렌더링 불가능한 문자가 있을 경우, 현재 인스톨된 폰트중에서 처리 가능한 폰트를 자동으로 찾아내 줍니다.
</p><p>Qt는 여러 부분에서 X extension을 이용하고 있습니다. Qt는 벡터 그래픽과 폰트에서 안티앨리어싱과 알파 블렌딩을 구현하기 위해 RENDER extension을 지원합니다. Qt는 X Input Methods를 위한 즉각 편집 기능을 제공합니다. Qt는 멀티 스크린을 지원하며 기존의 multi-head 방식과 Xinerama 방식 둘 다 지원합니다.
</p>
<h2><span class="mw-headline" id="Microsoft_Windows">Microsoft Windows</span></h2>
<p>Windows용 Qt는 저수준의 이벤트 핸들링과 드로잉을 위해 Win32® API와 GDI를 이용합니다. MFC나 다른 툴킷은 사용하지 않습니다. 그럼에도 불구하고 강력하면서도 확장성이 뛰어난 위젯을 자체적으로 제공합니다. 위젯은 매우 빠르면서도 정확한 페인팅 엔진을 통해 렌더링 됩니다. (예외적으로 Qt는 파일 다이얼로그와 프린트 다이얼로그만은 Windows 네이티브용 위젯을 사용합니다. 사용자에게 일관적인 사용성을 제공하기 위함입니다.)
</p><p>Windows를 이용하는 고객들은 Windows 98, NT4, ME, 2000, XP, Vista 상의 Microsoft Visual Studio를 이용하여 Qt 어플리케이션을 작성 가능합니다. Qt는 런타임에 윈도우의 버전을 체크하여, 버전에 맞게 최대의 성능을 발휘하게 해 줍니다. Qt 개발자들은 Windows 버전에 따른 API의 차이점을 의식할 필요가 없습니다.
</p><p>Microsoft 엑세서빌리티(accessibility) 인터페이스 역시 지원하고 있습니다. 다른 Windows의 표준 컨트롤과는 달리, Qt 위젯은 위젯의 기능을 확장할 시에도, 기반 위젯의 억세서빌리티 정보를 유지하면서도 확장이 가능합니다. 커스텀 위젯 역시 억세서빌리티를 지원 가능합니다. 또한 Qt는 Microsoft Windows 상에서 멀티 스크린을 지원합니다.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/architecture-diag.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/architecture-diag.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/architecture-diag.png</a>
</p><p><i>데스크탑 플랫폼상의 Qt 아키텍쳐</i>
</p>
<h2><span class="mw-headline" id="Mac_OS_X">Mac OS X</span></h2>
<p>Qt는 Mac OS X을 지원하며, Cocoa® 과 Carbon® API를 이용하고 있습니다. 64비트 하드웨어에서는 Mac OS X의 네이티브 위젯과 Cocoa 뷰와의 통합을 위해 Cocoa 라이브러리를 이용하고 있습니다.
</p><p>Mac OS X용 Qt는 레이아웃 기능과 직관적인 국제화 지원, OpenGL의 기본 지원, 그리고 강력한 비주얼 편집 도구인 <i>Qt Designer</i> 를 도입하였습니다. (역자 주: 이들 기능은 현재 다른 데스크탑 플랫폼에서도 지원중입니다.) Qt는 파일과 비동기 소켓의 입출력을 이벤트 루프 안에서 핸들링할 수 있습니다. Qt는 강력한 데이터베이스 기능을 지원합니다. 개발자들은 충실한 도큐먼트와 소스 코드를 포함한 최신의 개체지향 API를 사용하여 Mac OS X용 어플리케이션을 개발 가능합니다.
</p><p>Qt의 어플리케이션은 다양한 플랫폼용으로 컴파일 가능하기 때문에, 개발자들은 원하는 플랫폼에서 보다 큰 마켓 규모를 가지고 어플리케이션을 개발할 수 있게 됩니다. 또한 Mac OS X에서 통합 바이너리를 지원하기 때문에 Intel용과 PowerPC용 맥에서 둘 다 문제없이 동작합니다. 필요할 경우 개발자들은 Qt가 제공하는 특정 플랫폼용 확장 기능을 사용하여 특정 플랫폼에 최적화된 어플리케이션을 개발하는 것도 가능합니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_15">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/supported-platforms.html">http://qt.nokia.com/doc/latest/supported-platforms.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/installation.html">http://qt.nokia.com/doc/latest/installation.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/deployment.html">http://qt.nokia.com/doc/latest/deployment.html</a>
</p>
<h1><span class="mw-headline" id=".ED.8A.B9.EC.A0.95_.ED.94.8C.EB.9E.AB.ED.8F.BC.EC.9A.A9_.ED.99.95.EC.9E.A5_.EA.B8.B0.EB.8A.A5.EA.B3.BC_Qt_.EC.86.94.EB.A3.A8.EC.85.98">특정 플랫폼용 확장 기능과 Qt 솔루션</span></h1>
<p><i>Qt는 그 자체만으로 완벽한 구성을 하고 있으나, 싱글 플랫폼 개발자를 위해 특정 플랫폼 확장 기능을 제공합니다. ActiveQt 확장 기능을 이용하면, 개발자들은 Qt 어플레케이션에서 ActiveX 컨트롤을 사용가능하며, 또한 Qt 어플리케이션을 ActiveX 서버로 동작하게 할 수도 있습니다. 그 외에도, Qt 솔루션을 통해 특정 플랫폼용 확장 기능을 사용 가능합니다.</i>
</p>
<h2><span class="mw-headline" id="ActiveX_.ED.98.B8.ED.99.98">ActiveX 호환</span></h2>
<p>ActiveX는 Microsoft's COM 기술을 통해 구현된었습니다. ActiveX를 이용하면,컴퍼넌트 서버가 제공하는 컴퍼넌트를 어플리케이션과 라이브러리에서 사용가능하며 또한 그 자체가 컴퍼넌트 서버로 동작합니다. Windows용 Qt는 ActiveQt 모듈을 제공함으로써, 개발자들이 어플리케이션을 ActiveX 서버로 동작시키고, 다른 어플리케이션이 제공하는 ActiveX 컨트롤을 사용할 수 있게 해 줍니다.
</p><p>Microsoft의 .NET (TM) 기술과의 통합도 ActiveQt를 통해 가능합니다. 어플리케이션에서 ActiveQt의 COM 지원 기능을 사용함으로써, .NET 개발자들은 자동적으로 Qt 위젯과 데이터 타입에 접근 가능합니다.
</p><p>ActiveQt는 ActiveX와 Qt를 완벽하게 결합시킵니다. ActiveX의 프로퍼티, 메서드, 이벤트는 Qt 프로퍼티, 슬롯, 시그널로 취급되며, 이로 인해 Qt 개발자들은 Qt와 비슷한 패러다임으로 ActiveX 연계가 가능합니다. 이러한 작업은 ActiveX 쪽 구현부분을 코드 제네레이션 해 줌으로써 개발자들이 의식할 필요가 없습니다.
</p>
ActiveQt는 자동적으로 ActiveX와 Qt 사이의 데이터 타입의 변환을 수행합니다. ActiveQt는, 컨트롤의 <b>IDispatch</b> 인터페이스를 통해 ActiveX 컴퍼넌트를 컨트를 할 수 있도록, <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">dynamicCall<span class="br0">&#40;</span><span class="br0">&#41;</span></pre></div></div> 함수를 지원합니다.
<p>Qt 어플리케이션을 ActiveX 서버로 전환시키는 것도 매우 쉽습니다. 만약 클래스 하나를 익스포터할 경우, 헤더 파일을 인클루드 하고 부가적인 작업을 수행함으로써, 익스포트를 가능하게 합니다. 일단 클래스가 컴파일 되면, 클래스의 프로퍼티 슬롯, 시그널은 ActvieX 클라이언트의 프로퍼티, 메서드, 이벤트로 변환됩니다. 또한 ActiveQt는 현재의 어플리케이션이 독립적으로 실행되는지 아니면, ActiveX 컨트롤로서 실행되는지 판별할 수 있도록 하는 기능을 제공함으로써, 개발자가 어플리케이션의 실행 조건에 맞게 대응할 수 있도록 해 줍니다.
</p>
<h2><span class="mw-headline" id="Qt_.EC.86.94.EB.A3.A8.EC.85.98">Qt 솔루션</span></h2>
<p>Qt 프레임워크에서 제공되는 클래스와 별개로, Qt 라이센시가 이용가능한 옵션 서비스를 개발하고 있습니다. 이들 서비스는 제품 구매 시점에서, 혹은 애드온으로써 사용 가능합니다. Qt 솔루션은 수많은 컴포넌트와 위젯의 주기적인 업데이트를 제공하며, Qt와 똑같은 듀얼 라이센싱이 적용됩니다. 대부분의 솔루션들은 Qt 3 개발자들이 Qt 4을 사용할 수 있도록 하기 위해 개발되었으며 Qt 4에서 추가된 신기능들도 다수 릴리즈 되었습니다.
</p>
<h3><span class="mw-headline" id=".EC.98.A8.EB.9D.BC.EC.9D.B8_.EB.A6.AC.ED.8D.BC.EB.9F.B0.EC.8A.A4_16">온라인 리퍼런스</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/activeqt.html">http://qt.nokia.com/doc/latest/activeqt.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/latest/intro-to-dbus.html">http://qt.nokia.com/doc/latest/intro-to-dbus.html</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/products/appdev/add-on-products/qt-solutions">http://qt.nokia.com/products/appdev/add-on-products/qt-solutions</a>
</p>
<h1><span class="mw-headline" id="The_Qt_Development_Community">The Qt Development Community</span></h1>
<p><i>Companies and independent developers from around the world are joining the Qt development community every day. They have recognized that Qt's architecture lends itself to rapid application development. These developers, whether they are targeting one or many platforms, benefit from Qt's consistent and straightforward API, powerful build system, and supporting tools such as Qt Designer.</i>
</p>
Qt has an active and helpful user community who communicate using the <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">qt<span class="sy0">-</span>interest</pre></div></div> mailing list, the <i>Qt Centre</i> Web site at <a rel="nofollow" class="external text" href="http://www.qtcentre.org/">www.qtcentre.org</a>, and a number of other community Web sites and Weblogs. In addition, many Qt developers are active members of the <a rel="nofollow" class="external text" href="http://www.kde.org/">KDE</a> community. We publish <a rel="nofollow" class="external text" href="http://qt.nokia.com/doc/qq/">Qt Quarterly</a>, an online developers' newsletter, for commercial customers and open source developers. A growing number of commercial and open source add-ons from third parties are also available; see the <a rel="nofollow" class="external text" href="http://qt.nokia.com/">Qt Development Frameworks</a> site for the most up-to-date information.
<p>Qt's extensive documentation is available online at <a rel="nofollow" class="external text" href="http://qt.nokia.com/doc">qt.nokia.com/doc</a>. There are also a number of books in English, French, German, Russian, Chinese and Japanese, that present and explain Qt programming. Qt's official book is <b>C++ GUI Programming with Qt 4</b> (<a href="http://wiki.qt.io/Special:BookSources/0132354160" class="internal mw-magiclink-isbn">ISBN 0-13-235416-0</a>).
</p><p>Qt Development Frameworks and its partners provide a range of training options for Qt and C+<i>, including open enrollment courses for the general public and on-site courses for customers who have more specific training needs. See the online <a rel="nofollow" class="external text" href="http://qt.nokia.com/support-services/training">Qt Development Frameworks training pages</a> for more information.</i>
</p><p>As well as providing a comprehensive framework for C<i>+ developers, Qt can also be used with a variety of other programming languages. Qt itself includes the QtScript module, a JavaScript-oriented technology that enables developers to give users access to restricted parts of their applications for scripting purposes.</i>
</p><p>Qt Development Frameworks provides a set of Qt bindings to the Java programming language, formerly known as Qt Jambi, under the LGPL license.
</p><p>Language bindings for Python, Ruby, JavaScript, BASIC, Ada 2005, C#, Pascal, Lua, Perl and Scheme are also available from Qt Development Frameworks's partners and various third parties; many of these solutions are produced and maintained by teams of open source developers.
</p><p>Developers can evaluate Qt, with support, for 30 days on their preferred platform. For further information, visit <a rel="nofollow" class="external free" href="http://qt.nokia.com/products/qt">http://qt.nokia.com/products/qt</a>
</p>
<h3><span class="mw-headline" id="Online_References">Online References</span></h3>
<p><a rel="nofollow" class="external free" href="http://qt.nokia.com/support-services/training">http://qt.nokia.com/support-services/training</a>
</p><p><a rel="nofollow" class="external free" href="http://lists.trolltech.com/qt-interest/">http://lists.trolltech.com/qt-interest/</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.nokia.com/doc/qq/">http://qt.nokia.com/doc/qq/</a>
</p><p>This document is licensed under the <a rel="nofollow" class="external text" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-Share Alike 2.5</a> license.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/share.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/share.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/share.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/remix.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/remix.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/remix.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/by.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/by.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/by.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/sa.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/sa.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/sa.png</a>
</p><p>For more information, see <a rel="nofollow" class="external free" href="http://creativecommons.org/licenses/by-sa/2.5/legalcode">http://creativecommons.org/licenses/by-sa/2.5/legalcode</a> for the full terms of the license.
</p><p>^1 ISO is a registered trademark of the International Organization for Standardization.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/nokia-logo.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/nokia-logo.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/nokia-logo.png</a>
</p>
<!-- 
NewPP limit report
CPU time usage: 0.725 seconds
Real time usage: 0.749 seconds
Preprocessor visited node count: 635/1000000
Preprocessor generated node count: 1024/1000000
Post‐expand include size: 1268/2097152 bytes
Template argument size: 412/2097152 bytes
Highest expansion depth: 5/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key qtio_wiki:pcache:idhash:1884-0!*!0!!en!2!* and timestamp 20151105100559 and revision id 17403
 -->
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;oldid=17403">http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;oldid=17403</a>"				</div>
												<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://wiki.qt.io/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="http://wiki.qt.io/Category:Articles_needing_cleanup" title="Category:Articles needing cleanup">Articles needing cleanup</a></li><li><a href="http://wiki.qt.io/index.php?title=Category:Pages_with_broken_file_links&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages with broken file links (page does not exist)">Pages with broken file links</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=QtWhitepaper%2Fko" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/QtWhitepaper/ko"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:QtWhitepaper/ko&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="http://wiki.qt.io/QtWhitepaper/ko" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/QtWhitepaper/ko" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/QtWhitepaper/ko" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;oldid=17403&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;oldid=17403" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=QtWhitepaper/ko&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 26 May 2015, at 12:22.</li>
											<li id="footer-info-viewcount">This page has been accessed 1,770 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":254});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=QtWhitepaper/ko&oldid=17403 by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 13:17:50 GMT -->
</html>
