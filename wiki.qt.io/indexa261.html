<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/hu&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:58:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>View source for Getting Started Programming with QML/hu - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Getting_Started_Programming_with_QML/hu","wgTitle":"Getting Started Programming with QML/hu","wgCurRevisionId":19238,"wgRevisionId":0,"wgArticleId":822,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Getting_Started_Programming_with_QML/hu","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Getting_Started_Programming_with_QML_hu skin-vector action-edit vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for Getting Started Programming with QML/hu</span></h1>
						<div id="bodyContent">
								<div id="contentSub">← <a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/hu" title="Getting Started Programming with QML/hu">Getting Started Programming with QML/hu</a></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in one of the groups: <a href="http://wiki.qt.io/index.php?title=Qt_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Qt Wiki:Users (page does not exist)">Users</a>, KnowledgeBase, QtWS.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Cleanup | reason=Auto-imported from ExpressionEngine.}}

~Az alant olvasható leírás rev. 0.2 verziót visel, ezzel is jelezve, hogy a jövőben szeretnénk még csiszolni rajta~ :)

= Bevezetés a QML programozásba =

Üdvözöllek a QML világában, mely egy UI leíró nyelv! Ebben a bevezetőben egy egyszerű szövegszerkesztő alkalmazást fogunk létrehozni a QML segítségével. Ezen útmutató olvasása után már készen fogsz állni, hogy kifejleszd a saját alkalmazásaidat a QML és a Qt keretrendszer segítségével.

== Felhasználói felület létrehozása QML nyelven ==

Példa alkalmazásunk egy egyszerű szövegszerkesztő lesz, amely alkalmas egyszerű szövegfájlok megnyitására illetve alapvető szerkesztési műveletek elvégzésére. A leírás első részében a program felhasználói felületét tervezzük meg a QML leírónyelv segítségével. A második részben a fájlok betöltése és elmentése lesz implementálva C++ nyelven. A Qt [http://doc.qt.nokia.com/4.7/metaobjects.html Meta-Object System] segítségével a C++ függvényeket olyan tulajdonságokként ábrázolhatjuk, melyeket a QML elemek is képesek használni. QML és Qt C++ használatával hatékonyan szétválaszthatjuk a kezelői felület felépítését és a program logikáját.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor5_editmenu.png|qml-texteditor5_editmenu.png]]

QML példakódunk futtatásához csupán adjuk meg argumentumként a [http://doc.qt.nokia.com/4.7/qmlviewer.html qmlviewer] programnak a QML fájlunkat. Ezen útmutató C++ része feltételezi, hogy az olvasó le tud fordítani egy Qt-ban írt programot.

Az útmutató fejezetei:

# Nyomógomb és menü létrehozása
# Menüsáv implementálása
# Szövegszerkesztő létrehozása
# A szövegszerkesztő küllemének megteremtése
# QML kibővítése Qt C++ segítségével

== Nyomógomb és menü létrehozása ==

=== Alapelemek – a gomb ===

Szövegszerkesztőnket egy gomb létrehozásával kezdjük. Ha funkcionálisan nézzük, akkor a gomb rendelkezik egy egér számára érzékeny területtel és egy felirattal. A gombok akkor hajtják végre a feladatokat, ha a felhasználó rájuk klikkel. QML-ben a legalapvetőbb vizuális elem a [http://doc.qt.nokia.com/4.7/qml-rectangle.html Rectangle]. ''A Rectangle'' elem tulajdonságokkal rendelkezik, hogy beállíthassunk az elem megjelenését és elhelyezkedését.

Először az ''import Qt 4.7'' sor engedélyezi a qmlviewer eszköznek, hogy betöltse azokat a QML elemeket, melyeket később használni fogunk. Ennek a sornak szerepelnie kell minden QML fájlban! Figyeljük meg, hogy a Qt modulok verzióját az import utasítás már tartalmazza!

Ez az egyszerű ''Rectangle'' rendelkezik egy egyedi azonosítóval, ''simplebutton'', amely az ''id'' tulajdonsághoz kötődik. A ''Rectangle'' elem tulajdonságaihoz értékeket rendelünk a tulajdonság kilistázásakor, ekkor a kettőspont után áll az érték. A mintakódban a grey (szürke) színt rendeltük a ''Rectangle'' ''color'' tulajdonságához. Hasonlóan járunk el a ''Rectangle'' ''width'' és ''height'' tulajdonságainak esetében.

A ''Text'' elem egy nem szerkeszthető szövegmező. Nevezzük el ''buttonlabel''-ként ezt a ''Text'' elemet. A szövegmezőben lévő szöveget a ''Text'' tulajdonság segítségével módosíthatjuk. A feliratot a ''Rectangle'' tárolja és hogy középre igazítsuk, a ''Text'' elem ''anchors'' tuljadonságát a szülőjéhez rendeljük, ami itt most a ''simplebutton''. Az ''anchor''-ok (kapcsok) olykor más elemek ''anchor''-jaihoz kötődnek, hogy leegyszerűsítsék az elrendezést.

Most mentsük el a kódot ''SimpleButton.qml'' néven. Futtassuk a ''qmlviewer''-t a fájlunkat argumentumként megadva. Egy szürke téglalapot fogunk látni, benne a feliratunkkal.

A gombnyomás funkciójának implementálására használhatjuk a QML eseménykezelő metódusát. A QML esemény kezelése nagyon hasonlít a Qt signal and slot mechanizmusára. Példánkban az onClicked handlerben kezeljük le az eseményt.

&lt;code>
Rectangle{
 id:simplebutton
 …

MouseArea{
 id: buttonMouseArea

anchors.fill: parent //anchor all sides of the mouse area to the rectangle's anchors
 //onClicked handles valid mouse button clicks
 onClicked: console.log(buttonLabel.text + " clicked" )
 }
 }
&lt;/code>

Létrehozunk egy "MouseArea":qml-mousearea.html elemet a ''simplebutton''-on belül. A ''MouseArea'' elem meghatározza azt az interaktív területet, ahol érzékelni fogjuk majd az egérkattintásokat. Gombunk esetében az egész ''MouseArea''-t a szülőjéhez kapcsoljuk, ami most a ''simplebutton''. Az ''anchors.fill'' szintaktika is egy mód, hogy elérjünk egy bizonyos tulajdonságot (''fill''), az ''anchors'' tulajdonságokon belül. A QML kapocs alapú vázat használ, ahol az egyes elemek más elemekhez kapcsolhatók, így robosztus vázakat hozhatunk létre.

A ''MouseArea''-nak sok jelfeldolgozója ún. handler-je van, amelyek a meghatározott ''MouseArea'' határain belül történő egér események hatására hívódnak meg. Ezek közül az egyik az ''onClicked'', amely a gomb megnyomásakor hívódik meg, alapértelmezésben ez itt a bal gomb. Műveleteket is köthetünk az ''onClicked'' handler-jéhez. A példánkban, a ''console.log()'' szöveget ír a kimenetre, akárhányszor ráklikkelünk a ''MouseArea'' területére. ''A console.log()'' függvény egy nagyon hasznos eszköz hibakeresésre, segítségével bármit kiírathatunk a konzolba.

A ''SimpleButton.qml'' kódja már képes arra, hogy megjelenítsen egy gombot és szöveget írjon képernyőre klikkeléskor.

&lt;code>
Rectangle {
 id: button
 …

property color buttonColor: "lightblue"
 property color onHoverColor: "gold"
 property color borderColor: "white"

signal buttonClick()
 onButtonClick: {
 console.log(buttonLabel.text + " clicked" )
 }

MouseArea{
 id: buttonMouseArea
 onClicked: buttonClick()
 hoverEnabled: true
 onEntered: parent.border.color = onHoverColor
 onExited: parent.border.color = borderColor
 }

//determines the color of the button by using the conditional operator
 color: buttonMouseArea.pressed ? Qt.darker(buttonColor, 1.5) : buttonColor
 }
&lt;/code>

Egy teljesen működő gomb a ''Button.qml'' fájlban található. Ebben a leírásban szereplő kódrészlet mellőz néhány részletet, mert azokat már vagy tárgyaltuk az előzőekben vagy irreleváns a kód értelmezése szempontjából.

Egyedi tulajdonságokat a ''tulajdonság típus név'' szintaktikával tudunk deklarálni. Kódunkban a ''color'' típusú ''buttonColor'' tulajdonsághoz a „lightblue"-t rendeljük. A ''buttonColor'' később lesz használva egy kiegészítő műveletben, hogy meghatározzuk a gomb kitöltési színét. Megemlítendő, hogy értékadás az = jellel is történhet a kettőspont helyett. Az egyedi tulajdonságok lehetővé teszik, hogy belső elemek kívülről hozzáférhetőek legyenek, a ''Rectangle'' hatósugarán kívül is. A QML-nek megvannak a maga alaptípusai, mint az ''int'', a ''real'', a ''string'', vagy az általános konténertípus a ''variant''.

Színeket hozzáadva az ''onEntered'' és az ''onExited'' jelkezelőkhöz, a gomb szegélye sárgává fog válni, amikor az egér a gomb fölé ér, és visszaáll az eredeti színre, ha a kurzor távozik a területéről.

Egy ''buttonClick()'' signalt is deklarálunk a ''Button.qml''-ben a signal neve elé tett signal kulcsszóval. Minden signal-nak automatikusan létrejön a handler-je, „on"-al kezdődő nevekkel. Így értelemszerűen az ''onButtonClicked'' a ''buttonClicked'' handler-je. Ezután az ''onButtonClicked''-edet összekötjük egy művelettel, hogy az megfelelően működhessen. A mi gomb-példánkban egérkattintásra az ''onClicked'' handlerje szimplán meg fogja hívni az ''onButtonClick'' függvényt, mely megjelenít egy szöveget. Az ''onButtonClick'' lehetővé teszi, hogy külső objektumok könnyedén hozzáférjenek a ''Button'' klikkelési területéhez. Például egy elemnek több ''MouseArea'' deklarációja is van és a ''ButtonClick'' signal jobban el tudja végezni a megkülönböztetést a több ''MouseArea'' handler között.

Most már megvan az alaptudásunk, hogy implementáljunk olyan elemeket QML-ben, melyek képesek lekezelni alap egérműveleteket. Hozzunk létre egy ''Text'' feliratot egy ''Rectangle''-ben, szabjuk testre a tulajdonságait és implementáljuk az egérmozgásokra válaszoló műveleteit. Ez az alapelv, hogy elemeket hozunk létre más elemeken belül, végig fogja kísérni a szövegszerkesztő programunkat. Ám ez a gomb haszontalan, amíg nem műveletek ellátására szolgáló komponensként használjuk. A következő részben létrehozunk egy menüt, mely több ilyen gombot is tartalmazni fog.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor1_button.png|qml-texteditor1_button]]

=== Menü létrehozása ===

Eddig a részig áttekintettük, hogyan hozzunk létre elemeket és kössünk hozzájuk műveleteket egy QML fájlon belül. Ebben a fejezetben megtanuljuk, hogyan importáljunk QML elemeket és hogyan használjuk fel ezeket a komponenseket újra, hogy újabb komponenseket hozzunk létre.

Egy menü egy lista tartalmát jeleníti meg, mindegyik elemnek megvan a lehetősége, hogy végrehajtson egy feladatot. QML-ben sokféleképpen hozhatunk létre menüket. Először egy, a gombokat tartalmazó menüt fogunk készíteni, melyek különböző műveleteket hajtanak majd végre. A menü kódja a ''FileMenu.qml''-ben található.

&lt;code>
import Qt 4.7 import the main Qt QML module
import "folderName" import the contents of the folder
import "script.js" as Script import a Javascript file and name it as Script
&lt;/code>

A fent használt szintaktika megmutatja, hogyan használjuk az import parancsot. Olyan JavaScript vagy QML fájlok használatakor van szükségünk rá, melyek nem ugyanabban a mappában vannak. Mivel a ''Button.qml'' ugyanabban a mappában van, mint a ''FileMenu.qml'', így nem kell importálnunk a ''button.qml''-t, hogy használhassuk. Azonnal létrehozhatunk egy ''Button'' elemet a ''Button { }'' függvényt deklarálva, hasonlóan a ''Rectangle { }''-hoz.

&lt;code>
In FileMenu.qml:

Row{
 anchors.centerIn: parent
 spacing: parent.width/6

Button{
 id: loadButton
 buttonColor: "lightgrey"
 label: "Load"
 }
 Button{
 buttonColor: "grey"
 id: saveButton
 label: "Save"
 }
 Button{
 id: exitButton
 label: "Exit"
 buttonColor: "darkgrey"

onButtonClick: Qt.quit()
 }
 }
&lt;/code>

A ''FileMenu.qml''-ben deklaráljunk egy ''Row'' elemen belül 3 ''Button'' elemet. A ''Row'' egy pozícionáló elem, ami egy vízszintes sorban rendezi el a gyerekeit.

A ''Button'' deklarációja a ''Button.qml''-ben van, ami ugyan az a ''Button.qml'', amit mi az előző fejezetben használtunk. Új tulajdonságkötéseket deklarálhatunk az újonnan létrehozott gombokban, hatékonyan felülírva a ''Button.qml''-ben beállított tulajdonságokat. Az Exit gomb megnyomásának hatására ki fog lépni a program és bezárja az ablakot. Gondoljuk végig, hogy a ''Button.qml''-ben lévő ''onButtonClick'' signal handler is meg lesz hívva az ''exitButton''-ban lévő ''onButtonClick'' handleren kívül.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor1_filemenu.png|qml-texteditor1_filemenu]]

A ''Row''.t a ''Rectangle''.en belül deklaráljuk, ezzel létrehozunk egy _Rectangle- tárolót a gombok sorának. A második ''Rectangle'' létrehozása a menü gombjainak egy sorban történő tárolására indirekt módon történik. A Edit menü nagyon hasonló ebben a fázisban. Ez a menu is 3 gombot fog tartalmazni a következő nevekkel: Copy, Paste, Select All.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor1_editmenu.png|qml-texteditor1_editmenu]]

Most, hogy tudjuk hogyan importáljuk és szabjuk testre az előzőleg már létrehozott komponenseiket, már elkészíthetjük a menüsorunkat, mely a menüpontok kiválasztására szolgáló gombokból fog állni. Nézzük meg, hogyan rendszerezzük adatainkat a QML-ben!

== A menüsor implementálása ==

Szövegszerkesztőnknek meg kell tudni jelenítenie a menüket a menüsorból. A menüsoron kiválaszthatja a felhasználó, hogy melyik menüt jelenítse meg a program. A menük közötti váltásból következik, hogy az egy sorba rendezésnél bonyolultabb struktúrával fog rendelkezni a menünk.

=== Adatmodellek (''Data Models'') és adatnézetek (''Data Views'') használata: ===

Különböző [http://doc.qt.nokia.com/4.7/qdeclarativemodels.html Data View] -kal rendelkezik a QML a [http://doc.qt.nokia.com/4.7/qdeclarativemodels.html Data Model] -ek megjelenítésére. Menüsorunk listaként fogja megjeleníteni a kiválasztott menüt egy fejléccel, ahol többi menü nevét soroljuk fel vízszintesen. A menülistánk egy [http://doc.qt.nokia.com/4.7/qml-visualitemmodel.html VisualItemModel] -ben lesz deklarálva, mely olyan elemeket tartalmaz, melyek már eleve rendelkeznek valamilyen megjelenéssel, mint például egy ''Rectangle'' vagy egy importált UI elem. Más modell típusoknak, mint például a [http://doc.qt.nokia.com/4.7/qml-listmodel.html ListModel], egy megbízott kell, hogy megjelenítse az adatait. Két vizuális elemet deklarálunk a menuListModel-ünkben, a ''FileMenu''-t és az ''EditMenu''-t. Testreszabjuk a két menüt és megjelenítjük őket a [http://doc.qt.nokia.com/4.7/qml-listview.html ListView] -val. A ''Menubar.qml'' fájlunk tartalmazza a QML deklarálását és egy egyszerű szerkesztői menüt, melyet az ''EditMenu.qml''-ben hoztunk létre.

&lt;code>
VisualItemModel{
 id: menuListModel
 FileMenu{
 width: menuListView.width
 height: menuBar.height
 color: fileColor
 }
 EditMenu{
 color: editColor
 width: menuListView.width
 height: menuBar.height
 }
 }
&lt;/code>

A ''ListView'' elem egy megbízotton keresztül fogja megjeleníteni a modellünket. A megbízott lehet hogy meghatározza, hogy például egy sorban vagy egy hálóban jelenítse meg az elemeket. A mi ''menuListModel''-ünknek már vannak látható elemei, így nekünk nem kell megbízottat deklarálnunk hozzá.

&lt;code>
ListView{
 id: menuListView

//Anchors are set to react to window anchors
 anchors.fill:parent
 anchors.bottom: parent.bottom
 width:parent.width
 height: parent.height

//the model contains the data
 model: menuListModel

//control the movement of the menu switching
 snapMode: ListView.SnapOneItem
 orientation: ListView.Horizontal
 boundsBehavior: Flickable.StopAtBounds
 flickDeceleration: 5000
 highlightFollowsCurrentItem: true
 highlightMoveDuration:240
 highlightRangeMode: ListView.StrictlyEnforceRange
 }
&lt;/code>

A [http://doc.qt.nokia.com/4.7/qml-flickable.html Flickable] -ből örököljük a ''ListView''-unkat, ezzel a listánk reagálhat majd az egérmozdulatokra és más gesztusokra. Fenti kódunk utolsó része beállítja a ''Flickable'' tuljadonságait, hogy létrehozzunk a nézetünk kívánt kinetikus mozgását. A ''highLightMovementDuration'' tuljadonság meghatározza, hogy meddig tartson a kinetikus transzformáció. Egy nagyobb ''highLightMovementDuration'' érték lassabb menüváltást fog eredményezni. A ''ListView'' a modell minden egyes elemét egy indexszel látja el a deklarálásuk sorrendjében, melyeket ezeken az indexeken keresztül érhetünk el. A ''currentIndex'' értékének megváltoztatásával a ''ListView'' egy másik elemét jelöljük ki. A menüsor fejlécére is hatással lesz ez az effektus. Két gomb van egy sorban, melyek mindketten megváltozatják a megjelenített menüt, ha rájuk klikkelünk. A ''filebutton''-ra kattintva megjelenik a fálj menü, az index pedig 0 lesz, mivel a ''FileMenu''-t deklaráltuk először. A ''labelList'' ''rectangle''-jének van egy z értéke, mely itt 1, ezzel jelölve, hogy ezt a menüsor előtt jelenítjük meg. Minél nagyobb a z értéke, annál előrébb foglal helyet a képernyőre merőleges síkban. A z alapértelmezett értéke 0.

&lt;code>
 Rectangle{
 id: labelList
 …
 z: 1
 Row{
 anchors.centerIn: parent
 spacing:40
 Button{
 label: "File"
 id: fileButton
 …
 onButtonClick: menuListView.currentIndex = 0
 }
 Button{
 id: editButton
 label: "Edit"
 …
 onButtonClick: menuListView.currentIndex = 1
 }
 }
 }
&lt;/code>

A létrehozott menüsorunkon vagy a felette lévő két gomb valamelyikére klikkelve megjeleníthetjük a menüket. Így egy intuitív és interaktív menüválasztó képernyőt alkottunk.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor3_texteditor.png|qml-texteditor3_texteditor]]

== A szövegszerkesztő megalkotása ==

=== TextArea deklarálása ===

Szövegszerkesztőnk mindaddig nem szövegszerkesztő, amíg nem tartalmaz egy szerkeszthető szövegmezőt.
A QML [http://doc.qt.nokia.com/4.7/qml-textedit.html TextEdit] eleme egy többsoros szövegmező létrehozását teszi lehetővé. A ''TextEdit'' különbözik a [http://doc.qt.nokia.com/4.7/qml-text.html Text] elemtől, melyet a felhasználó nem szerkeszthet direkt módon.

&lt;code>
 TextEdit{
 id: textEditor
 anchors.fill:parent
 width:parent.width; height:parent.height
 color:"midnightblue"
 focus: true

wrapMode: TextEdit.Wrap

onCursorRectangleChanged: flickArea.ensureVisible(cursorRectangle)
 }
&lt;/code>

A szerkesztőnek megvan a saját betűszín tulajdonsága is. A ''TextArea'' egy ''flickable'' mezőn belül van, mely görgetni fogja a szöveget, ha a szövegkurzor a látható mezőn kívül van. Az ''ensureVisibility()'' függvény fogja leellenőrizni, hogy a kurzor ''rectangle''-je kívül van-e a látható szegélyeken, és ha igen, akkor ennek megfelelően fogja mozgatni a szövegmezőt. A QML JavaScript szintaktikát használ a kódjaihoz, és ahogy már korábban említettük, importálhatunk és használhatunk is Javascript fájlokat egy QML fájlon belül.

&lt;code>
 function ensureVisible®{
 if (contentX >= r.x)
 contentX = r.x;
 else if (contentX+width &lt;= r.x+r.width)
 contentX = r.x+r.width-width;
 if (contentY >= r.y)
 contentY = r.y;
 else if (contentY+height &lt;= r.y+r.height)
 contentY = r.y+r.height-height;
 }
&lt;/code>

=== Komponensek kombinálása a szövegszerkesztőhöz ===

Most már készen állunk, hogy létrehozzuk szövegszerkesztőnket a QML segítségével. Programunk két fő komponensből áll, az általunk létrehozott menüsorból és egy szövegmezőből. A QML lehetővé teszi, hogy újrafelhasználjuk komponenseinket azok importálásával és testreszabásával ha szükséges, ezzel is egyszerűbbé téve a kódunkat. A szövegszerkesztőnk egyharmadát a menüsor, kétharmadát a szövegmez fogja elfoglalni. A menüsor minden más elem előtt fog megjelenni.

&lt;code>
 Rectangle{

id: screen
 width: 1000; height: 1000

//the screen is partitioned into the MenuBar and TextArea. 1/3 of the screen is assigned to the MenuBar
 property int partition: height/3

MenuBar{
 id:menuBar
 height: partition
 width:parent.width
 z: 1
 }

TextArea{
 id:textArea
 anchors.bottom:parent.bottom
 y: partition
 color: "white"
 height: partition*2
 width:parent.width
 }
 }
&lt;/code>

Újrafelhasznált komponenseikkel sokkal egyszerűbbnek tűnik a ''TextEditor'' forráskódja. Ezután testreszabhatjuk a fő alkalmazásunkat anélkül, hogy az előre definiál tulajdonságok miatt kellene aggódnunk. Ezzel a módszerrel könnyedén hozhatunk létre programvázakat és interfészeket.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor3_texteditor.png|qml-texteditor3_texteditor]]

== Szövegszerkesztőnk megjelenésének testreszabása ==

=== A Drawer Interface implementálása ===

A szövegszerkesztőnk egyszerűen néz ki, most már a megjelenését is testre kellene szabnunk. A QML-t használva átmeneteket és animációkat deklarálhatunk a szövegszerkesztőnkhöz. Menüsorunk elfoglalja az ablak egyharmadát, így jó lenne, ha csak akkor jelenne meg, ha mi akarjuk.
Hozzáadhatunk egy rajzoló interfészt, amely összecsukja illetve megjeleníti a menüsort klikkeléskor. Jelen esetben egy kis ''rectange''.t használtunk, mely reagál az egérkattintásokra. A ''drawer'', akárcsak az maga az alkalmazás, két állapottal rendelkezik, egy nyitottal és egy zárttal. A ''drawer'' elem egy kis magasságú rectangle, amihez kapcsolunk egy "Image":ttp://doc.qt.nokia.com/4.7/qml-image.html elemet, egy kis nyíl ikont jelenítve meg középen a ''rectangle''-ön belül. A ''drawer'' meghatározza az program állapotát, ahogy a felhasználó rákattint a kis nyílra.

&lt;code>
Rectangle{
 id:drawer
 height:15

Image{
 id: arrowIcon
 source: "images/arrow.png"
 anchors.horizontalCenter: parent.horizontalCenter
 }

MouseArea{
 id: drawerMouseArea
 anchors.fill:parent
 onClicked:{
 if (screen.state "DRAWER_CLOSED"){
 screen.state = "DRAWER_OPEN"
 }
 else if (screen.state "DRAWER_OPEN"){
 screen.state = "DRAWER_CLOSED"
 }
 }
 …
 }
 }
&lt;/code>

Ez az állapot egy sor konfigurációs beállítás, melyeket [http://doc.qt.nokia.com/4.7/qml-state.html State] elemeken keresztül deklarálunk. A különböző állapotok a ''state'' tulajdonsághoz kötődnek és kilistázhatjuk őket onnan. Az alkalmazásunkban két állapot, a ''DRAWER_CLOSED'' és a ''DRAWER_OPEN'' lesz. Az elemek konfigurációja a [http://doc.qt.nokia.com/4.7/qml-propertychanges.html PropertyChanges] elemben lesznek deklarálva. A DRAWER_OPEN állapotban 4 elem tulajdonsága fog megváltozni. A ''menuBar'' y tulajdonsága 0-ra fog változni. Hasonlóképpen, a ''textArea'' pozíciója lejjebb fog kerül, ha a ''DRAWER_OPEN'' állapot az aktív. A ''textArea'', a ''drawer'' és a ''drawer'' ikonja fog változáson keresztülmenni, hogy elérje a megfelelő állapotot.

&lt;code>
 states:[
 State {
 name: "DRAWER_OPEN"
 PropertyChanges { target: menuBar; y: 0}
 PropertyChanges { target: textArea; y: partition + drawer.height}
 PropertyChanges { target: drawer; y: partition}
 PropertyChanges { target: arrowIcon; rotation: 180}
 },
 State {
 name: "DRAWER_CLOSED"
 PropertyChanges { target: menuBar; y:-height; }
 PropertyChanges { target: textArea; y: drawer.height; height: screen.height – drawer.height }
 PropertyChanges { target: drawer; y: 0 }
 PropertyChanges { target: arrowIcon; rotation: 0 }
 }
 ]
&lt;/code>

Az állapotváltozások azonnaliak, ám az átmenetnek ennél finomabbaknak kell lenniük. A [http://doc.qt.nokia.com/4.7/qml-transition.html Transition] elemben határozzuk meg a különböző állapotok közötti átmeneteket, amelyet ezután az elem ''transitions'' tulajdonságához rendelhetjük. A szövegszerkesztőnknek állapotátmenete lesz, akár ''DROWER_OPEN''-re akár ''DROWER_CLOSED''-ra módosul az állapota. Fontos, hogy az átmeneteknek rendelkezniük kell egy ''from'' (honnan) és egy ''to'' (hová) állapottal, de jelen esetben használhatunk csillagot * is, jelölve, hogy ez itt minden átmenetre vonatkozik. Az átmenetek során animációkat rendelhetünk a tulajdonság változásokhoz. A menüsorunk y : 0-ból y : x helyre ugrik, de ezt a mozgást leanimálhatjuk a [http://doc.qt.nokia.com/4.7/qml-numberanimation.html NumberAnimation] elem használatával. A cél elem tulajdonságait úgy állítjuk be, hogy annak mozgása egy meghatározott idő alatt, egy előre meghatározott csillapított görbe mentén animálódjon. Ez a csillapított görbe fogja szabályozni az animáció tulajdonságait az állapotváltozások között. Ez az ún. easing curve most az [http://doc.qt.nokia.com/4.7/qml-propertyanimation.html#easing.type-prop Easing.OutQuint] lesz, amely lelassítja az elem mozgását az animáció vége felé. Bővebb információért érdemes elolvasni a [http://doc.qt.nokia.com/4.7/qdeclarativeanimation.html QML's Animation] c. leírást.

&lt;code>
transitions: [
 Transition {
 to: "*"
 NumberAnimation { target: textArea; properties: "y, height"; duration: 100; easing.type:Easing.OutExpo }
 NumberAnimation { target: menuBar; properties: "y"; duration: 100; easing.type: Easing.OutExpo }
 NumberAnimation { target: drawer; properties: "y"; duration: 100; easing.type: Easing.OutExpo }
 }
 ]
&lt;/code>

Egy másik módja a tulajdonságváltozások animálásnak egy [http://doc.qt.nokia.com/4.7/qml-behavior.html Behavior] elem deklarálása. Egy átmenet csak állapotváltozások alatt működik, míg a ''Behavior'' hozzárendelhető egy egyszerű tulajdonságváltozáshoz is. A szövegszerkesztőnkben a nyílnak van egy ''NumberAnimation-ja'', mely leanimálja annak ''rotation'' tulajdonságát valahányszor megváltozik az.

&lt;code>
In TextEditor.qml:

Behavior{
 NumberAnimation{property: "rotation";easing.type: Easing.OutExpo }
 }
&lt;/code>

Térjünk vissza a komponenseinkhez az állapotokról és az animációkról megszerzett tudásunkkal, most már szebbé tehetjük azok megjelenését. A ''Button.qml''-ben a gomb lenyomásához ''color'' és ''scale'' tulajdonságokat adhatunk. A szín típusokat a [http://doc.qt.nokia.com/4.7/qml-coloranimation.html ColorAnimation] fogja animálni, míg a számokat a ''NumberAnimation''. Az alant látható ''on propertyName'' szintakszis hasznos lehet, ha csak egyetlen tulajdonságra akarunk utalni.

&lt;code>
In Button.qml:
 …

color: buttonMouseArea.pressed ? Qt.darker(buttonColor, 1.5) : buttonColor
 Behavior on color { ColorAnimation{ duration: 55} }

scale: buttonMouseArea.pressed ? 1.1 : 1.00
 Behavior on scale { NumberAnimation{ duration: 55} }
&lt;/code>

Még mutatósabbá tehetjük QML komponenseinket, ha olyan effektusokat adunk hozzájuk, mint a gradiens vagy az átlátszóság. Egy [http://doc.qt.nokia.com/4.7/qml-gradient.html Gradient] elem deklarálásával felülírhatjuk az elem ''color'' tulajdonságát. A [http://doc.qt.nokia.com/4.7/qml-gradientstop.html GradientStop] elemmel színeket is deklarálhatunk a gradiensünkön belül, melyet egy 0.0 és 1.0 közötti skálával adunk meg.

&lt;code>
In MenuBar.qml
 gradient: Gradient {
 GradientStop { position: 0.0; color: "#8C8F8C" }
 GradientStop { position: 0.17; color: "#6A6D6A" }
 GradientStop { position: 0.98;color: "#3F3F3F" }
 GradientStop { position: 1.0; color: "#0e1B20" }
 }
&lt;/code>

A menüsorunkon használjuk majd a gradienst egy színátmenet megjelenítésére. Az első szín 0.0-nál kezdődik, az utolsó pedig 1.0-nál végződik.

=== Innen hova ===

Ezzel befejeztük egy nagyon egyszerű szövegszerkesztő felhasználói felületét. Tovább haladva most már implementálhatjuk az alkalmazásunk logikáját a jól megszokott Qt és C++ segítségével. A QML szépen dolgozik, elválasztva előbbit az UI designtól.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor4_texteditor.png|qml-texteditor4_texteditor]]

== QML kibővítése Qt C++ használatával ==

Már megvan a szövegszerkesztőnk váza, most implementálhatjuk a funkciókat C++ -ban. A QML-t és a C++ -t együtt használva lehetőségünk van Qt-ben létrehozni a program logikáját. Beilleszthetünk egy QML kotextust a C++ alkalmazásunkban a [http://doc.qt.nokia.com/4.7/qtbinding.html Qt's Declarative] osztályok használatával és meg is jeleníthetjük a QML elemeket a Graphic Scene segítségével. Vagy exportálhatjuk a C++ kódunkat egy olyan pluginba, amit a qmlviewer olvasni tud. A programunk számára a mentés és betöltés funkciókat C++ -ban fogjuk implementálni és ezt exportáljuk egy pluginba. Így csak a QML fájlunkat kell betöltenünk, nem kell egy futtatható állományt elindítani.

=== C++ osztályok megismertetése a QML-el ===

Qt és C++ segítségével fogjuk implementálni a betöltés és mentés opciókat. A C++ osztályok és függvények használatához regisztrálni kell őket a QML-ben. Az osztály továbbá Qt pluginként kell fordítani és a QML fájlnak tudnia kell, hogy ez a plugin merre található.

Az alkalmazásunk számára a következő elemeket kell létrehoznunk:
# Directory osztály, mely a mappákhoz kötődő művelteket fogja végrehajtani
# File osztály, ami egy [http://doc.qt.nokia.com/4.7/qobject.html QObject], amely fájlok listáját szimulálja egy mappában
# plugin osztály mely a QML kontextushoz fogja regisztálni az osztályt
# Qt project fájl, mely majd lefordítja a plugin-t
# qmldir, mely átadja a plugin helyét a qmlviewer számára

=== Qt plugin létrehozása ===

A plugin létrehozásához a következőket kell beállítanunk a Qt project fájlunkban. Első körben a szükséges sources, headers, és a Qt modules szerepelnek a hozzáadandók listájában. Az összes C++ kód és project fájl a ''filedialog'' könyvtárban lesz.

&lt;code>
In cppPlugins.pro:

TEMPLATE = lib
 CONFIG ''= qt plugin
 QT''= declarative

DESTDIR ''= ../plugins
 OBJECTS_DIR = tmp
 MOC_DIR = tmp

 TARGET = FileDialog

 HEADERS''= directory.h  file.h  dialogPlugin.h

SOURCES += directory.cpp  file.cpp  dialogPlugin.cpp
&lt;/code>

A ''declarative'' modullal fordítjuk a Qt-t és _plugin_ként konfiguráljuk, amihez egy ''lib'' sablonra lesz szükségünk. A szülő ''plugins'' mappába kell tennünk a lefordított plugint.

=== Egy osztály regisztrálása QML-ben ===

&lt;code>
In dialogPlugin.h:

#include &lt;QDeclarativeExtensionPlugin>

class DialogPlugin : public QDeclarativeExtensionPlugin
 {
 Q_OBJECT

public:
 void registerTypes(const char *uri);

};
&lt;/code>

A ''DialogPlugin'' osztályunk a [http://doc.qt.nokia.com/4.7/qdeclarativeextensionplugin.html QDeclarativeExtensionPlugin] egy alosztálya. Implementálnunk kell az örökölt függvényt, a [http://doc.qt.nokia.com/4.7/qdeclarativeextensionplugin.html#registerTypes registerTypes()] -t. A ''dialogPlugin.cpp'' a következőképpen néz ki:

&lt;code>
DialogPlugin.cpp:

#include "dialogPlugin.h"
 #include "directory.h"
 #include "file.h"
 #include &lt;qdeclarative.h>

void DialogPlugin::registerTypes(const char '''uri){

 qmlRegisterType&lt;Directory>(uri, 1, 0, "Directory");
 qmlRegisterType&lt;File>(uri, 1, 0,"File");
 }

 Q_EXPORT_PLUGIN2(FileDialog, DialogPlugin);
&lt;/code>

A ''registerTypes()'' függvény regisztrálja a ''FILE'' és ''DIRECTORY'' osztályainkat QML-ben. Ennek a függvénynek meg kell adni a sablonja nevét, a fő- és az alverziószámot, valamint természetesen az osztályunk nevét.

Exportálnunk kell a plugint a [http://doc.qt.nokia.com/4.7/qtplugin.html#Q_EXPORT_PLUGIN2 Q_EXPORT_PLUGIN2] makróval. Megjegyzendő, hogy a ''dialogPlugin.h'' fájlunkban ott van a [http://doc.qt.nokia.com/4.7/qobject.html#Q_OBJECT Q_OBJECT] makró az osztályunk tetején. Majd futassuk a ''qmkae''-t a project fájlunkon hogy legeneráljuk a szükséges meta-object kódot.

=== QML tulajdonságok létrehozása C++ osztályban ===
Létrehozhatunk QML elemeket és tulajdonságokat a C++ és a [http://doc.qt.nokia.com/4.7/metaobjects.html Qt's Meta-Object System] segítségével. Implementálhatjuk ezeket a tulajdonságokat slot-ok és signal-ok használatával, átadva ezeket a Qt-nek.

A szövegszerkesztőnknek be kell tudnia tölteni, illetve elmenteni a fájlokat. Általában ezeket a funkciókat egy fájl dialogban valósítjuk meg. Szerencsére használhatjuk a [http://doc.qt.nokia.com/4.7/qdir.html QDir], [http://doc.qt.nokia.com/4.7/qfile.html QFile], [http://doc.qt.nokia.com/4.7/qtextstream.html QTextStream] függvényeket, hogy implementáljuk a mappaolvasásokat és az input/output folyamatokat.

&lt;code>
class Directory : public QObject{

 Q_OBJECT

 Q_PROPERTY(int filesCount READ filesCount CONSTANT)
 Q_PROPERTY(QString filename READ filename WRITE setFilename NOTIFY filenameChanged)
 Q_PROPERTY(QString fileContent READ fileContent WRITE setFileContent NOTIFY fileContentChanged)
 Q_PROPERTY(QDeclarativeListProperty&lt;File> files READ files CONSTANT )

 …
&lt;/code>

A ''Directory'' class a Qt's Meta-Object System-et használja, hogy regisztrálja a fájlkezelés megvalósításához szükséges tulajdonságokat. A ''Directory'' osztályt pluginként exportáltuk és QML-ben Directory elemként hivatkozhatunk rá. Az összes listázott tulajdonság a Q_PROPERTY makrót használja, amely egy QML tulajdonság.

A [http://doc.qt.nokia.com/4.7/qobject.html#Q_PROPERTY Q_PROPERTY] deklarál egy tulajdonságot, továbbá függvényeket olvas és ír a Qt's Meta-Object System-ből/be. Például a [http://doc.qt.nokia.com/4.7/qstring.html QString] ''filename'' tulajdonságát a ''filename()'' függvénnyel tudjuk olvasni, illetve a ''setFilename()'' függvénnyel írni. Továbbá egy signál, a ''filenameChanged()'', is rendelve van a ''filename'' tulajdonsághoz, amely minden esetben emittálásra kerül, ha a tulajdonság megváltozik. Az író és olvasó függvényeket ''public''-ként deklaráljuk a header fájlban. 

Hasonlóképpen deklaráljuk a többi tulajdonságot, természetesen a használatuknak megfelelően. A ''filesCount'' tulajdonság az adott mappában lévő fájlok számát adja jelzi. A ''filename'' tulajdonság mindig az éppen kijelölt fájl nevét tárolja, a ''fileContent'' tulajdonságban pedig a betöltött/elmentett fájl tartalma tárolódik el.

&lt;code>
 Q_PROPERTY(QDeclarativeListProperty&lt;File> files READ files CONSTANT )
&lt;/code>

A ''files'' lista tulajdonság egy lista a mappában lévő fájlokról. A ''Directory'' osztály azért implementáltuk, hogy kiszűrje az érvénytelen szöveges fájlokat, csak a .txt kiterjesztésűek lesznek érvényesek. Továbbá a [http://doc.qt.nokia.com/4.7/qlist.html QList] [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html QDeclarativeListProperty] -ként delarálva C++ -ban lesz használható QML-ben. A sablon objektumot a [http://doc.qt.nokia.com/4.7/qobject.html QObject] -től kell származtatni, így a File osztályt is. A ''Directory'' osztályban, a ''File'' objektumok listáját a _QList_–ben tárolj ''m_fileList'' néven.

&lt;code>
class File : public QObject{

 Q_OBJECT
 Q_PROPERTY(QString name READ name WRITE setName NOTIFY nameChanged)

 …
 };
&lt;/code>

Ez a tulajdonság ezután a ''Directory'' elem tulajdonságainak részeként használható QML-ben. Jegyezzük meg, hogy nem kell azonosító ''id'' tulajdonságot létrehoznunk a C++ kódunkban.

&lt;code>
Directory{
 id: directory

 filesCount
 filename
 fileContent
 files

 files[0].name
 }
&lt;/code>

Mivel a QML Javascript szintaktikát és struktúrát használ, így végigfuthatunk a fájlok listáján és meg is kapjuk azok tulajdonságait. Hogy megkapjuk az első fájl név tulajdonságát, csak hívjuk meg a ''files[0].name'' függvényt.

A sima C++ függvények is elérhetőek QML–ben. A betöltő és elmentő függvények C++ -ban kerültek implementálásra a [http://doc.qt.nokia.com/4.7/qobject.html#Q_INVOKABLE Q_INVOKABLE] makró felhasználásával. De _slot_–ként is deklarálhatjuk a függvényeket, melyek ezután elérhetőek lesznek QML –ben.

&lt;code>
In Directory.h:

 Q_INVOKABLE void saveFile();
 Q_INVOKABLE void loadFile();
&lt;/code>

A ''Directory'' osztálynak tudomást kell szereznie más objektumokról, ha megváltozik a mappa tartalma. Ezt a funkciót _signal_–ok használatával oldjuk meg. Ahogy előzőleg említettük, a QML _signal_–oknak van egy hozzájuk tartozó végrehajtójuk, egy ún. _handler_–jük, amelyek neve megegyezik egy on prefixumot leszámítva. A signal neve ''directoryChanged'' és ez mindig emittálásra kerül, ha a mappa frissül. A frissítés szimplán újra betölti a mappa tartalmát és frissíti a listában a mappa érvényes fájljait. Ezek a QML elemek észrevehetőek felhasználjuk az ''onDirectoryChanged'' handler-t.

Érdemes tovább vizsgálni a list tulajdonságokat, ugyanis ún. callback-eket, visszahívásokat alkalmaznak, hogy elérjék és módosítsák a lista tartalmát. A list tulajdonság ''QDeclarativeListProperty&lt;File>'' típusú, így akárhányszor hozzáférünk a listához, a hozzáférőnek egy ''QDeclarativeListProperty&lt;File>''-al kell visszatérnie. A sablon típusnak, a _File_–nak ''QObject'' leszármaztatottnak kell lennie! Hogy létrehozzunk egy [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html QDeclarativeListProperty] -t , a lista hozzáférőjét és módosítóját függvény mutatókként át kell adni konstruktornak! A listának, esetünkben a _QList_–nek egy ''File'' mutató listának kell lennie! A ''QDeclarativeProperrty'' konstruktor konstruktorának és a Directory implementálása:

&lt;code>
 QDeclarativeListProperty ( QObject''' object, void * data, AppendFunction append, CountFunction count = 0, AtFunction at = 0, ClearFunction clear = 0 )
 QDeclarativeListProperty&lt;File>( this, &amp;m_fileList, &amp;appendFiles, &amp;filesSize, &amp;fileAt, &amp;clearFilesPtr );
&lt;/code>

A konstruktor átadja a mutatókat a függényekneknek, amik csatolják, megszámolják a elemeinek számát vagy kiürítik a listát, illetve visszanyerik az elemeit az indexek segítségével. Csak az append (csatoló) függvény megbízott. Megjegyzendő, hogy a függvény mutatóknak meg kell egyezniük az [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#AppendFunction-typedef AppendFunction], a [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#CountFunction-typedef CountFunction], az [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#AtFunction-typedef AtFunction], és a [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#ClearFunction-typedef ClearFunction] definícióival!

&lt;code>
void appendFiles(QDeclarativeListProperty&lt;File> * property, File * file)
 File* fileAt(QDeclarativeListProperty&lt;File> * property, int index)
 int filesSize(QDeclarativeListProperty&lt;File> * property)
 void clearFilesPtr(QDeclarativeListProperty&lt;File> *property)
&lt;/code>

Hogy egyszerűbbé tegyük a dialógunkat, a ''Directory'' osztály kiszűr minden fájlt, amely nem .txt kiterjesztésű és csak azokat jeleníti meg, amelyek azok. Sőt, ez az implementáció arról is gondoskodik, hogy az elmentett fájljaink megfelelő (.txt) kiterjesztést kapjanak. A ''Directory'' a [http://doc.qt.nokia.com/4.7/qtextstream.html QTextStream] függvényt használja, hogy kiolvasson a fájlból, illetve hogy írjon bele.

A ''Directory'' elemünkkel tehát visszanyerhetjük a fájljaink listáját, azok nevét és tartalmát stringként, megtudhatjuk, hogy hány fájl van az adott mappában, és valahányszor megváltozik annak tartalma, arról értesítést kaphatunk.

Ahhoz hogy létrehozzuk a _plugin_–t, futassuk a _qmake_–t a ''cppPlugins.pro'' project fájlon, aztán futassuk a ''make'' parancsot hogy lefordítsuk és áthelyezzük a pluginunkkat a plugins könyvtára.

=== Plugin importálása QML-ben ===

A ''qmlviewer'' azokat a fájlokat importálja, amelyek az alkalmazásunkkal egy mappában van. De létrehozhatunk egy ''qmldir'' fájlt is, amely tartalmazza majd, hogy merre találhatóak a QML fájljaink, melyeket importálni szeretnénk. A ''qmldir'' fájl tovább tartalmazhatta más pluginok és ún. ''resources'', eszközök helyét.

&lt;code>
In qmldir:

Button ./Button.qml
 FileDialog ./FileDialog.qml
 TextArea ./TextArea.qml
 TextEditor ./TextEditor.qml
 EditMenu ./EditMenu.qml

plugin FileDialog plugins
&lt;/code>

A ''plugin'', melyet fentebb létrehoztunk ''FileDialog'' névvel rendelkezik, ahogy azt a ''TARGET'' mezőben is jeleztük a project fájlunkban. A lefordított plugin a plugins könyvtárban található.

=== Egy File Dialog integrálása a File Menu–be ===

A _FileMenu_–ünknek egy _FileDialog_–ot kell elemet megjelenítenie, amely tartalmazza a könyvtár, .txt kiterjesztésű, fájljait és lehetővé teszi a felhasználó számára, hogy kiválassza a megnyitni kívánt fájlt. Továbbá el kell helyeznünk benne a mentés, a megnyitás és az új gombokat, hogy azok elvégezhessék a kívánt műveletet. A ''FileMenu'' tartalmazni fog egy szerkeszthető szövegmezőt is, ahová a felhasználó begépelhet egy fájlnevet. A ''Directory'' elemet a _FileMenu.qml_–ben használjuk fel, és ez majd értesít minket, ha megváltozott a könyvtár tartalma. Ezt az ''signal''-t az ''onDirectoryChanged'' handler fogja számunkra eljuttatni.

&lt;code>
In FileMenu.qml:

Directory{
 id:directory
 filename: textInput.text
 onDirectoryChanged: fileDialog.notifyRefresh()
 }
&lt;/code>

Alkalmazásunk egyszerűségét megőrizendő, a fájl dialógunk csak a szükséges fájlokat fogja megjeleníteni, amelyek .txt kiterjesztésűek.

&lt;code>
In FileDialog.qml:

signal notifyRefresh()
 onNotifyRefresh: dirView.model = directory.files
&lt;/code>

Ahogy fentebb írtuk, a ''FileDialog'' elem meg fogja jeleníteni a mappa számunkra releváns tartalmát, amelyet a files tulajdonság kiolvasásával fogunk elérni. A fájlokat egy [http://doc.qt.nokia.com/4.7/qml-gridview.html GridView] modellt használó elem fogja megjeleníteni rácsos elrendezésben egy ''delegate''-nek megfelelően. A ''delegate'' fogja lekezelni a modellünk megjelenését és a fájl dialógunk létrehoz majd egy ''grid''-et, egy rácsot, középre igazítva benne a szöveget. Egy fájlnévre kattintva egy rectangle jelenik meg, kijelölve a fájlnevet. Akárhányszor emittálásra kerül a ''notifyRefresh'' signal, a ''FileDialog'' újratölti majd a könyvtár tartalmát.

&lt;code>
In FileMenu.qml:

Button{
 id: newButton
 label: "New"
 onButtonClick:{
 textArea.textContent = ""
 }
 }
 Button{
 id: loadButton
 label: "Load"
 onButtonClick:{
 directory.filename = textInput.text
 directory.loadFile()
 textArea.textContent = directory.fileContent
 }
 }
 Button{
 id: saveButton
 label: "Save"
 onButtonClick:{
 directory.fileContent = textArea.textContent
 directory.filename = textInput.text
 directory.saveFile()
 }
 }
 Button{
 id: exitButton
 label: "Exit"
 onButtonClick:{
 Qt.quit()
 }
 }
&lt;/code>

Most már a ''FileMenu''-nk kapcsolódhat a megfelelő műveletekhez. A ''saveButton'' továbbítja majd a ''TextEdit''-ből a szöveget a ''Directory'' ''filecontent'' tulajdonságában, majd átmásolja a fájl nevét a szerkeszthető szövegmezőből. Végül pedig a gomb meghívja a ''saveFile()'' függvényt, amely elmenti a fájlunkat. A ''loadButton'' hasonló végrehajtással rendelkezik. A ''New'' gomb megnyomására pedig kitörlődik a ''TextEdit'' tartalma. Továbbá a ''EditMenu'' gombjai kapcsolónak a ''TextEdit'' függvényeihez, hogy képesek legyenek a ''copy'', ''paste'' funkció betöltésére, valamint hogy a kijelölhessük a szöveget.

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor5_filemenu.png|qml-texteditor5_filemenu]]

=== A szövegszerkesztőnk befejezése ===

p=. [[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor5_newfile.png|qml-texteditor5_newfile]]

Összegezve, a kis alkalmazásunk képes az alapvető szövegszerkesztési funkciók ellátása, így képes elmenteni, megnyitni, illetve módosítani bármilyen .txt kiterjesztésű fájlt.

Köszönjük, hogy elolvasta eme ismertetőt, reméljük hasznosnak bizonyult és remek QML alkalmazások fognak születni az itt elolvasott tudás birtokában!

Have a nice day! :)
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="http://wiki.qt.io/Template:Ambox" title="Template:Ambox">Template:Ambox</a> (<a href="http://wiki.qt.io/index.php?title=Template:Ambox&amp;action=edit" title="Template:Ambox">view source</a>) </li><li><a href="http://wiki.qt.io/Template:Cleanup" title="Template:Cleanup">Template:Cleanup</a> (<a href="http://wiki.qt.io/index.php?title=Template:Cleanup&amp;action=edit" title="Template:Cleanup">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/hu" title="Getting Started Programming with QML/hu">Getting Started Programming with QML/hu</a>.</p>
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/hu">http://wiki.qt.io/Getting_Started_Programming_with_QML/hu</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=Getting+Started+Programming+with+QML%2Fhu" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/hu"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:Getting_Started_Programming_with_QML/hu&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/hu" >Read</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="http://wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/hu&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/hu&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/Getting_Started_Programming_with_QML/hu" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/Getting_Started_Programming_with_QML/hu" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/hu&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":614});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/hu&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:58:32 GMT -->
</html>
