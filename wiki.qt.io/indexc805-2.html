<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=QObject_Class_Reference/pl&printable=yes by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 13:46:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>QObject Class Reference/pl - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,follow" />
<link rel="shortcut icon" href="favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="api251f.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="apidf90.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="load6077.css?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;printable=1&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="load8b5e.css?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;printable=1&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="load041f.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;printable=1&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"QObject_Class_Reference/pl","wgTitle":"QObject Class Reference/pl","wgCurRevisionId":19277,"wgRevisionId":19277,"wgArticleId":1407,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Articles needing cleanup"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"QObject_Class_Reference/pl","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp-qt {line-height: normal;}
.source-cpp-qt li, .source-cpp-qt pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp-qt
 * CSS class: source-cpp-qt, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp-qt.source-cpp-qt .de1, .cpp-qt.source-cpp-qt .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.cpp-qt.source-cpp-qt  {font-family:monospace;}
.cpp-qt.source-cpp-qt .imp {font-weight: bold; color: red;}
.cpp-qt.source-cpp-qt li, .cpp-qt.source-cpp-qt .li1 {font-weight: normal; vertical-align:top;}
.cpp-qt.source-cpp-qt .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp-qt.source-cpp-qt .li2 {font-weight: bold; vertical-align:top;}
.cpp-qt.source-cpp-qt .kw1 {color: #000000; font-weight:bold;}
.cpp-qt.source-cpp-qt .kw2 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .kw4 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw5 {color: #22aadd;}
.cpp-qt.source-cpp-qt .co1 {color: #888888;}
.cpp-qt.source-cpp-qt .co2 {color: #006E28;}
.cpp-qt.source-cpp-qt .coMULTI {color: #888888; font-style: italic;}
.cpp-qt.source-cpp-qt .es0 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es1 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es2 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es3 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es4 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es5 {color: #006699; font-weight: bold;}
.cpp-qt.source-cpp-qt .br0 {color: #006E28;}
.cpp-qt.source-cpp-qt .sy0 {color: #006E28;}
.cpp-qt.source-cpp-qt .st0 {color: #BF0303;}
.cpp-qt.source-cpp-qt .nu0 {color: #B08000;}
.cpp-qt.source-cpp-qt .nu6 {color: #208080;}
.cpp-qt.source-cpp-qt .nu8 {color: #208080;}
.cpp-qt.source-cpp-qt .nu12 {color: #208080;}
.cpp-qt.source-cpp-qt .nu16 {color:#800080;}
.cpp-qt.source-cpp-qt .nu17 {color:#800080;}
.cpp-qt.source-cpp-qt .nu18 {color:#800080;}
.cpp-qt.source-cpp-qt .nu19 {color:#800080;}
.cpp-qt.source-cpp-qt .me1 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me2 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .ln-xtra, .cpp-qt.source-cpp-qt li.ln-xtra, .cpp-qt.source-cpp-qt div.ln-xtra {background-color: #ffc;}
.cpp-qt.source-cpp-qt span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-QObject_Class_Reference_pl skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">QObject Class Reference/pl</span></h1>
						<div id="bodyContent">
								<div id="siteSub">From Qt Wiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table style="center; margin: -1px auto 0px;border: 1px solid rgb(127, 194, 66); border-left: 10px solid rgb(127, 194, 66); background:rgb(250,250,250); width:600px">

<tr>
<td style="padding: 0.25em 0.5em;"> <b>This article may require cleanup to meet the Qt Wiki's quality standards.</b> Reason: Auto-imported from ExpressionEngine.<br /><small>Please <b><a rel="nofollow" class="external text" href="index6b6c.html?title=QObject_Class_Reference/pl&amp;action=edit">improve this article</a></b> if you can. Remove the {{cleanup}} tag and add this page to <b><a href="Updated_pages.html" title="Updated pages">Updated pages</a></b> list after it's clean.</small>
</td></tr></table>
<p>p. Tłumaczenie z angielskiego wykonał Andrzej Kryński (akrynski_AT_wp.pl )
</p><p>Klasa QObject jest bazową klasą wszystkich obiektów Qt
<b>WŁAŚCIWOŚCI:</b>
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> objectName<span class="sy0">:</span> <span class="kw5">QString</span><span class="sy0">&lt;</span>code<span class="sy0">&gt;</span>
<span class="st0">''</span><span class="st0">'FUNKCJE PUBLICZNE:'</span><span class="st0">''</span></pre></div></div> QObject(QObject* parent=0) — konstruktor
 virtual ~QObject() — destruktor<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>bool blockSignals(bool block)
<p>bool QObject::blockSignals(bool block);
Jeśli parametr block jest prawdziwy to sygnały emitowane przez ten obiekt są blokowane
(znaczy to, że wyemitowanie jakiego kolwiek sygnału nie wywoła żadnej czynności powiązanej z tym sygnałem). Fałszywa wartość block powoduje, że żadne blokowanie nie nastąpi. Metoda zwraca ostatnio ustawioną wartość parametru block.
</p>
Należy zauważyć, iż sygnał destroyed() zostanie wyemitowany pomimo blokowania pozostałych sygnałów tego obiektu.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>const QObjectList&amp; children() const
<p>const QObjectList &amp; QObject::children () const
Zwraca listę obiektów potomnych. Klasa QObjectList jest zdefiniowana w pliku nagłówkowym &lt;QObject&gt; następująco:
typedef QList&lt;QObject*&gt; QObjectList;
Pierwszy potomek dodawany to pierwszy obiekt na liście, a potomek dodany jako ostatni to ostatni obiekt na liście. Znaczy to, że nowe potomki dodawane są do końcówki listy.
Należy zwrócić uwagę, że porządek listy ulega zmianie jeśli potomki QWidget są przesuwane w górę lub w dół przy użyciu void QWidget::raise() [slot] albo void QWidget::lower() [slot].
</p>
Widżet przesunięty w góre (raised()) staje się ostatnim obiektem na liście a przesunięty w dół – pierwszym.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>bool connect ( const QObject * sender, const char * signal, const char * method, Qt::ConnectionType type = Qt::AutoConnection ) const
<p>bool QObject::connect ( const QObject * sender, const char * signal, const char * method, Qt::ConnectionType type = Qt::AutoConnection ) const
Jest to metoda przeciążająca funkcję connect(). Wiąże sygnał od obiektu sender z daną metodą obiektu.
Jest równoznaczna z connect(sender, signal, this, method, type)
</p>
Każde wykonane połączenie emituje sygnał, tak więc zduplikowane połączenia emitują dwa sygnały. Połączenie można przerwać używając disconnect().<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>bool disconnect(const char* signal=0, const Qobject* receiver=0, const char* method=0)
<p>bool Qobject::disconnect(const char* signal = 0, consc Qobject* receiver = 0, const char* method = 0)
Ta funkcja przeciąża disconnect(). Odłącza sygnał od metody odbiorcy (slotu).
Połączenie sygnał-slot jest usuwane gdy którykolwiek z aktywnych w połączeniu obiektów jest niszczony.
</p>
Funkcja jest bezpieczna dla wątku (thread-safe)<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>bool disconnect(const char* receiver, const char* method=0)
<p>bool Qobject::disconnect(const Qobject* receiver, const char* method = 0)
Kolejne przeciążenie metody disconnect() odłączające wszystkie sygnały z tego obiektu od metod odbiorcy.
</p>
Połączenie sygnał-slot jest usuwane, gdy który kolwiek z aktywnych w połączeniu obiektów jest niszczony.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>void dumpObjectInfo()
<p>void Qobject::dumpObjectInfo()
Zwraca na wyjście debugera informację o połączeniach sygnału itp. dla danego obiektu.
</p>
Funkcja jest użyteczna do celów odpluskwiania ale nie wykonuje żadnych czynności ( jest nieaktywna) podczas kompilacji w trybie finalnym (release mode)<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>void dumpObjectTree()
<p>void Qobject:: dumpObjectTree()
Zwraca drzewo potomków danego obiektu, kierując je na wyjścia debugera (pokazuje w konsoli, zapisuje do pliku itp.).
</p>
Jak powyższa, jest aktywna tylko w trybie odpluskwiania.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>Qlist&lt;QByteArray&gt; dynamicPropertyNames() const
<p>Qlist&lt;QByteArray&gt; Qobject::dynamic propertyNames () const
</p>
Zwraca nazwy wszystkich właściwości, które były dodane do obiektu dynamicznie z użyciem setProperty().<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>virtual bool event(QEvent* e)
<p>bool Qobject::event(QEvent* e) [virtual]
Ta wirtualna metoda odbiera zdarzenia dla obiektu i powina zwracać prawdę jeśli zdarzenie e zostanie rozpoznane i obsłużone.
</p>
Funkcja event() może być nadpisana w celu odpowiedniego dostosowania zachowania obiektu.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>virtual bool eventFilter(QObiect* watched, QEvent* event)
<p>bool Qobject::eventFilter(QObject* watched, QEvent* event) [virtual]
Filtruje wydarzenia, jeśli obiekt został zainstalowany jako filtr zdarzeń dla obserwowanych obiektów.
Nadpisując tę metodę, jeśli chcemy odfiltrować zdarzenie, np. zatrzymać je do późniejszej obsługi, zwraca prawdę; w innym przypadku fałsz.
Przykład:
class MainWindow&#160;: public QmainWindow
{
public:
</p>
<pre>MainWindow();
</pre>
<p>protected:
</p>
<pre>bool eventFilter(QObject *obj, QEvent *ev);
</pre>
<p>private:
</p>
<pre>QtextEdit *textEdit;
</pre>
<p>};
MainWindow::MainWindow()
{
</p>
<pre>textEdit = new QTextEdit;
setCentralWidget(textEdit);
textEdit-&gt;installEventFilter(this);
</pre>
<p>}
bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
</p>
<pre>if(objtextEdit){
 if(event-&gt;type()QEvent::KeyPress){
QKeyEvent <b>keyEvent = static_cast&lt;QKeyEvent</b>&gt;(event);
</pre>
<p>qDebug()&lt;&lt;"Ate key press"&lt;&lt;keyEvent-&gt;key();
</p>
<pre>return true;
</pre>
<p>} else {
</p>
<pre>return false;
}
} else{
//przekaż zdarzenie do klasy rodzica
return QMainWindow::eventFilter(obj,event);
}
</pre>
<p>}
</p>
<pre>Zauważ, że w powyższym przykładzie nieobsłużone zdarzenia przekazywane są
</pre>
<p>do metody eventFilter() klasy bazowej, gdyż może się zdarzyć, iż może ona nadpisywać eventFilter() dla swych wewnętrznych celów.
</p>
Ostrzeżenie: jeśli usuniesz obiekt odbiornika w tej funkcji upewnij się, by zwrócić prawdę. W innym przypadku Qt przekaże zdarzenie do usuniętego obiektu i program może się załamać.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>T findChild (const Qstring&amp; name=QString()) const
<p>T QObject::findChild(const QString&amp; name = QString()) const
Zwraca potomka danego obiektu, który może być rzutowany na typ T i który występuje pod nazwą name, albo 0 jeśli taki obiekt nie istnieje. Opuszczenie argumentu name skutkuje dopasowaniem wszystkich nazw obiektu. Wyszukiwanie dokonuje się rekursywnie.
Jeśli w kryteriach wyszukiwania mieści się więcej niż jeden obiekt potomny to zwracany jest najbardziej bezpośredni (najbliższy) wstępny. Nie jest zdefiniowane, jeśli istnieje wielu bezpośrednich wstępnych, który z nich zostanie zwrócony. W takim przypadku należy użyć metody findChildren().
Poniższy przykład zwraca potomka typu QPushButton rodzica parentWindow o nazwie
</p>
<pre>„button1":
QPushButton <b>button = parentWidget-&gt;findChild&lt;QPushButton</b>&gt;(„button1");
</pre>
<p>Kolejny przykład zwraca QListWidget – potomka parentWIdget:
</p>
<pre>QListWidget <b>list = parentWidget-&gt;findChild&lt;QListWidget</b>&gt;();
</pre>
Uwaga: Funkcja nie jest dostępna w MSVC 6. W zastępstwie należy użyć qFindChild() jeśli jest konieczność użycia tego kompilatora.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>QList&lt;T&gt; findChildren(const QString&amp; name=QString()) const
<p>QList&lt;T&gt; QObject::findChildren(const QString &amp; name = QString()) const
Zwraca wszystkie potomki danego obiektu o nazwie name, które mogą być rzutowane na typ T albo 0 jeśli takie obiekty nie występują. Ominięcie argumentu name skutkuje dopasowaniem nazw wszystkich obiektów. Wyszukiwanie przebiega rekursywnie.
Następujący przykład pokazuje jak wyszukać listę potomnych obiektów typu QWidget pochodzących od rodzica parentWidget mającego nazwę „widgetname":
</p>
<pre>QList&lt;QWidget <b>&gt; widgets = parentWidget.findChildren&lt;QWidget</b>&gt;(„widgetname");
</pre>
<p>Kolejny przykład zwraca wszystkie obiekty typu QPushButton będące potomkami widżetu parentWidget:
</p>
<pre>Qlist&lt;QPushButton <b>&gt; allPButtons = parentWidget.findChildren&lt;QPushButton</b>&gt;()
</pre>
Uwaga: Funkcja nie jest dostępna w MSVC 6. W zastępstwie należy użyć qFindChildren() jeśli jest konieczność użycia tego kompilatora.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>QList&lt;T&gt; findChildren(const QRegExp &amp; regExp) const
<p>QList&lt;T&gt; QObject::findChildren(const QRegExp &amp; regExp) const
Jest to przeciążenie metody findChildren().
Zwraca potomki danego obiektu, które mogą być rzutowane na typ T i mają nazwy odpowiadające wyrażeniom regularnym regExp albo pustą listę jeśli takie obiekty nie występują. Wyszukiwanie przebiega rekursywnie.
</p>
Uwaga: Funkcja nie jest dostępna w MSVC 6. W zastępstwie należy użyć qFindChildren() jeśli jest konieczność użycia tego kompilatora.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>bool inherits(const char* className) const
<p>bool QObject::inherits(const char* className) const
Zwraca prawdę jeżeli obiekt jest instancją klasy dziedziczącej po className,
albo subklasą QObject, która dziedziczy po className; w innym przypadku zwraca fałsz.
A class is considered to inherit itself.
Przykład:
</p>
<pre>QTimer *timer = new QTimer; //QTimer dziedziczy po QObject
timer-&gt;inherits(„QTimer"); //zwraca prawdę
timer-&gt;inherits(„QObject"); //zwraca prawdę
timer-&gt;inherits(„QAbstractButton"); //zwraca fałsz
</pre>
<p>// QVBoxLayout dziedziczy po QObject (pośrednio-dziadek)
// i QLayoutItem (bezpośrednio-rodzic)
</p>
<pre>QVBoxLayout <b>layout = new QVBoxLayout;</b>
layout-&gt;inherits(„QObject"); //prawda
layout-&gt;inherits(„QLayoutItem");//prawda ( pomimo że QLayoutItem to nie //QObject)
</pre>
<p>Jeśli trzeba określić czy obiekt jest instancją danej klasy w celu rzutowania,
</p>
należy się zdecydować na użycie qobject_cast&lt;Type<b>&gt;(object)<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>void installEventFilter(QObject* filterObj)</b>
<p>void QObject::installEventFilter(QObject* filterObj)
Instaluje filtr zdarzeń filterObj dla danego obiektu. Np.:
</p>
<pre>monitoredObj-&gt;installEventFilter(filterObj);
</pre>
<p>Filtr zdarzeń to taki obiekt, który odbiera wszystkie zdarzenia wysyłane do (monitorowanego) obiektu. Filtr może zdarzenie zatrzymać albo przepuścić do obiektu.
Filtr zdarzeń filterObj odbiera zdarzenia za pomocą własnej funkcji eventFilter().
Funkcja ta musi zwrócić prawdę jeżeli zdarzenie ma być odfiltrowane (np. zatrzymane);
musi zwrócić fałsz w innym przypadku.
Jeśli dla jednego obiektu zainstalowano wiele filtrów zdarzeń to jako pierwszy jest aktywowany filtr zainstalowany jako ostatni.
</p>
<pre>Daną mamy klasę KeyPressEater (zjadacz klawiszy&#160;;)), która przechwytuje dane
</pre>
<p>z klawiatury dla monitorowanych obiektów:
</p>
<pre>class KeyPressEater&#160;: public QObject
</pre>
<p>{
</p>
<pre>QObject
…
</pre>
<p>protected:
</p>
<pre>bool eventFilter(QObject *obj, QEvent *event);
</pre>
<p>};
</p><p>bool KeyPressEater::eventFilter(QObject *obj, QEvent *event)
{
</p>
<pre>if(event-&gt;type() == QEvent::KeyPress) {
QKeyEvent <b>keyEvent = static_cast&lt;QKeyEvent</b>&gt;(event);
qDebug(„Ate key press&#160;%d", keyEvent-&gt;key());
return true;
} else {
//standardowa obsługa zdarzeń
return QObject::eventFilter(obj, event);
}
</pre>
<p>}
</p><p>A oto jak zainstalować filtr na dwóch widżetach:
</p>
<pre>KeyPressEater *keyPressEater = new KeyPresEater(this);
QPushButton *pushButton = new QPushButton(this);
QListView <b>listView = new QListView(this);</b>
</pre>
<pre>pushButton-&gt; installEventFilter(keyPressEater);
listView-&gt;installEventFilter(keyPressEater);
</pre>
<p>Klasa QShortcut, dla przykładu, używa tej techniki do rozpoznania użycia skrótu klawiaturowego.
Uwaga: Jeśli usunie się obiekt odbiornika w funkcji eventFilter() należy bezwzględnie zwrócić prawdę. Jeśli zwróci się fałsz Qt wyśle zdarzenie do usuniętego obiektu i program się załamie.
</p>
Należy zauważyć, iż obiekt filtrujący musi być w tym samym wątku co obiekt bieżący (this). Jeśli filterObj jest w innym wątku funkcja niczego nie wykona. Jeśli albo filterObj albo obiekt bieżący zostaną przeniesione do innego wątku po wywołaniu funkcji, filtr zdarzeń nie będzie wywołany dopóki oba obiekty powtórnie nie będą działały w tym samym wątku (nie zostanie usunięty).<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>
<p>bool isWidgetType() const
bool QObject::isWidgetType() const
</p>
<pre>Zwraca prawdę jeśli obiekt jest widżetem, w przeciwnym wypadku fałsz.
</pre>
Wywołanie tej funkcji jest jednoznaczne z wywołaniem inherits(„QWidget") z tym, że ta metoda jest wiele szybsza.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>void killTimer(int id)
<p>void QObject::killTimer(int id)
</p>
<pre>Niszczy zagar określony identyfikatorem id.
</pre>
Identyfikator zegara jest przydzielany funkcją startTimer() gdy uruchamiane jest zdarzenie zegara.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>virtual const QMetaObject<b> metaObject() const</b>
<p>const QMetaObject * QObject::metaObject () const [virtual]
</p>
<pre>Zwraca wskaźnik do meta-obiektu danego objektu.
</pre>
<p>Meta-obiekt zawiera informacje o klasie, które dziedziczy z QObject, takie jak nazwa klasy, nazwa superklasy, właściwości, sygnały i sloty. Każda subklasa QObject tworzona z użyciem makra Q_OBJECT będzie miała własny meta-obiekt.
Informacja zawarta w meta-obiekcie jest wykorzystywana przez mechanizm połączeń sygnał/slot i system właściwości. Także funkcja inherits() bierze użytek z meta-obiektu.
Jeśli nie posiadamy wskaźnika do aktualnej instancji obiektu a mimo to chcemy mieć dostęp do meta-obiektu klasy możemy użyć staticMetaObject.
Przykład:
</p><p>QObject <b>obj = new QPushButton;</b>
</p>
<pre>obj-&gt;metaObject()-&gt;className(); //zwraca napis „QPushButton"
</pre>
 QPushButton::staticMetaObject.className(); // zwraca napis „QPushButton"<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>void moveToThread(QThread* targetThread)
<p>void QObject::moveToThread(QThread * targetThread)
</p>
<pre>Zmienia przypisanie do wątku obiektu i jego potomków. Obiekt nie może być przeniesiony jeśli ma rodzica. Obsługa zdarzeń będzie kontynuowana w targetThread.
</pre>
<p>Chcąc przenieść obiekt do głównego wątku należy użyć QApplication::instance() aby otrzymać wskaźnik do bieżącej aplikacji a następnie QApplication::thread() aby otrzymać wskaźnik do wątku, w którym aplikacja jest wykonywana. Np.:
</p>
<pre>myObject-&gt;moveToThread(QApplication::instance()-&gt;thread());
</pre>
<p>Jeśli targetThread jest równy zero cała obsługa zdarzeń dla obiektu i jego potomnych zostanie zatrzymana.
Należy zauważyć, że wszystkie aktywne zegary obiektu zostaną zresetowane. Zegary zostaną najpierw zatrzymane w bieżącym wątku i uruchomione od nowa ( z tym samym interwałem) w targetThread. W rezultacie, stałe przenoszenie obiektu pomiędzy wątkami może doprowadzić do zawieszenia zdarzeń zegara na czas nieokreślony ( zapętlenia).
Zdarzenie QEvent::ThreadChange jest wysyłane do obiektu tuż przed przypisaniem przynależności do wątku. Można obsłużyć to zdarzenie aby wykonać w tym czasie jakieś specjalne działania. Należy pamiętać, że jakiekolwiek nowe zdarzenia kierowane do tego obiektu będą obsługiwane w targetThread.
</p>
Uwaga: ta funkcja nie jest bezpieczna dla wątku; bieżący wątek musi być tożsamy z bieżącym przypisaniem wątku. Innymi słowy, funkcja ta może tylko „przepychać" obiekt z bieżącego wątku do innego, nie może go stamtąd „wyciągać".<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>QString objectName() const
<pre>Jest to funkcja dostępu do właściwości objectName, tzw. „geter".
</pre>
<p>Funkcja „setera" ma postać: void setObjectName(const QString &amp; name).
</p>
Właściwość objectName przechowuje nazwę obiektu. Wykorzystywana jest np. gdy poszukujemy obiektu przez nazwę używając findChild() albo findChildren().<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>QObject* parent() const
<p>QObject * QObject::parent () const
</p>
 Zwraca wskaźnik do wstępnego obiektu ( rodzica).<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>QVariant property(const char* name) const
<p>QVariant QObject::property(const char * name) const
</p>
<pre>Zwraca wartość właściwości o nazwie name.
</pre>
<p>Jeśli obiekt nie posiada takiej właściwości zwrócony variant jest nieważny (invalid).
Informacja o wszystkich dostępnych właściwościach jest dostarczana za pośrednictwem metaObject() i dynamicPropertyNames().
void removeEventFilter(QObject* obj)
void QObject::removeEventFilter(QObject * obj)
</p>
<pre>Usuwa obiekt obj filtra zdarzeń z bieżącego obiektu. Żądanie jest ignorowane jeśli żaden filtr zdarzeń nie był instalowany.
</pre>
Wszystkie filtry zdarzeń bieżącego obiektu są automatycznie usuwane gdy jest on niszczony. Zawsze jest bezpiecznie usunąć filtr zdarzeń, nawet w trakcie jego aktywacji ( np. z funkcji eventFilter()).<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>void setObjectName(const QString &amp; name)
<p>objectName&#160;: QString
</p>
 Funkcja „setera" właściwości objectName.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>void setParent(QObject* parent)
<p>void QObject::setParent(QObject * parent)
</p>
 Czyni obiekt potomkiem obiektu parent; ustanawia rodzica.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>bool setProperty(const char* name, const QVariant &amp; value)
<p>bool QObject::setProperty( const char * name, const QVariant &amp; value)
</p>
<pre>Nadaje własności name obiektu wartość value.
</pre>
<p>Jeśli ta właściwość została w klasie zdefiniowana przy użyciu makra Q_PROPERTY to funkcja zwraca prawdę a fałsz w przeciwnym przypadku. Jeśli tej właściwości nie zdefiniowano za pomocą w.w. makra i dla tego nie jest ona wpisana w meta-obiekt,
</p>
to jest ona dodawana jako właściwość dynamiczna a funkcja zwraca fałsz.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>bool signalsBlocked() const
<p>bool QObject::signalsBlocked () const
</p>
<pre>Zwraca prawdę jeśli sygnały są blokowane, fałsz w innym wypadku.
</pre>
Standardowo sygnały nie są blokowane.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>int startTimer(int interval)
<p>int QObject::startTimet (int interval)
</p>
<pre>Uruchamia zegar i zwraca jego identyfikator albo zero jeśli zegara nie dało się uruchomić.
</pre>
<p>Zdarzenie zegara będzie wywoływane co przedział interval milisekund dopóki nie zostanie wywołana funkcja killTimer(). Ustawienie interwału na wartość równą zero skutkuje wystąpieniem zdarzenia zegara tylko po każdorazowym obsłużeniu wszystkich zdarzeń okien systemowych.
Wraz z wystąpieniem zdarzenia zegara wywoływana jest wirtualna funkcja timerEvent() z parametrem QTimerEvent. Aby przechwycić zdarzenia zegara należy ją przeciążyć.
Jeśli jest uruchomione wiele zegarów można użyć QTimerEvent::timerId() do określenia, który z nich został aktywowany.
Przykład:
</p>
<pre>class MyObject&#160;: public QObject
{
Q_OBJECT
public:
MyObject(QObject *parent = 0);
protected:
void timerEvent(QTimerEvent *event);
};
MyObject::MyObject(QObject <b>parent)</b>
: QObject(parent)
{
startTimer(50); //interwał = 50 milisekund
startTimer(1000); //interwał = 1 sekunda
startTimer(60000); //interwał = 1 minuta
}
void MyObject::timerEvent(QTimerEvent<b> event)</b>
{
qDebug() &lt;&lt; „Timer ID: " &lt;&lt; event-&gt;timerId();
}
</pre>
<pre>Dokładność zegarów QTimer zależy od systemu operacyjnego i używanego sprzętu (hardware). Większość platform obsługuje je z dokładnością do 20 milisekund; niektóre z większą. Jeśli Qt nie jest w stanie wysłać żądaną ilość zdarzeń zegara, to niektóre będą po prostu dyskretnie pominięte.
</pre>
Klasa QTimer dostarcza wysokiego poziomu interfejsu programistycznego zawierającego zegary typu single-shot a także sygnały zegara jako zamiennik zdarzeń. Dostępna jest także klasa QBasicTimer – lżejsza w obsłudze niż QTimer i mniej absorbująca niż bezpośrednie używanie identyfikatorów (ID) zegara.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>QThread<b> thread() const</b>
<p>QThread * QObject::thread () const
</p>
 Zwraca wątek, w którym obiekt jest umiejscowiony.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="st0">''</span><span class="st0">'SLOTY PUBLICZNE'</span><span class="st0">''</span></pre></div></div>void deleteLater()
<p>void QObject::deleeLater () [slot]
</p><p>Umieszcza dany obiekt w kolejce obiektów do usunięcia.
Obiekt zostanie usunięty gdy powróci kontrola do pętli zdarzeń.
Gdy pętla zdarzeń nie została osiągnięta a funkcja już została wywołana (dzieje się tak gdy wywoła się deleteLater() przed wywołaniem QCoreApplication::exec()),obiekt zostanie usunięty skoro tylko program osiągnie pętlę zdarzeń.
Działania takie jak wchodzenie/opuszczanie kolejnych pętli zdarzeń (np. związanych z obsługą zdarzeń po wywołaniu dialogu modalnego) opóźnią usunięcie obiektu;
aby został usunięty kontrola musi powrócić do pętli zdarzeń z której deleteLater() zostało wywołane.
</p>
Wielokrotne wywołanie tej funkcji nie powoduje zagrożeń; po obsłużeniu pierwszego zdarzenia z żądaniem usunięcia obiektu wszelkie inne zdarzenia związane z tym obiektem są usuwane z kolejki.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="st0">''</span><span class="st0">'SYGNAŁY'</span><span class="st0">''</span></pre></div></div>void destroyed(QObject* obj = 0)
<p>void QObject::destroyed (QObject * obj = 0 )[signal]
</p>
 Ten sygnał jest emitowany tuż przed zniszczeniem obiektu obj i nie ma możliwości zablokowania tego sygnału w żaden sposób. Wszystkie potomki obiektu zostaną zniszczone bezpośrednio po emisji sygnału.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="st0">''</span><span class="st0">'STATYCZNE SKŁADNIKI PUBLICZNE'</span><span class="st0">''</span></pre></div></div>bool connect(const QObject* sender, const char* signal, const QObject* receiver, const char* method, Qt::ConnectionType type=Qt::AutoConnection)
<p>bool QObject::connect (const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoConnection) [static]
</p>
<pre>Tworzy połączenie zadanego typu type wiążąc sygnał signal obiektu sender z metodą method w obiekcie odbiornika receiver. Zwraca prawdę jeśli połączenie się powiedzie, w przeciwnym wypadku fałsz.
</pre>
<p>Specyfikując wartości signal i method należy użyć makr SIGNAL () i SLOT(), jak w przykładzie:
</p>
<pre>QLabel *label = new QLabel;
QScrollBar *scrollBar = new QScrollBar;
QObject::connect(scrollbar, SIGNAL (valueChanged(int)),
label, SLOT (setNum(int)));
</pre>
<p>W przykładzie zapewniamy, że etykieta zawsze wyświetla aktualną wartość suwaka przewijania. Parametry sygnału i slotu nie mogą zawierać jakichkolwiek nazw zmiennych a jedynie typy. Następny przykład nie będzie pracował poprawnie i zwróci fałsz:
</p>
<pre>// ŹLE
QObject::connect(scrollBar, SIGNAL (valueChanged(int value)),
label, SLOT (setNum(int value)));
</pre>
<p>Sygnał może być także podłączony (sprzężony) z innym sygnałem:
</p>
<pre>class MyWIdget&#160;: public QWidget
{
Q_OBJECT
public:
MyWIdget();
signals:
void buttonClicked();
private:
QPushButton *myButton;
};
</pre>
<p>MyWidget::MyWidget()
</p>
<pre>{
myButton = new QPushButton(this);
connect(myButton, SIGNAL (clicked()), this, SIGNAL (buttonClicked()));
}
</pre>
W powyższym przykładzie konstruktor klasy MyWidget przekazuje sygnał od prywatnej zmiennej składowej i czyni go dostępnym pod nazwą odnoszącą się do MyWidget.<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">&#160;</pre></div></div>

<!-- 
NewPP limit report
CPU time usage: 0.596 seconds
Real time usage: 0.594 seconds
Preprocessor visited node count: 117/1000000
Preprocessor generated node count: 732/1000000
Post‐expand include size: 1312/2097152 bytes
Template argument size: 423/2097152 bytes
Highest expansion depth: 5/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key qtio_wiki:pcache:idhash:1407-0!*!0!*!*!*!* and timestamp 20151105104756 and revision id 19277
 -->
</div>								<div class="printfooter">
				Retrieved from "<a href="index1f96.html?title=QObject_Class_Reference/pl&amp;oldid=19277">http://wiki.qt.io/index.php?title=QObject_Class_Reference/pl&amp;oldid=19277</a>"				</div>
												<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_Articles_needing_cleanup.html" title="Category:Articles needing cleanup">Articles needing cleanup</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="User_10.0.113.html" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="User_talk_10.0.113.html" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="https://login.qt.io/authorize?client_id=one-qt-server-003&amp;response_type=code&amp;state=2aae5fe12b43679e&amp;scope=authorizations&amp;redirect_uri=https%3A%2F%2Fwiki.qt.io%2FSpecial%3AQtLogin%2Fcallback" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="QObject_Class_Reference/pl.html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="Talk_QObject_Class_Reference/pl.html?title=Talk:QObject_Class_Reference/pl&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="QObject_Class_Reference/pl.html" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="index6b6c.html?title=QObject_Class_Reference/pl&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="indexbd36-4.html?title=QObject_Class_Reference/pl&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(skins/common/images/wiki.png);" href="Main_Page.html"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="How_to_create_columns_in_a_QML_ListView.html" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/QObject_Class_Reference/pl.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/QObject_Class_Reference/pl.html" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-permalink"><a href="index1f96.html?title=QObject_Class_Reference/pl&amp;oldid=19277" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="indexad4b.html?title=QObject_Class_Reference/pl&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 23 August 2015, at 13:23.</li>
											<li id="footer-info-viewcount">This page has been accessed 447 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="load2f85.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;printable=1&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":193});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=QObject_Class_Reference/pl&printable=yes by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 13:46:08 GMT -->
</html>
