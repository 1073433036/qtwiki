<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=How_to_use_OpenGL_Core_Profile_with_Qt&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 11:18:33 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>View source for How to use OpenGL Core Profile with Qt - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"How_to_use_OpenGL_Core_Profile_with_Qt","wgTitle":"How to use OpenGL Core Profile with Qt","wgCurRevisionId":18223,"wgRevisionId":0,"wgArticleId":989,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"How_to_use_OpenGL_Core_Profile_with_Qt","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-How_to_use_OpenGL_Core_Profile_with_Qt skin-vector action-edit vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for How to use OpenGL Core Profile with Qt</span></h1>
						<div id="bodyContent">
								<div id="contentSub">← <a href="http://wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt" title="How to use OpenGL Core Profile with Qt">How to use OpenGL Core Profile with Qt</a></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in one of the groups: <a href="http://wiki.qt.io/index.php?title=Qt_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Qt Wiki:Users (page does not exist)">Users</a>, KnowledgeBase, QtWS.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Cleanup | reason=Article needs to be updated to Qt 5.}}
[[Category:HowTo]]
[[Category:Developing_with_Qt::General]]
[[Category:Tutorial]]
[[Category:Developing with Qt::QtOpenGL]]
== Introduction ==

Qt's support for OpenGL has now been extended to provide access to the OpenGL Core profile. When using the Core profile, all access to the legacy fixed-functionality pipeline is removed. This means that to get anything drawn on screen we have to make use of glsl shaders and vertex arrays or buffers.

The OpenGL Core profile is available when using Qt 4.8.0 or newer and OpenGL 3.1 or newer. Since Qt 4.8.0 has not yet been released you will need to get a development version of Qt. The easiest way to do this is to get it from the gitorious repository.

A complete copy of the source code for this tutorial can be obtained by doing:

&lt;code>
svn co https://svn.theharmers.co.uk/svn/codes/public/opengl/trunk opengl
cd opengl/07-core-profile
&lt;/code>

Why would we want to use the OpenGL Core profile? Well, for a start OpenGL 3.0 deprecated much of the old fixed-functionality pipeline entry points. Yes, at present these are still available when using the Compatibility profile in order to keep old applications working. However, many of these deprecated functions encourage poor or out-dated practises. For example it is much more efficient to use vertex arrays or even better vertex buffer objects to send geometry to the OpenGL pipeline than the old glVertex family of functions. The same is true for all other per-vertex attributes too (e.g. normals, texture coordinates, colours etc.).

Using the Core profile also means that the OpenGL driver has to track far fewer states per-context. Using the Core profile the developer is responsible for configuring which states their shaders care about and these are all passed in by means of a much simpler and more consistent set of functions.

The Khronos Group that oversees the OpenGL specification recommends to use the Core profile in new OpenGL applications.

Some OpenGL drivers (e.g. nVidia) may incur a small performance penalty when using the Core profile as internally this enables checks to see if a feature should be enabled or not. So to get the very best performance one method is to develop your app using only the Core profile but then when you release build and test it using the Compatibility profile. This way you can be sure that you are only using non-deprecated feature but still getting the very best performance.

'''This is known to work under Linux but Windows and Mac OSX have some issues inside of Qt for creating Core Profile contexts.'''

== Specifying the OpenGL Format ==

The first stage in being able to use the OpenGL Core profile is to prepare a QGLFormat object that describes the OpenGL context we would like to use. The following simple main function does just that:

&lt;code>
#include &lt;QApplication>
#include &lt;QGLFormat>

#include "glwidget.h"

int main( int argc, char* argv[] )
{
 QApplication a( argc, argv );

// Specify an OpenGL 3.3 format using the Core profile.
 // That is, no old-school fixed pipeline functionality
 QGLFormat glFormat;
 glFormat.setVersion( 3, 3 );
 glFormat.setProfile( QGLFormat::CoreProfile ); // Requires >=Qt-4.8.0
 glFormat.setSampleBuffers( true );

// Create a GLWidget requesting our format
 GLWidget w( glFormat );
 w.show();

return a.exec();
}
&lt;/code>

We first create a QApplication as usual. We then create a QGLFormat object and set it to OpenGL version 3.3 (the newest that my card and driver combination supports). We then request to use the Core profile and for nicer looking results we also ask to enable multi-sampling. We then pass the glFormat object through to the constructor of our custom subclass of QGLWidget, GLWidget (yes imaginative I know). Finally we show the widget and enter the event loop.

== The GLWidget Class Declaration ==

Here is the declaration of the simple class we will use to demonstrate usage of the OpenGL Core profile:

&lt;code>
#ifndef GLWIDGET_H
#define GLWIDGET_H

#include &lt;QGLWidget>

#include &lt;QGLBuffer>
#include &lt;QGLShaderProgram>

class GLWidget : public QGLWidget
{
 Q_OBJECT
public:
 GLWidget( const QGLFormat&amp; format, QWidget* parent = 0 );

protected:
 virtual void initializeGL();
 virtual void resizeGL( int w, int h );
 virtual void paintGL();

virtual void keyPressEvent( QKeyEvent* e );

private:
 bool prepareShaderProgram( const QString&amp; vertexShaderPath,
 const QString&amp; fragmentShaderPath );

QGLShaderProgram m_shader;
 QGLBuffer m_vertexBuffer;
};

#endif // GLWIDGET_H
&lt;/code>

We inherit a class from QGLWidget as normal. Note that the constructor accepts a constant reference to a QGLFormat. We override the initialiseGL(), resizeGL(), and paintGL() functions to provide our custom functionality. For convenience we also override the keyPressEvent() function so that the Escape key quits the application.

The prepareShaderProgram() function is a simple wrapper function that takes care of loading the vertex and fragment shader source, compiling the shaders, and linking them into a functional shader program. The shader program is stored in the m_shader member. The m_vertexBuffer member, as its name suggests, encapsulates and OpenGL vertex buffer that holds the vertex data for our geometry.

== The GLWidget Class Implementation ==

=== Initialisation ===

The constructor is very simple:

&lt;code>
GLWidget::GLWidget( const QGLFormat&amp; format, QWidget* parent )
 : QGLWidget( format, parent ),
 m_vertexBuffer( QGLBuffer::VertexBuffer )
{
}
&lt;/code>

We pass the requested QGLFormat object through to the QGLWidget constructor along with the usual pointer to the parent. QGLWidget tries its best to supply a QGLContext that matches our requested format. If it is unable to get an exact match it tries to create a close approximation. You can explicitly check the created OpenGL context properties by way of the QGLWidget::format() function.

We also initialise the QGLBuffer object by telling it that we wish to use it to store vertex data.

Following construction Qt calls the initialiseGL() function for us to allow us to do any OpenGL initialisation. Note that this function is only called once so only do setup that will persist for as long as this widget here.

&lt;code>
void GLWidget::initializeGL()
{
 QGLFormat glFormat = QGLWidget::format();
 if ( !glFormat.sampleBuffers() )
 qWarning() &lt;&lt; "Could not enable sample buffers";

// Set the clear color to black
 glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );

// Prepare a complete shader program…
 if ( !prepareShaderProgram( ":/simple.vert", ":/simple.frag" ) )
 return;

// We need us some vertex data. Start simple with a triangle ;-)
 float points[] = { –0.5f, –0.5f, 0.0f, 1.0f,
 0.5f, -0.5f, 0.0f, 1.0f,
 0.0f, 0.5f, 0.0f, 1.0f };
 m_vertexBuffer.create();
 m_vertexBuffer.setUsagePattern( QGLBuffer::StaticDraw );
 if ( !m_vertexBuffer.bind() )
 {
 qWarning() &lt;&lt; "Could not bind vertex buffer to the context";
 return;
 }
 m_vertexBuffer.allocate( points, 3 * 4 * sizeof( float ) );

 // Bind the shader program so that we can associate variables from
 // our application to the shaders
 if ( !m_shader.bind() )
 {
 qWarning() &lt;&lt; "Could not bind shader program to context";
 return;
 }

 // Enable the "vertex" attribute to bind it to our currently bound
 // vertex buffer.
 m_shader.setAttributeBuffer( "vertex", GL_FLOAT, 0, 4 );
 m_shader.enableAttributeArray( "vertex" );
}
&lt;/code>

We begin by checking that we do in fact have an OpenGL context with multi-sampling enabled. We then set the clear colour to black.

Next we call the prepareShaderProgram() passing in the paths of the vertex and fragment shader sources. In this case the sources are in the project's resource file. We will look at this function in more detail shortly.

The next step is to define a simple array of floats representing the vertices of our geometry- a single triangle. We then ask the QGLBuffer object to actually create the underlying OpenGL buffer object and we tell it the intended usage pattern for this buffer. In this case we will never be changing the vertices so QGLBuffer::StaticDraw is a sensible choice. The next step is to bind the buffer to the OpenGL context and insert the actual vertex data into it. The above is likely to result in the vertex data being uploaded to the dedicated graphics memory of your GPU. I say likely as the final choice of where to locate the data is left to the OpenGL driver.

Now that the OpenGL driver knows about our vertex buffer we can associate it with a variable in the shader program. As we will see shortly, the vertex shader contains an input variable called "vertex". The final part of the initialiseGL() function tells OpenGL context and driver that we wish to use the currently bound vertex buffer as the "vertex" variable in the shader, what type the buffer contains (GL_FLOAT) and how many elements are in each vertex (4 in this case).

On some setups (Windows 7, NVidia 9800 GT using drivers 285.62), it is required to bind a VAO before setting up the attributes. This behavior is part of the OpenGL 3.3 core profile. This is done by calling:
&lt;code>
 uint vao;
 glGenVertexArrays(1, &amp;vao);
 glBindVertexArray(vao);
&lt;/code>
Unfortunately, those functions are not loaded by Qt and they must be accessed using a GL loader library or by manually calling wglGetProcAddress.

Here is the prepareShaderProgram() function mentioned above:

&lt;code>
bool GLWidget::prepareShaderProgram( const QString&amp; vertexShaderPath,
 const QString&amp; fragmentShaderPath )
{
 // First we load and compile the vertex shader…
 bool result = m_shader.addShaderFromSourceFile( QGLShader::Vertex, vertexShaderPath );
 if ( !result )
 qWarning() &lt;&lt; m_shader.log();

// …now the fragment shader…
 result = m_shader.addShaderFromSourceFile( QGLShader::Fragment, fragmentShaderPath );
 if ( !result )
 qWarning() &lt;&lt; m_shader.log();

// …and finally we link them to resolve any references.
 result = m_shader.link();
 if ( !result )
 qWarning() &lt;&lt; "Could not link shader program:" &lt;&lt; m_shader.log();

return result;
}
&lt;/code>

All this function does is to load and compile the source code for the vertex and fragment shaders respectively and then link them together into a complete shader program handily encapsulated in a QGLShaderProgram. Individual shaders are analogous to compilation units in C/C++ and must go through a final linking stage to make a functional binary or in this case a shader program. The linking stage, amongst other things, ensures that the variables used to interface between the vertex and fragment shaders match up.

The final part of the OpenGL initialisation is the implementation of the resizeGL() function:

&lt;code>
void GLWidget::resizeGL( int w, int h )
{
 // Set the viewport to window dimensions
 glViewport( 0, 0, w, qMax( h, 1 ) );
}
&lt;/code>

Qt calls this function for us in response to a resizeEvent. In our case all we need to do is to adjust the OpenGL viewport transformation that is performed after the fragment shader. All we do is make sure that our viewport fills the available space.

Note that in this simple example we are not using any custom perspective or orthogonal view transformations. Instead we are relying on the default OpenGL view transformation that maps the rectangle (–1, -1)- (1, 1) to the viewport.

== Drawing ==

Now we are ready to draw something! Note that following the above initialiseGL() function we still have our shader program and vertex buffer bound to the OpenGL context so there is no need to rebind them each time we draw. This results in a trivial paintGL() function:

&lt;code>
void GLWidget::paintGL()
{
 // Clear the buffer with the current clearing color
 glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

// Draw stuff
 glDrawArrays( GL_TRIANGLES, 0, 3 );
}
&lt;/code>

All we do is clear the colour and depth buffers and tell OpenGL to draw our currently bound vertex buffer using the currently bound shader program. What could be easier? ;-)

== Miscellaneous ==
The only remaining part of the C++ implementation is the keyPressEvent() handler.

&lt;code>
void GLWidget::keyPressEvent( QKeyEvent* e )
{
 switch ( e->key() )
 {
 case Qt::Key_Escape:
 QCoreApplication::instance()->quit();
 break;

default:
 QGLWidget::keyPressEvent( e );
 }
}
&lt;/code>

This just makes the application quit when the escape key is pressed.

== The Shaders ==

=== The Vertex Shader ===

The vertex shader is simplicity itself:

&lt;code>
#version 330

in vec4 vertex;

void main( void )
{
 gl_Position = vertex;
}
&lt;/code>

It begins with a pre-processing instruction telling the glsl compiler that it requires glsl version 330 which corresponds to OpenGL 3.3. We then declare an input variable of type vec4 (a 4D vector as you might expect). This is the variable to which we linked the vertex buffer object at the end of the initialiseGL() function.

The shader entry point is the main() function. This is called once per vertex. So in this simple example it will get called 3 times, once for each vertex of our triangle, per redraw. All it does is to assign the vextex coordinates to the built-in (implicitly declared) variable gl_Position.

Following execution of the vertex shader the OpenGL drivers performs some fixed functionality such as primitive assembly and rasterisation. The output of the rasterisation stage is a stream of "fragments". Fragments are a data structure corresponding to a pixel plus some additional data. These fragments are then operated on by the fragment shader.

=== The Fragment Shader ===

The fragment shader is also simple:

&lt;code>
#version 330

layout(location = 0, index = 0) out vec4 fragColor;

void main( void )
{
 fragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
&lt;/code>

Once again we have the pre-processor instruction as in the vertex shader.

Next we declare the output variable, fragColor, that will hold the colour for this fragment that will be passed onto the last parts of the OpenGL pipeline (depth-testing, scissor-testing, blending etc.). The layout() syntax just tells OpenGL which variable in the blending equation the output of this fragment shader maps to.

The entry-point is once again the main() function which simply forces each fragment to an opaque red colour.

== Building and Running ==

The example application can be built by doing the usual:

&lt;code>
qmake &amp;&amp; make
&lt;/code>

or by using Qt-Creator. Upon running the application you should see the following on screen:
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="http://wiki.qt.io/Template:Ambox" title="Template:Ambox">Template:Ambox</a> (<a href="http://wiki.qt.io/index.php?title=Template:Ambox&amp;action=edit" title="Template:Ambox">view source</a>) </li><li><a href="http://wiki.qt.io/Template:Cleanup" title="Template:Cleanup">Template:Cleanup</a> (<a href="http://wiki.qt.io/index.php?title=Template:Cleanup&amp;action=edit" title="Template:Cleanup">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="http://wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt" title="How to use OpenGL Core Profile with Qt">How to use OpenGL Core Profile with Qt</a>.</p>
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt">http://wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=How+to+use+OpenGL+Core+Profile+with+Qt" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="http://wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt" >Read</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="http://wiki.qt.io/index.php?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/How_to_use_OpenGL_Core_Profile_with_Qt" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/How_to_use_OpenGL_Core_Profile_with_Qt" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":651});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=How_to_use_OpenGL_Core_Profile_with_Qt&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 11:18:33 GMT -->
</html>
