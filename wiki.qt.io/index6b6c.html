<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=QObject_Class_Reference/pl&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 13:46:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>View source for QObject Class Reference/pl - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"QObject_Class_Reference/pl","wgTitle":"QObject Class Reference/pl","wgCurRevisionId":19277,"wgRevisionId":0,"wgArticleId":1407,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"QObject_Class_Reference/pl","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-QObject_Class_Reference_pl skin-vector action-edit vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for QObject Class Reference/pl</span></h1>
						<div id="bodyContent">
								<div id="contentSub">← <a href="http://wiki.qt.io/QObject_Class_Reference/pl" title="QObject Class Reference/pl">QObject Class Reference/pl</a></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in one of the groups: <a href="http://wiki.qt.io/index.php?title=Qt_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Qt Wiki:Users (page does not exist)">Users</a>, KnowledgeBase, QtWS.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Cleanup | reason=Auto-imported from ExpressionEngine.}}

p. Tłumaczenie z angielskiego wykonał Andrzej Kryński (akrynski_AT_wp.pl )

Klasa QObject jest bazową klasą wszystkich obiektów Qt
'''WŁAŚCIWOŚCI:'''
&lt;code> objectName: QString&lt;code>
'''FUNKCJE PUBLICZNE:'''
&lt;/code> QObject(QObject* parent=0) — konstruktor
 virtual ~QObject() — destruktor&lt;code>

&lt;/code>bool blockSignals(bool block)
bool QObject::blockSignals(bool block);
Jeśli parametr block jest prawdziwy to sygnały emitowane przez ten obiekt są blokowane
(znaczy to, że wyemitowanie jakiego kolwiek sygnału nie wywoła żadnej czynności powiązanej z tym sygnałem). Fałszywa wartość block powoduje, że żadne blokowanie nie nastąpi. Metoda zwraca ostatnio ustawioną wartość parametru block.
Należy zauważyć, iż sygnał destroyed() zostanie wyemitowany pomimo blokowania pozostałych sygnałów tego obiektu.&lt;code>

&lt;/code>const QObjectList&amp; children() const
const QObjectList &amp; QObject::children () const
Zwraca listę obiektów potomnych. Klasa QObjectList jest zdefiniowana w pliku nagłówkowym &lt;QObject> następująco:
typedef QList&lt;QObject*> QObjectList;
Pierwszy potomek dodawany to pierwszy obiekt na liście, a potomek dodany jako ostatni to ostatni obiekt na liście. Znaczy to, że nowe potomki dodawane są do końcówki listy.
Należy zwrócić uwagę, że porządek listy ulega zmianie jeśli potomki QWidget są przesuwane w górę lub w dół przy użyciu void QWidget::raise() [slot] albo void QWidget::lower() [slot].
Widżet przesunięty w góre (raised()) staje się ostatnim obiektem na liście a przesunięty w dół – pierwszym.&lt;code>

&lt;/code>bool connect ( const QObject * sender, const char * signal, const char * method, Qt::ConnectionType type = Qt::AutoConnection ) const
bool QObject::connect ( const QObject * sender, const char * signal, const char * method, Qt::ConnectionType type = Qt::AutoConnection ) const
Jest to metoda przeciążająca funkcję connect(). Wiąże sygnał od obiektu sender z daną metodą obiektu.
Jest równoznaczna z connect(sender, signal, this, method, type)
Każde wykonane połączenie emituje sygnał, tak więc zduplikowane połączenia emitują dwa sygnały. Połączenie można przerwać używając disconnect().&lt;code>

&lt;/code>bool disconnect(const char* signal=0, const Qobject* receiver=0, const char* method=0)
bool Qobject::disconnect(const char* signal = 0, consc Qobject* receiver = 0, const char* method = 0)
Ta funkcja przeciąża disconnect(). Odłącza sygnał od metody odbiorcy (slotu).
Połączenie sygnał-slot jest usuwane gdy którykolwiek z aktywnych w połączeniu obiektów jest niszczony.
Funkcja jest bezpieczna dla wątku (thread-safe)&lt;code>

&lt;/code>bool disconnect(const char* receiver, const char* method=0)
bool Qobject::disconnect(const Qobject* receiver, const char* method = 0)
Kolejne przeciążenie metody disconnect() odłączające wszystkie sygnały z tego obiektu od metod odbiorcy.
Połączenie sygnał-slot jest usuwane, gdy który kolwiek z aktywnych w połączeniu obiektów jest niszczony.&lt;code>

&lt;/code>void dumpObjectInfo()
void Qobject::dumpObjectInfo()
Zwraca na wyjście debugera informację o połączeniach sygnału itp. dla danego obiektu.
Funkcja jest użyteczna do celów odpluskwiania ale nie wykonuje żadnych czynności ( jest nieaktywna) podczas kompilacji w trybie finalnym (release mode)&lt;code>

&lt;/code>void dumpObjectTree()
void Qobject:: dumpObjectTree()
Zwraca drzewo potomków danego obiektu, kierując je na wyjścia debugera (pokazuje w konsoli, zapisuje do pliku itp.).
Jak powyższa, jest aktywna tylko w trybie odpluskwiania.&lt;code>

&lt;/code>Qlist&lt;QByteArray> dynamicPropertyNames() const
Qlist&lt;QByteArray> Qobject::dynamic propertyNames () const
Zwraca nazwy wszystkich właściwości, które były dodane do obiektu dynamicznie z użyciem setProperty().&lt;code>

&lt;/code>virtual bool event(QEvent* e)
bool Qobject::event(QEvent* e) [virtual]
Ta wirtualna metoda odbiera zdarzenia dla obiektu i powina zwracać prawdę jeśli zdarzenie e zostanie rozpoznane i obsłużone.
Funkcja event() może być nadpisana w celu odpowiedniego dostosowania zachowania obiektu.&lt;code>

&lt;/code>virtual bool eventFilter(QObiect* watched, QEvent* event)
bool Qobject::eventFilter(QObject* watched, QEvent* event) [virtual]
Filtruje wydarzenia, jeśli obiekt został zainstalowany jako filtr zdarzeń dla obserwowanych obiektów.
Nadpisując tę metodę, jeśli chcemy odfiltrować zdarzenie, np. zatrzymać je do późniejszej obsługi, zwraca prawdę; w innym przypadku fałsz.
Przykład:
class MainWindow : public QmainWindow
{
public:
 MainWindow();
protected:
 bool eventFilter(QObject *obj, QEvent *ev);
private:
 QtextEdit *textEdit;
};
MainWindow::MainWindow()
{
 textEdit = new QTextEdit;
 setCentralWidget(textEdit);
 textEdit->installEventFilter(this);
}
bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
 if(objtextEdit){
  if(event->type()QEvent::KeyPress){
 QKeyEvent '''keyEvent = static_cast&lt;QKeyEvent'''>(event);
qDebug()&lt;&lt;"Ate key press"&lt;&lt;keyEvent->key();
 return true;
} else {
 return false;
 }
 } else{
 //przekaż zdarzenie do klasy rodzica
 return QMainWindow::eventFilter(obj,event);
 }
}
 Zauważ, że w powyższym przykładzie nieobsłużone zdarzenia przekazywane są
do metody eventFilter() klasy bazowej, gdyż może się zdarzyć, iż może ona nadpisywać eventFilter() dla swych wewnętrznych celów.
Ostrzeżenie: jeśli usuniesz obiekt odbiornika w tej funkcji upewnij się, by zwrócić prawdę. W innym przypadku Qt przekaże zdarzenie do usuniętego obiektu i program może się załamać.&lt;code>

&lt;/code>T findChild (const Qstring&amp; name=QString()) const
T QObject::findChild(const QString&amp; name = QString()) const
Zwraca potomka danego obiektu, który może być rzutowany na typ T i który występuje pod nazwą name, albo 0 jeśli taki obiekt nie istnieje. Opuszczenie argumentu name skutkuje dopasowaniem wszystkich nazw obiektu. Wyszukiwanie dokonuje się rekursywnie.
Jeśli w kryteriach wyszukiwania mieści się więcej niż jeden obiekt potomny to zwracany jest najbardziej bezpośredni (najbliższy) wstępny. Nie jest zdefiniowane, jeśli istnieje wielu bezpośrednich wstępnych, który z nich zostanie zwrócony. W takim przypadku należy użyć metody findChildren().
Poniższy przykład zwraca potomka typu QPushButton rodzica parentWindow o nazwie
 „button1":
 QPushButton '''button = parentWidget->findChild&lt;QPushButton'''>(„button1");
Kolejny przykład zwraca QListWidget – potomka parentWIdget:
 QListWidget '''list = parentWidget->findChild&lt;QListWidget'''>();

Uwaga: Funkcja nie jest dostępna w MSVC 6. W zastępstwie należy użyć qFindChild() jeśli jest konieczność użycia tego kompilatora.&lt;code>

&lt;/code>QList&lt;T> findChildren(const QString&amp; name=QString()) const
QList&lt;T> QObject::findChildren(const QString &amp; name = QString()) const
Zwraca wszystkie potomki danego obiektu o nazwie name, które mogą być rzutowane na typ T albo 0 jeśli takie obiekty nie występują. Ominięcie argumentu name skutkuje dopasowaniem nazw wszystkich obiektów. Wyszukiwanie przebiega rekursywnie.
Następujący przykład pokazuje jak wyszukać listę potomnych obiektów typu QWidget pochodzących od rodzica parentWidget mającego nazwę „widgetname":
 QList&lt;QWidget '''> widgets = parentWidget.findChildren&lt;QWidget'''>(„widgetname");
Kolejny przykład zwraca wszystkie obiekty typu QPushButton będące potomkami widżetu parentWidget:
 Qlist&lt;QPushButton '''> allPButtons = parentWidget.findChildren&lt;QPushButton'''>()
Uwaga: Funkcja nie jest dostępna w MSVC 6. W zastępstwie należy użyć qFindChildren() jeśli jest konieczność użycia tego kompilatora.&lt;code>

&lt;/code>QList&lt;T> findChildren(const QRegExp &amp; regExp) const
QList&lt;T> QObject::findChildren(const QRegExp &amp; regExp) const
Jest to przeciążenie metody findChildren().
Zwraca potomki danego obiektu, które mogą być rzutowane na typ T i mają nazwy odpowiadające wyrażeniom regularnym regExp albo pustą listę jeśli takie obiekty nie występują. Wyszukiwanie przebiega rekursywnie.
Uwaga: Funkcja nie jest dostępna w MSVC 6. W zastępstwie należy użyć qFindChildren() jeśli jest konieczność użycia tego kompilatora.&lt;code>

&lt;/code>bool inherits(const char* className) const
bool QObject::inherits(const char* className) const
Zwraca prawdę jeżeli obiekt jest instancją klasy dziedziczącej po className,
albo subklasą QObject, która dziedziczy po className; w innym przypadku zwraca fałsz.
A class is considered to inherit itself.
Przykład:
 QTimer *timer = new QTimer; //QTimer dziedziczy po QObject
 timer->inherits(„QTimer"); //zwraca prawdę
 timer->inherits(„QObject"); //zwraca prawdę
 timer->inherits(„QAbstractButton"); //zwraca fałsz

// QVBoxLayout dziedziczy po QObject (pośrednio-dziadek)
// i QLayoutItem (bezpośrednio-rodzic)
 QVBoxLayout '''layout = new QVBoxLayout;
 layout->inherits(„QObject"); //prawda
 layout->inherits(„QLayoutItem");//prawda ( pomimo że QLayoutItem to nie //QObject)

Jeśli trzeba określić czy obiekt jest instancją danej klasy w celu rzutowania,
należy się zdecydować na użycie qobject_cast&lt;Type'''>(object)&lt;code>

&lt;/code>void installEventFilter(QObject* filterObj)
void QObject::installEventFilter(QObject* filterObj)
Instaluje filtr zdarzeń filterObj dla danego obiektu. Np.:
 monitoredObj->installEventFilter(filterObj);
Filtr zdarzeń to taki obiekt, który odbiera wszystkie zdarzenia wysyłane do (monitorowanego) obiektu. Filtr może zdarzenie zatrzymać albo przepuścić do obiektu.
Filtr zdarzeń filterObj odbiera zdarzenia za pomocą własnej funkcji eventFilter().
Funkcja ta musi zwrócić prawdę jeżeli zdarzenie ma być odfiltrowane (np. zatrzymane);
musi zwrócić fałsz w innym przypadku.
Jeśli dla jednego obiektu zainstalowano wiele filtrów zdarzeń to jako pierwszy jest aktywowany filtr zainstalowany jako ostatni.
 Daną mamy klasę KeyPressEater (zjadacz klawiszy ;)), która przechwytuje dane
z klawiatury dla monitorowanych obiektów:
 class KeyPressEater : public QObject
{
 QObject
 …
protected:
 bool eventFilter(QObject *obj, QEvent *event);
};

bool KeyPressEater::eventFilter(QObject *obj, QEvent *event)
{
 if(event->type() == QEvent::KeyPress) {
 QKeyEvent '''keyEvent = static_cast&lt;QKeyEvent'''>(event);
 qDebug(„Ate key press %d", keyEvent->key());
 return true;
 } else {
 //standardowa obsługa zdarzeń
 return QObject::eventFilter(obj, event);
 }
}

A oto jak zainstalować filtr na dwóch widżetach:
 KeyPressEater *keyPressEater = new KeyPresEater(this);
 QPushButton *pushButton = new QPushButton(this);
 QListView '''listView = new QListView(this);

 pushButton-> installEventFilter(keyPressEater);
 listView->installEventFilter(keyPressEater);

Klasa QShortcut, dla przykładu, używa tej techniki do rozpoznania użycia skrótu klawiaturowego.
Uwaga: Jeśli usunie się obiekt odbiornika w funkcji eventFilter() należy bezwzględnie zwrócić prawdę. Jeśli zwróci się fałsz Qt wyśle zdarzenie do usuniętego obiektu i program się załamie.
Należy zauważyć, iż obiekt filtrujący musi być w tym samym wątku co obiekt bieżący (this). Jeśli filterObj jest w innym wątku funkcja niczego nie wykona. Jeśli albo filterObj albo obiekt bieżący zostaną przeniesione do innego wątku po wywołaniu funkcji, filtr zdarzeń nie będzie wywołany dopóki oba obiekty powtórnie nie będą działały w tym samym wątku (nie zostanie usunięty).&lt;code>
&lt;/code>
bool isWidgetType() const
bool QObject::isWidgetType() const
 Zwraca prawdę jeśli obiekt jest widżetem, w przeciwnym wypadku fałsz.
Wywołanie tej funkcji jest jednoznaczne z wywołaniem inherits(„QWidget") z tym, że ta metoda jest wiele szybsza.&lt;code>

&lt;/code>void killTimer(int id)
void QObject::killTimer(int id)
 Niszczy zagar określony identyfikatorem id.
Identyfikator zegara jest przydzielany funkcją startTimer() gdy uruchamiane jest zdarzenie zegara.&lt;code>

&lt;/code>virtual const QMetaObject''' metaObject() const
const QMetaObject * QObject::metaObject () const [virtual]
 Zwraca wskaźnik do meta-obiektu danego objektu.
Meta-obiekt zawiera informacje o klasie, które dziedziczy z QObject, takie jak nazwa klasy, nazwa superklasy, właściwości, sygnały i sloty. Każda subklasa QObject tworzona z użyciem makra Q_OBJECT będzie miała własny meta-obiekt.
Informacja zawarta w meta-obiekcie jest wykorzystywana przez mechanizm połączeń sygnał/slot i system właściwości. Także funkcja inherits() bierze użytek z meta-obiektu.
Jeśli nie posiadamy wskaźnika do aktualnej instancji obiektu a mimo to chcemy mieć dostęp do meta-obiektu klasy możemy użyć staticMetaObject.
Przykład:

QObject '''obj = new QPushButton;
 obj->metaObject()->className(); //zwraca napis „QPushButton"

 QPushButton::staticMetaObject.className(); // zwraca napis „QPushButton"&lt;code>

&lt;/code>void moveToThread(QThread* targetThread)
void QObject::moveToThread(QThread * targetThread)
 Zmienia przypisanie do wątku obiektu i jego potomków. Obiekt nie może być przeniesiony jeśli ma rodzica. Obsługa zdarzeń będzie kontynuowana w targetThread.
Chcąc przenieść obiekt do głównego wątku należy użyć QApplication::instance() aby otrzymać wskaźnik do bieżącej aplikacji a następnie QApplication::thread() aby otrzymać wskaźnik do wątku, w którym aplikacja jest wykonywana. Np.:
 myObject->moveToThread(QApplication::instance()->thread());
Jeśli targetThread jest równy zero cała obsługa zdarzeń dla obiektu i jego potomnych zostanie zatrzymana.
Należy zauważyć, że wszystkie aktywne zegary obiektu zostaną zresetowane. Zegary zostaną najpierw zatrzymane w bieżącym wątku i uruchomione od nowa ( z tym samym interwałem) w targetThread. W rezultacie, stałe przenoszenie obiektu pomiędzy wątkami może doprowadzić do zawieszenia zdarzeń zegara na czas nieokreślony ( zapętlenia).
Zdarzenie QEvent::ThreadChange jest wysyłane do obiektu tuż przed przypisaniem przynależności do wątku. Można obsłużyć to zdarzenie aby wykonać w tym czasie jakieś specjalne działania. Należy pamiętać, że jakiekolwiek nowe zdarzenia kierowane do tego obiektu będą obsługiwane w targetThread.
Uwaga: ta funkcja nie jest bezpieczna dla wątku; bieżący wątek musi być tożsamy z bieżącym przypisaniem wątku. Innymi słowy, funkcja ta może tylko „przepychać" obiekt z bieżącego wątku do innego, nie może go stamtąd „wyciągać".&lt;code>

&lt;/code>QString objectName() const
 Jest to funkcja dostępu do właściwości objectName, tzw. „geter".
Funkcja „setera" ma postać: void setObjectName(const QString &amp; name).
Właściwość objectName przechowuje nazwę obiektu. Wykorzystywana jest np. gdy poszukujemy obiektu przez nazwę używając findChild() albo findChildren().&lt;code>

&lt;/code>QObject* parent() const
QObject * QObject::parent () const
 Zwraca wskaźnik do wstępnego obiektu ( rodzica).&lt;code>

&lt;/code>QVariant property(const char* name) const
QVariant QObject::property(const char * name) const
 Zwraca wartość właściwości o nazwie name.
Jeśli obiekt nie posiada takiej właściwości zwrócony variant jest nieważny (invalid).
Informacja o wszystkich dostępnych właściwościach jest dostarczana za pośrednictwem metaObject() i dynamicPropertyNames().
void removeEventFilter(QObject* obj)
void QObject::removeEventFilter(QObject * obj)
 Usuwa obiekt obj filtra zdarzeń z bieżącego obiektu. Żądanie jest ignorowane jeśli żaden filtr zdarzeń nie był instalowany.
Wszystkie filtry zdarzeń bieżącego obiektu są automatycznie usuwane gdy jest on niszczony. Zawsze jest bezpiecznie usunąć filtr zdarzeń, nawet w trakcie jego aktywacji ( np. z funkcji eventFilter()).&lt;code>

&lt;/code>void setObjectName(const QString &amp; name)
objectName : QString
 Funkcja „setera" właściwości objectName.&lt;code>

&lt;/code>void setParent(QObject* parent)
void QObject::setParent(QObject * parent)
 Czyni obiekt potomkiem obiektu parent; ustanawia rodzica.&lt;code>

&lt;/code>bool setProperty(const char* name, const QVariant &amp; value)
bool QObject::setProperty( const char * name, const QVariant &amp; value)
 Nadaje własności name obiektu wartość value.
Jeśli ta właściwość została w klasie zdefiniowana przy użyciu makra Q_PROPERTY to funkcja zwraca prawdę a fałsz w przeciwnym przypadku. Jeśli tej właściwości nie zdefiniowano za pomocą w.w. makra i dla tego nie jest ona wpisana w meta-obiekt,
to jest ona dodawana jako właściwość dynamiczna a funkcja zwraca fałsz.&lt;code>

&lt;/code>bool signalsBlocked() const
bool QObject::signalsBlocked () const
 Zwraca prawdę jeśli sygnały są blokowane, fałsz w innym wypadku.
Standardowo sygnały nie są blokowane.&lt;code>

&lt;/code>int startTimer(int interval)
int QObject::startTimet (int interval)
 Uruchamia zegar i zwraca jego identyfikator albo zero jeśli zegara nie dało się uruchomić.
Zdarzenie zegara będzie wywoływane co przedział interval milisekund dopóki nie zostanie wywołana funkcja killTimer(). Ustawienie interwału na wartość równą zero skutkuje wystąpieniem zdarzenia zegara tylko po każdorazowym obsłużeniu wszystkich zdarzeń okien systemowych.
Wraz z wystąpieniem zdarzenia zegara wywoływana jest wirtualna funkcja timerEvent() z parametrem QTimerEvent. Aby przechwycić zdarzenia zegara należy ją przeciążyć.
Jeśli jest uruchomione wiele zegarów można użyć QTimerEvent::timerId() do określenia, który z nich został aktywowany.
Przykład:
 class MyObject : public QObject
 {
 Q_OBJECT
 public:
 MyObject(QObject *parent = 0);
 protected:
 void timerEvent(QTimerEvent *event);
 };
 MyObject::MyObject(QObject '''parent)
 : QObject(parent)
 {
 startTimer(50); //interwał = 50 milisekund
 startTimer(1000); //interwał = 1 sekunda
 startTimer(60000); //interwał = 1 minuta
 }
 void MyObject::timerEvent(QTimerEvent''' event)
 {
 qDebug() &lt;&lt; „Timer ID: " &lt;&lt; event->timerId();
 }

 Dokładność zegarów QTimer zależy od systemu operacyjnego i używanego sprzętu (hardware). Większość platform obsługuje je z dokładnością do 20 milisekund; niektóre z większą. Jeśli Qt nie jest w stanie wysłać żądaną ilość zdarzeń zegara, to niektóre będą po prostu dyskretnie pominięte.
Klasa QTimer dostarcza wysokiego poziomu interfejsu programistycznego zawierającego zegary typu single-shot a także sygnały zegara jako zamiennik zdarzeń. Dostępna jest także klasa QBasicTimer – lżejsza w obsłudze niż QTimer i mniej absorbująca niż bezpośrednie używanie identyfikatorów (ID) zegara.&lt;code>

&lt;/code>QThread''' thread() const
QThread * QObject::thread () const
 Zwraca wątek, w którym obiekt jest umiejscowiony.&lt;code>

'''SLOTY PUBLICZNE'''

&lt;/code>void deleteLater()
void QObject::deleeLater () [slot]

Umieszcza dany obiekt w kolejce obiektów do usunięcia.
Obiekt zostanie usunięty gdy powróci kontrola do pętli zdarzeń.
Gdy pętla zdarzeń nie została osiągnięta a funkcja już została wywołana (dzieje się tak gdy wywoła się deleteLater() przed wywołaniem QCoreApplication::exec()),obiekt zostanie usunięty skoro tylko program osiągnie pętlę zdarzeń.
Działania takie jak wchodzenie/opuszczanie kolejnych pętli zdarzeń (np. związanych z obsługą zdarzeń po wywołaniu dialogu modalnego) opóźnią usunięcie obiektu;
aby został usunięty kontrola musi powrócić do pętli zdarzeń z której deleteLater() zostało wywołane.
Wielokrotne wywołanie tej funkcji nie powoduje zagrożeń; po obsłużeniu pierwszego zdarzenia z żądaniem usunięcia obiektu wszelkie inne zdarzenia związane z tym obiektem są usuwane z kolejki.&lt;code>

'''SYGNAŁY'''

&lt;/code>void destroyed(QObject* obj = 0)
void QObject::destroyed (QObject * obj = 0 )[signal]
 Ten sygnał jest emitowany tuż przed zniszczeniem obiektu obj i nie ma możliwości zablokowania tego sygnału w żaden sposób. Wszystkie potomki obiektu zostaną zniszczone bezpośrednio po emisji sygnału.&lt;code>

'''STATYCZNE SKŁADNIKI PUBLICZNE'''

&lt;/code>bool connect(const QObject* sender, const char* signal, const QObject* receiver, const char* method, Qt::ConnectionType type=Qt::AutoConnection)
bool QObject::connect (const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoConnection) [static]
 Tworzy połączenie zadanego typu type wiążąc sygnał signal obiektu sender z metodą method w obiekcie odbiornika receiver. Zwraca prawdę jeśli połączenie się powiedzie, w przeciwnym wypadku fałsz.
Specyfikując wartości signal i method należy użyć makr SIGNAL () i SLOT(), jak w przykładzie:
 QLabel *label = new QLabel;
 QScrollBar *scrollBar = new QScrollBar;
 QObject::connect(scrollbar, SIGNAL (valueChanged(int)),
 label, SLOT (setNum(int)));
W przykładzie zapewniamy, że etykieta zawsze wyświetla aktualną wartość suwaka przewijania. Parametry sygnału i slotu nie mogą zawierać jakichkolwiek nazw zmiennych a jedynie typy. Następny przykład nie będzie pracował poprawnie i zwróci fałsz:
 // ŹLE
 QObject::connect(scrollBar, SIGNAL (valueChanged(int value)),
 label, SLOT (setNum(int value)));

Sygnał może być także podłączony (sprzężony) z innym sygnałem:
 class MyWIdget : public QWidget
 {
 Q_OBJECT
 public:
 MyWIdget();
 signals:
 void buttonClicked();
 private:
 QPushButton *myButton;
 };

MyWidget::MyWidget()
 {
 myButton = new QPushButton(this);
 connect(myButton, SIGNAL (clicked()), this, SIGNAL (buttonClicked()));
 }
W powyższym przykładzie konstruktor klasy MyWidget przekazuje sygnał od prywatnej zmiennej składowej i czyni go dostępnym pod nazwą odnoszącą się do MyWidget.&lt;code>
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="http://wiki.qt.io/Template:Ambox" title="Template:Ambox">Template:Ambox</a> (<a href="http://wiki.qt.io/index.php?title=Template:Ambox&amp;action=edit" title="Template:Ambox">view source</a>) </li><li><a href="http://wiki.qt.io/Template:Cleanup" title="Template:Cleanup">Template:Cleanup</a> (<a href="http://wiki.qt.io/index.php?title=Template:Cleanup&amp;action=edit" title="Template:Cleanup">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="http://wiki.qt.io/QObject_Class_Reference/pl" title="QObject Class Reference/pl">QObject Class Reference/pl</a>.</p>
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/QObject_Class_Reference/pl">http://wiki.qt.io/QObject_Class_Reference/pl</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=QObject+Class+Reference%2Fpl" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/QObject_Class_Reference/pl"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:QObject_Class_Reference/pl&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="http://wiki.qt.io/QObject_Class_Reference/pl" >Read</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="http://wiki.qt.io/index.php?title=QObject_Class_Reference/pl&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=QObject_Class_Reference/pl&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/QObject_Class_Reference/pl" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/QObject_Class_Reference/pl" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=QObject_Class_Reference/pl&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":952});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=QObject_Class_Reference/pl&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 13:46:08 GMT -->
</html>
