<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=QtWhitepaper&oldid=19205 by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 12:29:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>QtWhitepaper - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"QtWhitepaper","wgTitle":"QtWhitepaper","wgCurRevisionId":19205,"wgRevisionId":19205,"wgArticleId":1882,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Articles needing cleanup","Pages with broken file links"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"QtWhitepaper","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp-qt {line-height: normal;}
.source-cpp-qt li, .source-cpp-qt pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp-qt
 * CSS class: source-cpp-qt, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp-qt.source-cpp-qt .de1, .cpp-qt.source-cpp-qt .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.cpp-qt.source-cpp-qt  {font-family:monospace;}
.cpp-qt.source-cpp-qt .imp {font-weight: bold; color: red;}
.cpp-qt.source-cpp-qt li, .cpp-qt.source-cpp-qt .li1 {font-weight: normal; vertical-align:top;}
.cpp-qt.source-cpp-qt .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp-qt.source-cpp-qt .li2 {font-weight: bold; vertical-align:top;}
.cpp-qt.source-cpp-qt .kw1 {color: #000000; font-weight:bold;}
.cpp-qt.source-cpp-qt .kw2 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .kw4 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw5 {color: #22aadd;}
.cpp-qt.source-cpp-qt .co1 {color: #888888;}
.cpp-qt.source-cpp-qt .co2 {color: #006E28;}
.cpp-qt.source-cpp-qt .coMULTI {color: #888888; font-style: italic;}
.cpp-qt.source-cpp-qt .es0 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es1 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es2 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es3 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es4 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es5 {color: #006699; font-weight: bold;}
.cpp-qt.source-cpp-qt .br0 {color: #006E28;}
.cpp-qt.source-cpp-qt .sy0 {color: #006E28;}
.cpp-qt.source-cpp-qt .st0 {color: #BF0303;}
.cpp-qt.source-cpp-qt .nu0 {color: #B08000;}
.cpp-qt.source-cpp-qt .nu6 {color: #208080;}
.cpp-qt.source-cpp-qt .nu8 {color: #208080;}
.cpp-qt.source-cpp-qt .nu12 {color: #208080;}
.cpp-qt.source-cpp-qt .nu16 {color:#800080;}
.cpp-qt.source-cpp-qt .nu17 {color:#800080;}
.cpp-qt.source-cpp-qt .nu18 {color:#800080;}
.cpp-qt.source-cpp-qt .nu19 {color:#800080;}
.cpp-qt.source-cpp-qt .me1 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me2 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .ln-xtra, .cpp-qt.source-cpp-qt li.ln-xtra, .cpp-qt.source-cpp-qt div.ln-xtra {background-color: #ffc;}
.cpp-qt.source-cpp-qt span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-QtWhitepaper skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">QtWhitepaper</span></h1>
						<div id="bodyContent">
								<div id="siteSub">From Qt Wiki</div>
								<div id="contentSub"><div id="mw-revision-info">Revision as of 13:05, 23 August 2015 by <a href="http://wiki.qt.io/index.php?title=User:JKSH&amp;action=edit&amp;redlink=1" class="new mw-userlink" title="User:JKSH (page does not exist)">JKSH</a>  <span class="mw-usertoollinks">(<a href="http://wiki.qt.io/User_talk:JKSH" title="User talk:JKSH">Talk</a> | <a href="http://wiki.qt.io/Special:Contributions/JKSH" title="Special:Contributions/JKSH">contribs</a>)</span></div><br />
				<div id="mw-revision-nav">(<a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;diff=prev&amp;oldid=19205" title="QtWhitepaper">diff</a>) <a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;direction=prev&amp;oldid=19205" title="QtWhitepaper">← Older revision</a> | Latest revision (diff) | Newer revision → (diff)</div></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table style="center; margin: -1px auto 0px;border: 1px solid rgb(127, 194, 66); border-left: 10px solid rgb(127, 194, 66); background:rgb(250,250,250); width:600px">

<tr>
<td style="padding: 0.25em 0.5em;"> <b>This article may require cleanup to meet the Qt Wiki's quality standards.</b> Reason: Auto-imported from ExpressionEngine.<br /><small>Please <b><a rel="nofollow" class="external text" href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;action=edit">improve this article</a></b> if you can. Remove the {{cleanup}} tag and add this page to <b><a href="http://wiki.qt.io/Updated_pages" title="Updated pages">Updated pages</a></b> list after it's clean.</small>
</td></tr></table>
<p><b>English</b> <a href="http://wiki.qt.io/QtWhitepaper_Korean" title="QtWhitepaper Korean" class="mw-redirect">한국어</a> <a rel="nofollow" class="external text" href="http://qt-devnet.developpez.com/tutoriels/qt/livre-blanc/">French</a>
</p><p><br />
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Qt_Whitepaper"><span class="tocnumber">1</span> <span class="toctext">Qt Whitepaper</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Introduction"><span class="tocnumber">2</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Executive_Summary"><span class="tocnumber">2.1</span> <span class="toctext">Executive Summary</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Graphical_User_Interfaces"><span class="tocnumber">3</span> <span class="toctext">Graphical User Interfaces</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Widgets"><span class="tocnumber">3.1</span> <span class="toctext">Widgets</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Layouts"><span class="tocnumber">3.2</span> <span class="toctext">Layouts</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Signals_and_Slots"><span class="tocnumber">3.3</span> <span class="toctext">Signals and Slots</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Application_Features"><span class="tocnumber">4</span> <span class="toctext">Application Features</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#Main_Window_Features"><span class="tocnumber">4.1</span> <span class="toctext">Main Window Features</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Actions"><span class="tocnumber">4.2</span> <span class="toctext">Actions</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Dialogs_and_Wizards"><span class="tocnumber">4.3</span> <span class="toctext">Dialogs and Wizards</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Interactive_Help"><span class="tocnumber">4.4</span> <span class="toctext">Interactive Help</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Settings"><span class="tocnumber">4.5</span> <span class="toctext">Settings</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Multithreading_and_Concurrent_Programming"><span class="tocnumber">4.6</span> <span class="toctext">Multithreading and Concurrent Programming</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Desktop_Integration"><span class="tocnumber">4.7</span> <span class="toctext">Desktop Integration</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="#Qt_Designer"><span class="tocnumber">5</span> <span class="toctext">Qt Designer</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Working_with_Qt_Designer"><span class="tocnumber">5.1</span> <span class="toctext">Working with Qt Designer</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Extending_Qt_Designer"><span class="tocnumber">5.2</span> <span class="toctext">Extending Qt Designer</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-26"><a href="#Graphics_and_Multimedia"><span class="tocnumber">6</span> <span class="toctext">Graphics and Multimedia</span></a>
<ul>
<li class="toclevel-2 tocsection-27"><a href="#Painting"><span class="tocnumber">6.1</span> <span class="toctext">Painting</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#Images"><span class="tocnumber">6.2</span> <span class="toctext">Images</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#Paint_Devices_and_Printing"><span class="tocnumber">6.3</span> <span class="toctext">Paint Devices and Printing</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#Graphics_View_Framework"><span class="tocnumber">6.4</span> <span class="toctext">Graphics View Framework</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Scalable_Vector_Graphics_.28SVG.29"><span class="tocnumber">6.5</span> <span class="toctext">Scalable Vector Graphics (SVG)</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#3D_Graphics"><span class="tocnumber">6.6</span> <span class="toctext">3D Graphics</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Multimedia"><span class="tocnumber">6.7</span> <span class="toctext">Multimedia</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="#Item_Views"><span class="tocnumber">7</span> <span class="toctext">Item Views</span></a>
<ul>
<li class="toclevel-2 tocsection-37"><a href="#Standard_Item_Views"><span class="tocnumber">7.1</span> <span class="toctext">Standard Item Views</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#Qt.27s_Model.2FView_Framework"><span class="tocnumber">7.2</span> <span class="toctext">Qt's Model/View Framework</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-40"><a href="#Text_Handling"><span class="tocnumber">8</span> <span class="toctext">Text Handling</span></a>
<ul>
<li class="toclevel-2 tocsection-41"><a href="#Rich_Text_Editing"><span class="tocnumber">8.1</span> <span class="toctext">Rich Text Editing</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#Customization.2C_Printing_and_Document_Export"><span class="tocnumber">8.2</span> <span class="toctext">Customization, Printing and Document Export</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-44"><a href="#Web_Integration_with_WebKit"><span class="tocnumber">9</span> <span class="toctext">Web Integration with WebKit</span></a>
<ul>
<li class="toclevel-2 tocsection-45"><a href="#Native_Application_Integration"><span class="tocnumber">9.1</span> <span class="toctext">Native Application Integration</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="#DOM_Access_API"><span class="tocnumber">9.2</span> <span class="toctext">DOM Access API</span></a></li>
<li class="toclevel-2 tocsection-47"><a href="#Netscape_Plugin_Support"><span class="tocnumber">9.3</span> <span class="toctext">Netscape Plugin Support</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-49"><a href="#Databases"><span class="tocnumber">10</span> <span class="toctext">Databases</span></a>
<ul>
<li class="toclevel-2 tocsection-50"><a href="#Executing_SQL_Commands"><span class="tocnumber">10.1</span> <span class="toctext">Executing SQL Commands</span></a></li>
<li class="toclevel-2 tocsection-51"><a href="#SQL_Models"><span class="tocnumber">10.2</span> <span class="toctext">SQL Models</span></a></li>
<li class="toclevel-2 tocsection-52"><a href="#Data-Aware_Widgets"><span class="tocnumber">10.3</span> <span class="toctext">Data-Aware Widgets</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-54"><a href="#Internationalization"><span class="tocnumber">11</span> <span class="toctext">Internationalization</span></a>
<ul>
<li class="toclevel-2 tocsection-55"><a href="#Text_Entry_and_Rendering"><span class="tocnumber">11.1</span> <span class="toctext">Text Entry and Rendering</span></a></li>
<li class="toclevel-2 tocsection-56"><a href="#Translating_Applications"><span class="tocnumber">11.2</span> <span class="toctext">Translating Applications</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-58"><a href="#Qt_Script"><span class="tocnumber">12</span> <span class="toctext">Qt Script</span></a>
<ul>
<li class="toclevel-2 tocsection-59"><a href="#Scripting_Architecture"><span class="tocnumber">12.1</span> <span class="toctext">Scripting Architecture</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="#Debugging"><span class="tocnumber">12.2</span> <span class="toctext">Debugging</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-62"><a href="#Styles_and_Themes"><span class="tocnumber">13</span> <span class="toctext">Styles and Themes</span></a>
<ul>
<li class="toclevel-2 tocsection-63"><a href="#Built-in_Styles"><span class="tocnumber">13.1</span> <span class="toctext">Built-in Styles</span></a></li>
<li class="toclevel-2 tocsection-64"><a href="#Widget_Style_Sheets"><span class="tocnumber">13.2</span> <span class="toctext">Widget Style Sheets</span></a></li>
<li class="toclevel-2 tocsection-65"><a href="#Custom_Styles"><span class="tocnumber">13.3</span> <span class="toctext">Custom Styles</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-67"><a href="#Input.2FOutput_and_Networking"><span class="tocnumber">14</span> <span class="toctext">Input/Output and Networking</span></a>
<ul>
<li class="toclevel-2 tocsection-68"><a href="#File_Handling"><span class="tocnumber">14.1</span> <span class="toctext">File Handling</span></a></li>
<li class="toclevel-2 tocsection-69"><a href="#XML"><span class="tocnumber">14.2</span> <span class="toctext">XML</span></a></li>
<li class="toclevel-2 tocsection-70"><a href="#Inter-Process_Communication"><span class="tocnumber">14.3</span> <span class="toctext">Inter-Process Communication</span></a></li>
<li class="toclevel-2 tocsection-71"><a href="#Networking"><span class="tocnumber">14.4</span> <span class="toctext">Networking</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-74"><a href="#Collection_Classes"><span class="tocnumber">15</span> <span class="toctext">Collection Classes</span></a>
<ul>
<li class="toclevel-2 tocsection-75"><a href="#Containers"><span class="tocnumber">15.1</span> <span class="toctext">Containers</span></a></li>
<li class="toclevel-2 tocsection-76"><a href="#Implicit_Sharing"><span class="tocnumber">15.2</span> <span class="toctext">Implicit Sharing</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-78"><a href="#Plugins_and_the_Meta-Object_System"><span class="tocnumber">16</span> <span class="toctext">Plugins and the Meta-Object System</span></a>
<ul>
<li class="toclevel-2 tocsection-79"><a href="#Plugins_and_Libraries"><span class="tocnumber">16.1</span> <span class="toctext">Plugins and Libraries</span></a></li>
<li class="toclevel-2 tocsection-80"><a href="#The_Meta-Object_System"><span class="tocnumber">16.2</span> <span class="toctext">The Meta-Object System</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-82"><a href="#Building_Qt_Applications"><span class="tocnumber">17</span> <span class="toctext">Building Qt Applications</span></a>
<ul>
<li class="toclevel-2 tocsection-83"><a href="#Qt.27s_Build_System"><span class="tocnumber">17.1</span> <span class="toctext">Qt's Build System</span></a></li>
<li class="toclevel-2 tocsection-84"><a href="#Qt.27s_Resource_System"><span class="tocnumber">17.2</span> <span class="toctext">Qt's Resource System</span></a></li>
<li class="toclevel-2 tocsection-85"><a href="#Testing_and_Benchmarking_Qt_Applications"><span class="tocnumber">17.3</span> <span class="toctext">Testing and Benchmarking Qt Applications</span></a></li>
<li class="toclevel-2 tocsection-86"><a href="#Qt_Creator"><span class="tocnumber">17.4</span> <span class="toctext">Qt Creator</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-88"><a href="#Qt.27s_Architecture"><span class="tocnumber">18</span> <span class="toctext">Qt's Architecture</span></a>
<ul>
<li class="toclevel-2 tocsection-89"><a href="#X11"><span class="tocnumber">18.1</span> <span class="toctext">X11</span></a></li>
<li class="toclevel-2 tocsection-90"><a href="#Microsoft_Windows"><span class="tocnumber">18.2</span> <span class="toctext">Microsoft Windows</span></a></li>
<li class="toclevel-2 tocsection-91"><a href="#Mac_OS_X"><span class="tocnumber">18.3</span> <span class="toctext">Mac OS X</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-93"><a href="#Platform_Specific_Extensions_and_Qt_Solutions"><span class="tocnumber">19</span> <span class="toctext">Platform Specific Extensions and Qt Solutions</span></a>
<ul>
<li class="toclevel-2 tocsection-94"><a href="#ActiveX_Interoperability"><span class="tocnumber">19.1</span> <span class="toctext">ActiveX Interoperability</span></a></li>
<li class="toclevel-2 tocsection-95"><a href="#Qt_Solutions"><span class="tocnumber">19.2</span> <span class="toctext">Qt Solutions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-97"><a href="#The_Qt_Development_Community"><span class="tocnumber">20</span> <span class="toctext">The Qt Development Community</span></a>
<ul>
<li class="toclevel-2 tocsection-98"><a href="#Online_References_19"><span class="tocnumber">20.1</span> <span class="toctext">Online References</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Qt_Whitepaper">Qt Whitepaper</span></h1>
<div class="thumb tleft"><div class="thumbinner" style="width:182px;"><a href="http://wiki.qt.io/File:Qt-logo-medium.png" class="image"><img alt="" src="http://wiki.qt.io/thumb.php?f=Qt-logo-medium.png&amp;width=180" width="180" height="236" class="thumbimage" srcset="/thumb.php?f=Qt-logo-medium.png&amp;width=270 1.5x, /thumb.php?f=Qt-logo-medium.png&amp;width=360 2x" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://wiki.qt.io/File:Qt-logo-medium.png" class="internal" title="Enlarge"><img src="http://wiki.qt.io/skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Qt Logo</div></div></div>
<p>This whitepaper describes the Qt C++ framework. Qt supports the development of cross-platform GUI applications with its "write once, compile anywhere" approach. Using a single source tree and a simple recompilation, applications can be written for Windows, Mac OS X, Linux, Solaris, HP-UX, and many other versions of Unix with X11.
</p><p>Qt applications can also be compiled to run on embedded Linux, Symbian and Windows CE platforms.
</p><p>Qt has excellent cross-platform support for multimedia and 3D graphics, internationalization, SQL, XML and unit testing, as well as providing platform-specific extensions for specialized applications.
</p><p>Qt applications can be built visually using <i>Qt Designer</i>, a flexible user interface builder with support for IDE integration.
</p><p>The release of Qt 4.7 introduces the foundations of Qt Quick, a collection of technologies for rapid prototyping and creation of modern, intuitive user interfaces. These are covered briefly in the <i>Qt Quick</i> section later in this whitepaper, and are described in more detail in the <a href="http://wiki.qt.io/Introduction_to_Qt_Quick_for_C++_Developers" title="Introduction to Qt Quick for C++ Developers">Introduction to Qt Quick for C++ Developers</a> whitepaper.
</p>
<h1><span class="mw-headline" id="Introduction">Introduction</span></h1>
<p><i>Qt is the de facto standard C++ framework for high performance cross-platform software development. In addition to an extensive C++ class library, Qt includes tools to make writing applications fast and straightforward. Qt's cross-platform capabilities and internationalization support ensure that Qt applications reach the widest possible market.</i>
</p><p>The Qt C++ framework has been at the heart of commercial applications since 1995. Qt is used by companies and organizations as diverse as Adobe®, Boeing®, Google®, IBM (R), Motorola®, NASA, Skype®, and by numerous smaller companies and organizations. Qt 4 is designed to be easier to use than previous versions of Qt, while adding more powerful functionality. Qt's classes are fully featured and provide consistent interfaces to assist learning, reduce developer workload, and increase programmer productivity. Qt is, and always has been, fully object-oriented.
</p><p>This whitepaper gives an overview of Qt's tools and functionality. Each section begins with a non-technical introduction before providing a more detailed description of relevant features. Links to online resources are also given for each subject area.
</p><p>To evaluate Qt Commercial for 30 days, visit <a rel="nofollow" class="external free" href="http://qt.digia.com/en/downloads/">http://qt.digia.com/en/downloads/</a>. Qt is also available under a LGPL license from <a rel="nofollow" class="external free" href="https://qt.io/download">https://qt.io/download</a>.
</p>
<h2><span class="mw-headline" id="Executive_Summary">Executive Summary</span></h2>
<p>Qt includes a rich set of widgets ("controls" in Windows terminology) that provide standard GUI functionality. Qt introduces an innovative alternative for inter-object communication, called "signals and slots", that replaces the old and unsafe callback technique used in many legacy frameworks. Qt also provides a conventional event model for handling mouse clicks, key presses, and other user input. Qt's cross-platform GUI applications can support all the user interface functionality required by modern applications, such as menus, context menus, drag and drop, and dockable toolbars. Desktop integration features provided by Qt can be used to extend applications into the surrounding desktop environment, taking advantage of some of the services provided on each platform.
</p><p>Qt also includes <i>Qt Designer</i>, a tool for graphically designing user interfaces. <i>Qt Designer</i> supports Qt's powerful layout features in addition to absolute positioning. <i>Qt Designer</i> can be used purely for GUI design, or to create entire applications with its support for integration with popular integrated development environments (IDEs).
</p><p>Qt has excellent support for multimedia and 3D graphics (page). Qt is the de facto standard GUI framework for platform-independent OpenGL® programming. Qt's painting system offers high quality rendering across all supported platforms. A sophisticated canvas framework enables developers to create interactive graphical applications that take advantage of Qt's advanced painting features.
</p><p>Qt makes it possible to create platform-independent database applications using standard databases. Qt includes native drivers for Oracle®, Microsoft® SQL Server, Sybase® Adaptive Server, IBM DB2®, PostgreSQL™, MySQL®, Borland® Interbase, SQLite, and ODBC-compliant databases. Qt includes database-specific widgets, and any built-in or custom widget can be made data-aware.
</p><p>Qt programs have native look and feel on all supported platforms using Qt's styles and themes support. From a single source tree, recompilation is all that is required to produce applications for Windows®, Mac OS X (R), Linux®, Solaris™, HP-UX™, and many other versions of Unix® with X11™. Qt's <a href="http://wiki.qt.io/index.php?title=Qmake&amp;action=edit&amp;redlink=1" class="new" title="Qmake (page does not exist)">qmake</a> build tool produces makefiles or <i>.dsp</i> files appropriate to the target platform.
</p><p>Since Qt's architecture takes advantage of the underlying platform, many customers use Qt for single-platform development on Windows, Mac OS X, and Unix because they prefer Qt's approach. Qt includes support for important platform-specific features, such as ActiveX® on Windows, and Motif™ on Unix. See the section on sec:Qt's-Architecture for more information.
</p><p>Qt uses Unicode™ throughout and has considerable support for internationalization. Qt includes <i>Qt Linguist</i> and other tools to support translators. Applications can easily use and mix text in Arabic, Chinese, English, Hebrew, Japanese, Russian, and other languages supported by Unicode.
</p><p>Qt includes a variety of domain-specific classes. For example, Qt has an XML module that includes SAX and DOM classes for reading and manipulating data stored in XML-based formats. Objects can be stored in memory using Qt's STL-compatible collection classes, and handled using styles of iterators used in Java® and the C++ Standard Template Library (STL). Local and remote file handling using standard protocols are provided by Qt's input/output and networking classes.
</p><p>Qt applications can have their functionality extended by plugins and dynamic libraries. Plugins provide additional codecs, database drivers, image formats, styles, and widgets. Plugins and libraries can be sold as products in their own right.
</p><p>The QtScript module enables applications to be scripted with Qt Script, an ECMAScript-based language related to JavaScript. This technology allows developers to give users restricted access to parts of their applications for scripting purposes.
</p><p>Qt is a mature C++ framework that is widely used around the world. In addition to Qt's many commercial uses, the Open Source edition of Qt is the foundation of KDE, the Linux desktop environment. Qt makes application development a pleasure, with its cross-platform build system, visual form design, and elegant API.
</p>
<h3><span class="mw-headline" id="Online_References">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://qt.io/videos#c-142">Qt Videos: Qt in Use</a>
</p>
<h1><span class="mw-headline" id="Graphical_User_Interfaces">Graphical User Interfaces</span></h1>
<p><i>Qt provides a rich set of standard widgets that can be used to create graphical user interfaces for applications. Layout managers are used to arrange and resize widgets to suit the user's screen, language and fonts.</i>
</p><p>Widgets are visual elements that are combined to create user interfaces. Buttons, menus and scroll bars, message boxes and application windows are all examples of widgets.
</p><p>Layout managers organize child widgets within their parent widget's area. They perform automatic positioning and resizing of child widgets, provide sensible minimum and default sizes for top-level widgets, and automatically reposition widgets when their contents change.
</p><p>Signals and slots connect application components together so that they can communicate in a simple, type-safe way. This form of inter-object communication is enabled in all standard widgets and can be used by developers in their own custom widgets.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/widgets.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/widgets.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/widgets.png</a>
</p><p><i>A selection of widgets provided by Qt.</i>
</p>
<h2><span class="mw-headline" id="Widgets">Widgets</span></h2>
<p>The images above present a selection of widgets. These include standard text entry widgets, check boxes, radio buttons, sliders and push buttons, as well as more specialized widgets for date and time entry.
</p><p>Labels, message boxes, tooltips and other textual widgets are not confined to using a single color, font and language. Qt's text-rendering widgets can display multi-language rich text using a subset of HTML.
</p><p>Container widgets such as tab widgets and group boxes are also available, and can be used to group related user interface components. These widgets are managed specially in <i>Qt Designer</i> to help designers create new user interfaces. More complex widgets, such as scrolling views, are often used more by developers than by user interface designers because they are used to display specialized or dynamic content.
</p><p>Developers can create their own widgets and dialogs by subclassing the base <b>QWidget</b> class or one of its subclasses. Specialized widgets like these can be completely customized to render their own content, respond to user input, and provide their own signals and slots.
</p><p>Qt provides many other widgets than those shown here. Many of the available widgets are shown with links to their class documentation in Qt's online <a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/gallery.html">Widget Gallery</a>.
</p>
<h2><span class="mw-headline" id="Layouts">Layouts</span></h2>
<p>Layouts provide flexibility and responsiveness to user interfaces, enabling them to adapt when their styles, orientations or text fonts are updated.
</p><p>Layouts help developers to support internationalization in their applications. With fixed sizes and positions, translated text is often truncated; with layouts, the child widgets are automatically resized. Additionally, widget placement can be reversed to provide a more natural appearance for users who work with right-to-left writing systems.
</p><p>Layouts can also run from right-to-left and from bottom-to-top. Right-to-left layouts are convenient for internationalized applications supporting right-to-left writing systems such as Arabic and Hebrew. The built-in layouts are fully integrated with Qt's style system to provide a consistent look and feel on reversed displays.
</p><p><i>Qt Designer</i> is fully able to use layouts to position widgets.
</p>
<h2><span class="mw-headline" id="Signals_and_Slots">Signals and Slots</span></h2>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/signalsandslots.html">Signals and slots</a> are used for communication between Qt objects. The signals and slots mechanism is a central feature of Qt and probably the part that differs most from the features provided by other frameworks. Signals and slots makes it easy to implement the <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>.
</p><p>Widgets emit signals when events occur. For example, a button will emit a "clicked" signal when it is clicked. A developer can choose to connect to a signal by creating a function (a "slot") and calling the <i><b>connect()</b></i> function to relate the signal to the slot. Qt's signals and slots mechanism does not require classes to have knowledge of each other, which makes it much easier to develop highly reusable classes. Since signals and slots are type-safe, type errors are reported as warnings and do not cause crashes to occur.
</p><p>For example, if a Quit button's <i><b>clicked()</b></i> signal is connected to the application's <i><b>quit()</b></i> slot, a user's click on Quit makes the application terminate. In code, this is written as
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw2">connect</span><span class="br0">&#40;</span>button<span class="sy0">,</span> SIGNAL <span class="br0">&#40;</span>clicked<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span> qApp<span class="sy0">,</span> SLOT <span class="br0">&#40;</span>quit<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>Connections can be added or removed at any time during the execution of a Qt application, they can be set up so that they are executed when a signal is emitted or queued for later execution, and they can be made between objects in different threads.
</p><p>The signals and slots mechanism is implemented in standard C++. The implementation uses the C++ preprocessor and <i>moc</i>, the Meta-Object Compiler, included with Qt. Code generation is performed automatically by sub:Qt's-Build-System. Developers never have to edit or even look at the generated code.
</p><p>In addition to handling signals and slots, the Meta-Object Compiler supports Qt's translation mechanism, its property system, and its extended run-time type information. It also makes run-time introspection of C++ programs possible in a way that works on all supported platforms. The underlying system that provides these facilities is known as Qt's meta-object system.
</p>
<h3><span class="mw-headline" id="Online_References_2">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/all-examples.html">Qt Examples</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/layout.html">Layout Management</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/object.html">Object Model</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/signalsandslots.html">Signals and Slots</a>
</p>
<h1><span class="mw-headline" id="Application_Features">Application Features</span></h1>
<p><i>Building modern GUI applications with Qt is fast and simple, and can be achieved by hand coding or by using Qt Designer, Qt's visual design tool.</i>
</p><p>Qt provides all the features necessary to create modern GUI applications with menus, toolbars and dock windows. Qt supports both SDI (single document interface) and MDI (multiple document interface). Qt also supports drag and drop and the clipboard.
</p><p>A full set of standard dialogs are provided, including those for choosing files, folders, fonts, and colors. In practice, a one-line statement using one of Qt's static convenience functions is all that is necessary to present a standard dialog.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/assistant.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/assistant.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/assistant.png</a>
</p><p><i>Qt Assistant uses many of the main window application features to display Qt's documentation.</i>
</p><p>Qt uses actions to simplify user interface programming. For example, if a menu option, a toolbar button, and a keyboard accelerator all perform the same action, the action need only be coded once.
</p><p>Qt can store application settings in a platform-independent way, using the system registry or text files, allowing items such as user preferences, most recently used files, window and toolbar positions and sizes to be recorded for later use.
</p><p>Support for multithreading programming is provided by a collection of classes that represent common constructs, making it possible to write Qt applications that take advantage of threads to perform calculations, long duration tasks, or just to improve responsiveness.
</p><p>Applications can also use Qt's desktop integration features to interact with services provided by the user's desktop environment.
</p>
<h2><span class="mw-headline" id="Main_Window_Features">Main Window Features</span></h2>
<p>The <b>QMainWindow</b> class provides a framework for typical application main windows. A main window contains a set of standard widgets. The top of the main window is occupied by a menu bar, beneath which toolbars are laid out in toolbar areas around the center of the window. The area of the main window below the bottom toolbar area is occupied by a status bar. Tooltips and "What's this?" help provide balloon help for the user interface elements.
</p>
<h3><span class="mw-headline" id="QMenu">QMenu</span></h3>
<p>The QMenu widget presents menu items to the user in a vertical list. Menus can be standalone (e.g., a context pop-up menu), can appear in a menu bar, or can be a sub-menu of another pop-up menu. Menus can have tear-off handles.
</p><p>Each menu item can have an icon, a checkbox, and an accelerator. Menu items usually correspond to actions (e.g., "Save") and cause their associated slots to be executed when selected by the user. Qt's layout managers take any menu bar into consideration. On Mac OS X, the menu bar appears at the top of the screen.
</p><p>Qt's menus are very flexible and are part of an integrated action system (see <a href="http://wiki.qt.io/QtWhitepaper#Actions" title="QtWhitepaper">QtWhitepaper#Actions</a>). Actions can be enabled or disabled, dynamically added to menus, and removed again later.
</p>
<h3><span class="mw-headline" id="QToolBar">QToolBar</span></h3>
<p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-unified-toolbar.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-unified-toolbar.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-unified-toolbar.png</a>
</p><p><i>Unified toolbar support on Mac OS X improves the look and feel of applications by blending adjacent toolbars and window title bars together.</i>
</p><p>Toolbars contain collections of buttons and other widgets that the user can access to perform actions. They can be moved between the areas at the top, left, right, and bottom of the central area of a main window. Any toolbar can be dragged out of its toolbar area, and floated as an independent tool palette.
</p><p>The <b>QToolButton</b> class implements a toolbar button with an icon, a styled frame, and an optional label. Toggle toolbar buttons turn features on and off. Other toolbar buttons execute commands. Different icons can be provided for the active, disabled, and enabled modes, and for the on and off states. If only one icon is provided, Qt automatically distinguishes the state using visual cues, for example, graying out disabled buttons. Toolbar buttons can also trigger pop-up menus.
</p><p>Dock windows are windows that the user can move inside a toolbar area or from one toolbar area to another. The user can undock a dock window and make it float on top of the application, or minimize it. Animations are used to smoothly slide dock windows into and out of dock areas.
</p><p>Dock areas can also be nested to allow dock windows to be stacked in multiple rows or columns, and dock windows can be stacked together in shared areas — when this occurs, the dock widgets are held in tabs.
</p><p>Customization of dock windows is also possible. They can be displayed with vertical title bars, and given individually-styled title bars and window controls.
</p><p>Some applications, including <i>Qt Designer</i> (see page) and <i>Qt Linguist</i> (page), use dock windows extensively. provides operators to save and restore the position of dock windows and toolbars, so that applications can easily restore the user's preferred working environment.
</p>
<h3><span class="mw-headline" id="QStatusBar">QStatusBar</span></h3>
<p>The QStatusBar class provides a horizontal bar suitable for presenting status information, for example a can be hint:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">statusBar<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me3">showMessage</span><span class="br0">&#40;</span><span class="st0">&quot;Ready&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>This snippet will show the message- "Ready" on status bar. You can set property <i><b>statusHint</b></i> in any widget.
</p>
<h2><span class="mw-headline" id="Actions">Actions</span></h2>
<p>Applications usually provide the user with several different ways to perform a particular action. For example, most applications have traditionally provided a "Save" action available from the menu, from the toolbar (a toolbar button with an appropriate icon), and as an accelerator (). The <b>QAction</b> class encapsulates this concept. It allows programmers to define an action in one place.
</p><p>As well as avoiding duplication of work, using a <b>QAction</b> ensures that the state of menu items stay in sync with the state of related toolbar buttons, and that interactive help is displayed when necessary. Disabling an action will disable any corresponding menu items and toolbar buttons. Similarly, if the user clicks a toggle button in a toolbar, the corresponding menu item will also be toggled.
</p>
<h2><span class="mw-headline" id="Dialogs_and_Wizards">Dialogs and Wizards</span></h2>
<p>Most GUI applications use dialog boxes to interact with the user for certain operations. Qt includes ready-made dialog classes with convenience functions for the most common tasks. Screenshots of some of Qt's standard dialogs are presented below. Qt also provides standard dialogs for color selection, printing, indicating progress and displaying messages.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/filedialog.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/filedialog.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/filedialog.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/fontdialog.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/fontdialog.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/fontdialog.png</a>
</p><p>A <b>QFileDialog</b> and a <b>QFontDialog</b> shown in the Plastique style. On Windows and Mac OS X, native dialogs are used instead.
</p><p>Programmers can create their own dialogs by subclassing <b>QDialog</b>. <i>Qt Designer</i> also includes dialog templates to help developers get started with new designs.
</p><p>Wizards are used to guide users through common tasks and processes, taking them step by step through the available options and providing help where necessary. Qt provides a flexible, yet intuitive API for building wizards with the appropriate native look and feel on each supported platform.
</p><p>The <b>QWizard</b> class provides features for customizing the appearance of the wizard beyond the basic platform-specific look and feel. Instances of this class also control the order in which pages are presented to the user. <b>QWizardPage</b> is a standard widget that provides features to store and validate user input.
</p>
<h2><span class="mw-headline" id="Interactive_Help">Interactive Help</span></h2>
<p>Applications often use various forms of interactive help to explain the purpose of user interface elements and assist users. Qt provides two mechanisms for giving brief help messages: tooltips for short context-sensitive help and "What's this?" pop-up help containing longer, more informative messages. Both of these are integrated with Qt's action system.
</p><p>Developers can deploy <i>Qt Assistant</i> as the help browser for their own applications and documentation sets by using the classes in Qt's Help module. This module also provides an API that developers can use to access documentation for custom display purposes, perhaps using the tooltips and "What's This?" classes to show small pieces of relevant information to users.
</p>
<h2><span class="mw-headline" id="Settings">Settings</span></h2>
<p>User settings and other application settings can easily be stored on disk using the <b>QSettings</b> class. On Windows, Mac OS X and Linux platforms, settings are stored in standard system locations; on other platforms, they are stored in text files.
</p><p>A variety of Qt data types can be used seamlessly with <b>QSettings</b> and will be serialized for storage and later retrieval by applications. See sub:File-Handling for more information about serialization of Qt's data types.
</p>
<h2><span class="mw-headline" id="Multithreading_and_Concurrent_Programming">Multithreading and Concurrent Programming</span></h2>
<p>Qt applications can use multiple threads: one thread to keep the user interface responsive, and one or many other threads to perform time-consuming activities such as reading large files and performing complex calculations. Qt provides classes to represent threads, mutexes, semaphores, thread-global storage, and locking primitives.
</p><p>Facilities for concurrent programming are also provided, including implementations of the well-known map-reduce and filter-reduce algorithms. These are integrated with Qt's object model, using standard container classes to make it more convenient to use concurrent techniques in Qt applications.
</p><p>Qt's meta-object system enables objects in different threads to communicate using signals and slots, making it possible for developers to create single-threaded applications that can later be adapted for multithreading without an extensive redesign.
</p>
<h2><span class="mw-headline" id="Desktop_Integration">Desktop Integration</span></h2>
<p>Applications can be extended to interact with services provided by the user's desktop environment by using Qt's desktop integration classes. These range from <b>QSystemTrayIcon</b>, which is often used by long-running applications to provide a persistent indicator in the system tray, to <b>QDesktopServices</b>, which allows resources such as <b>mailto:</b> and <b>http://</b> URLs to be processed by the most appropriate applications on each platform.
</p>
<h3><span class="mw-headline" id="Online_References_3">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-4.8/qt4-mainwindow.html">The Qt 4 Main Window Classes</a>
</p>
<h1><span class="mw-headline" id="Qt_Designer">Qt Designer</span></h1>
<p><i>Qt Designer is a graphical user interface design tool for Qt applications. Applications can be written entirely as source code, or using Qt Designer to speed up development. A component-based architecture makes it possible for developers to extend Qt Designer with custom widgets and extensions, and even integrate it into integrated development environments.</i>
</p><p>Designing a form with <i>Qt Designer</i> is a simple process. Developers drag widgets from a toolbox onto a form, and use standard editing tools to select, cut, paste, and resize them. Each widget's properties can then be changed using the property editor. The precise positions and sizes of the widgets do not matter. Developers select widgets and apply layouts to them. For example, some button widgets could be selected and laid out side by side by choosing the "lay out horizontally" option. This approach makes design very fast, and the finished forms will scale properly to fit whatever window size the end-user prefers. See sub:Layouts for information about Qt's automatic layouts.
</p><p><i>Qt Designer</i> eliminates the time-consuming "compile, link, and run" cycle for user interface design. This makes it easy to correct or change designs. <i>Qt Designer'</i>s preview options let developers see their forms in other styles; for example, a Mac OS X developer can preview a form in the Windows style. Forms can be previewed using device "skins" to simulate the display constraints and appearance of the target device.
</p><p>Commercial licensees on Windows can enjoy <i>Qt Designer'</i>s user interface design facilities from within Microsoft Visual Studio®. Qt Development Frameworks also produces a Qt integration plugin for the cross-platform Eclipse™ IDE that embeds <i>Qt Designer</i> alongside other Qt technologies into the IDE framework.
</p>
<h2><span class="mw-headline" id="Working_with_Qt_Designer">Working with Qt Designer</span></h2>
<p>Developers can create both "dialog" style applications and "main window" style applications with menus, toolbars, balloon help, and other standard features. Several form templates are supplied, and developers can create their own templates to ensure consistency across an application or family of applications. Programmers can create their own custom widgets that can easily be integrated with <i>Qt Designer</i>.
</p><p><i>Qt Designer</i> supports a form-based approach to application development. A form is represented by a user interface (<i>.ui</i>) file, which can either be converted into C++ and compiled into an application, or processed at run-time to produce dynamically-generated user interfaces. Qt's build system (see page) is able to automate the compile-time construction of user interfaces to make the design process easier.
</p><p>The tools used to create and edit the source code for applications created with <i>Qt Designer</i> will depend on each developer's personal preferences; some will want to take advantage of the integration features provided with <i>Qt Designer</i> to develop from within Microsoft Visual Studio or the Eclipse environment.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/designer-46-overview.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/designer-46-overview.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/designer-46-overview.png</a>
</p><p><i>An overview of Qt Designer's user interface.</i>
</p>
<h2><span class="mw-headline" id="Extending_Qt_Designer">Extending Qt Designer</span></h2>
<p>The component-based architecture used as a foundation for <i>Qt Designer</i> was specifically designed to allow developers to extend its user interface and editing tools with custom components. In addition, the modular nature of the application makes it possible to make <i>Qt Designer'</i>s user interface design features available from within integrated development environments such as Qt Creator, Microsoft Visual Studio and KDevelop.
</p><p>In total, the QtDesigner module provides over 20 classes for working with <i>.ui</i> files and extending <i>Qt Designer</i>. Many of these allow third parties to customize the user interface of the application itself.
</p><p>Third party and custom widgets for in-house work are easily integrated into <i>Qt Designer</i>. Adapting an existing widget for use within <i>Qt Designer</i> only requires a the widget to be compiled as a plugin, using an interface class to supply default widget properties and construct new instances of the widget. The plugin's interface is exported to <i>Qt Designer</i> using a macro similar to that described in sub:Plugins .
</p>
<h3><span class="mw-headline" id="Online_References_4">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtdesigner-manual.html">Qt Designer Manual</a>
</p><p><a rel="nofollow" class="external text" href="http://wiki.qt.io/Category:Tools::QtCreator">Qt Creator</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/qtdesigner-module.html">Qt Designer Module</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/examples-designer.html">Qt Designer Examples</a>
</p>
<h1><span class="mw-headline" id="Graphics_and_Multimedia">Graphics and Multimedia</span></h1>
<p><i>Qt provides excellent support for 2D and 3D graphics. Qt's 2D graphics classes support raster and vector graphics, can load and save a wide and extensible range of image formats, and can export text and graphics to Portable Document Format (PDF) files. Qt can draw transformed Unicode rich text, Scalable Vector Graphics (SVG) drawings, and provides a fully-featured canvas for demanding interactive applications. Qt also provides features for playing audio and video files and streams.</i>
</p><p>Graphics are drawn using device-independent painter objects that allow the developer to reuse the same code to render graphics on different types of device, represented in Qt by paint devices (see sub:Painting on page). This approach ensures that a wide range of powerful painting operations are available for each of the devices supported by Qt, and also allows developers to choose the devices that are most suitable for their needs.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/demos-boxes.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/demos-boxes.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/demos-boxes.png</a>
</p><p><i>The Boxes demonstration presents a range of Qt's graphical features.</i>
</p><p>Graphical applications that require an interactive canvas can take advantage of the Graphics View framework to manage and render scenes with large numbers of interactive items, using multiple views if necessary.
</p><p>Qt's support for OpenGL and OpenGL ES helps developers to integrate 3D graphics into their applications, yet it also enables them to take advantage of modern graphics hardware to improve 2D rendering performance.
</p><p>Device-independent color support enables colors to be specified by ARGB, AHSV, or ACMYK values, or by common names. The color channels used are 16 bits wide, and an optional level of opacity can be specified. Qt automatically allocates the requested color in the system's palette, or uses a similar color on color-limited displays.
</p>
<h2><span class="mw-headline" id="Painting">Painting</span></h2>
<p>Qt provides a platform-independent API for painting onto widgets and other paint devices. It provides drawing primitives as well as advanced features such as transformations and clipping. All of Qt's built-in widgets paint themselves using <b>QPainter</b>, and programmers use this class when implementing their own custom widgets.
</p>
<h3><span class="mw-headline" id="QPainter">QPainter</span></h3>
<p>QPainter provides standard functions to draw points, lines, ellipses, arcs, B'ezier curves, and other primitives. More complex painting operations include support for polygons and vector paths, allowing detailed drawings to be prepared in advance and drawn using a single function call. Text can also be painted directly with a painter or incorporated in a path for later use.
</p><p>Qt's painting system also provides a number of features to improve overall rendering quality, including alpha blending, Porter-Duff composition modes, anti-aliasing, and linear, radial and conical gradient fills.
</p>
<table style="center; margin: -1px auto 20px;border: 1px solid #C00; border-left: 10px solid #C00; background:rgb(250,250,250); width:600px">

<tr>
<td style="padding: 0.25em 0.5em;"> When painting on a QWidget, QPainter can only be used inside a <i><b>paintEvent()</b></i> function or in a function called by <i><b>paintEvent();</b></i> that is unless the <b>Qt::WA_PaintOutsidePaintEvent</b> widget attribute is set. On Mac OS X and Windows, you can only paint in a paintEvent() function regardless of this attribute's setting.
</td></tr></table>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw4">void</span> paintEvent<span class="br0">&#40;</span><span class="kw5">QPaintEvent</span> <span class="sy0">*</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 <span class="kw5">QPainter</span> doc<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw5">QLineF</span> line<span class="br0">&#40;</span><span class="nu16">10.0</span><span class="sy0">,</span> <span class="nu16">80.0</span><span class="sy0">,</span> <span class="nu16">90.0</span><span class="sy0">,</span> <span class="nu16">20.0</span><span class="br0">&#41;</span><span class="sy0">;</span>
 doc.<span class="me1">drawLine</span><span class="br0">&#40;</span>line<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>This snippet will draw a black line on a widget. <a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/qpainter.html">There are many methods</a> to set brush, pen and aliasing.
</p>
<h2><span class="mw-headline" id="Images">Images</span></h2>
<p>Qt supports input, output, and manipulation of images in several formats, including BMP, GIF, JPEG, MNG, PNG, PNM, TIFF, XBM and XPM. Both classes can be used as paint devices and used in interactive graphical applications, or they can be used to preprocess images for later use in user interface components.
</p><p><b>QImage</b> is used for image manipulation, and can perform conversions between various color depths and pixel formats. Programmers can manipulate the pixel and palette data, apply transformations such as rotations and shears, and reduce the color depth with dithering if desired. Support for alpha channels enables applications to use transparency and alpha-blending for image composition and other purposes.
</p><p>The range of graphics file formats that can be used with these classes can be extended through the use of an extensible plugin mechanism.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/graphicsview-map.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/graphicsview-map.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/graphicsview-map.png</a>
</p><p><i>The Graphics View framework enables graphical applications to be created which combine high quality rendering with comprehensive features for user interaction.</i>
</p>
<h2><span class="mw-headline" id="Paint_Devices_and_Printing">Paint Devices and Printing</span></h2>
<p><b>QPainter</b> can operate on any paint device. The code required to paint on any supported device is the same, regardless of the device.
</p><p>All widgets are paint devices. Qt uses a <i>backing store</i> to reduce flickering during the painting process. Translucent and shaped windows can be created on suitably configured systems.
</p><p>OpenGL surfaces used with <b>QGLWidget</b> are also paint devices that convert standard <b>QPainter</b> calls to OpenGL calls, enabling two-dimensional graphics to be accelerated on devices with appropriately supported hardware.
</p><p>Images can also be created by painting on device-independent <b>QImage</b> and display-optimized <b>QPixmap</b> objects. Standard image format files can be created by rendering to an image with the desired color depth and pixel format. Images can be created with support for varying levels of transparency and painted onto custom widgets to achieve certain effects.
</p><p>Vector and meta-file formats are also supported by the paint system. <b>QSvgGenerator</b> creates Scalable Vector Graphics (SVG) drawings (see page) by translating painting commands to the corresponding structures in the SVG file format. <b>QPicture</b> is used to hold a sequence of painting commands that can be replayed when painting on another paint device or stored in a file.
</p><p>Printing is performed by rendering to a <b>QPrinter</b> device that represents a physical printer. On Windows, the paint commands are sent to the Windows print engine, which uses the installed printer drivers. On Unix, PostScript® or Portable Document Format (PDF) data is sent to the print daemon — this is handled by the Common Unix Printing System (CUPS) on modern systems.
</p><p>Using Qt's generic painting API, applications can create PDF and PostScript files can be generated on all platforms, enabling applications to create high quality documents that can be viewed using suitable reader applications.
</p>
<h2><span class="mw-headline" id="Graphics_View_Framework">Graphics View Framework</span></h2>
<p>Qt introduces a powerful new framework for interactive graphical applications that is used to manage and display large numbers of items in a two-dimensional scene. Graphics View provides both an object-based API for adding new items to a scene and a traditional canvas-style API containing convenience functions for creating predefined items.
</p><p>Once created, items can be placed with the required position, orientation, and scale in a scene. The display and item management functionality are implemented separately in the <b>QGraphicsView</b> and <b>QGraphicsScene</b> classes, enabling features such as multiple views onto the same scene and support for switchable renderers.
</p><p>A selection of standard item types are provided, and these can be extended through subclassing to provide custom item types. Items can be grouped together to allow higher-level control over parts of a scene. Each scene, view, and the items themselves provide a comprehensive set of functions to allow coordinates to be transformed conveniently between coordinate systems. Both standard and custom items can be made selectable and movable, enabling a basic level of interactivity with a minimum of code.
</p><p>Graphics View has been designed with animations in mind: items can be used to create animated objects that are transformed according to a series of transformations defined at certain points on a timeline.
</p><p>Some of the standard items bring features found in other parts of Qt to the Graphics View framework, including rich text editing, Web browsing, display of SVG drawings and the use of shapes, paths and images. Items on a scene can also be rendered independently of any attached view, enabling scenes to be rendered to image files and printed to PDF files or printers.
</p><p>A fully-featured event model enables events to be handled efficiently by dispatching them only to the items that require them. Since basic item handling is performed by the framework, items only need to respond to events if they need particular information about their environment.
</p><p>Applications that need to mix classical user interface elements with interactive content can embed widgets directly into a scene using <b>QGraphicsProxyWidget</b>, or create widget-like elements from scratch with <b>QGraphicsWidget</b>. As with conventional user interfaces, layout managers can be used to arrange widgets and items in a scene.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/svgviewer-example.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/svgviewer-example.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/svgviewer-example.png</a>
</p><p><i>SVG drawings can be rendered onto any paint device supported by Qt.</i>
</p>
<h2><span class="mw-headline" id="Scalable_Vector_Graphics_.28SVG.29">Scalable Vector Graphics (SVG)</span></h2>
<p>SVG is an XML-based file format and language for describing graphical applications that is commonly associated with two-dimensional Web-based graphics. SVG support in Qt is based on the SVG 1.1 standard, a World Wide Web Consortium (W3C®) Recommendation, and provides additional features to support the Tiny profiles of SVG 1.1 and 1.2.
</p><p>Qt can render SVG drawings onto any paint device, including those for images and OpenGL widgets. This flexibility lets developers trade quality for speed as required. SVG drawings can also be used for icons in standard user interface controls, removing the need to generate bitmaps in a range of predefined sizes.
</p><p>Developers can also generate SVG drawings by using <b>QPainter</b> functions to draw on a specialized SVG paint device, allowing graphics used in applications to be exported as SVG drawings with little additional effort.
</p>
<h2><span class="mw-headline" id="3D_Graphics">3D Graphics</span></h2>
<p>OpenGL is a standard API for rendering 3D graphics that can be used by Qt developers to include 3D graphics in their GUI applications. Qt's OpenGL module is available on Windows, X11, and Mac OS X, and uses each system's OpenGL library.
</p><p>To use OpenGL in a Qt application, developers only need to subclass <b>QGLWidget</b> and draw onto it with standard OpenGL functions. Qt provides functions to convert color values to OpenGL's color format to help developers provide a consistent user interface for their applications.
</p><p>Qt also enables OpenGL features and extensions to be used conveniently from within Qt applications. Convenience functions allow textures to be created from images, and support for pixel buffers and framebuffer objects are provided by appropriate classes. Support for features such as sample buffers can be enabled if they are available on the underlying platform.
</p><p>2D applications can use <b>QGLWidget</b> subclasses to improve rendering performance on appropriate hardware. In this use case, standard <b>QPainter</b> operations are translated into OpenGL calls. This also makes it possible to overlay controls and decorations onto 3D scenes drawn using pure OpenGL. On embedded platforms, where hardware acceleration is often limited, this paint engine is restricted to using the functionality of OpenGL ES 2.0, ensuring that it works well on as many devices as possible.
</p><p>On suitable hardware, support for anti-aliased rendering can be enabled to enhance both the rendering speed and quality of graphics produced using the OpenGL paint engine. On less-capable hardware, developers can give users the choice between quality and speed by exposing these rendering options to users at run-time.
</p>
<h2><span class="mw-headline" id="Multimedia">Multimedia</span></h2>
<p>Qt uses the Phonon multimedia framework, an open source project originating from the KDE project, to provide media playback features that can be accessed using a consistent, cross-platform API. Qt ensures that applications on Linux/Unix, Windows and Mac OS X transparently use the appropriate multimedia framework for each platform — this means that applications can also take advantage of platform-specific support for audio and video codecs and formats.
</p><p>Phonon's features can be integrated into other technologies provided by Qt. For example, movie widgets can be added to Web pages displayed using the WebKit browser engine and to scenes rendered using the Graphics View framework.
</p><p>Additional classes for multimedia are included in the QtMultimedia module. These classes are focused on providing low-level access to audio and video data.
</p>
<h3><span class="mw-headline" id="Online_References_5">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/qpainter.html">QPainter Class Reference</a> <a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/graphicsview.html">Graphics View Framework</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtopengl-index.html">OpenGL Module</a> <a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtmultimedia-index.html">QtMultimedia Module</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtsvg-index.html">QtSvg Module</a>
</p>
<h1><span class="mw-headline" id="Item_Views">Item Views</span></h1>
<p><i>Qt's item view widgets provide standard GUI controls for displaying and modifying large quantities of data. The underlying model/view framework isolates the way data is stored from the way it is presented to the user, enabling features like data sharing, sorting and filtering, multiple views, and multiple data representations to be used for the same data.</i>
</p><p>When writing applications that process large quantities of data, developers typically rely on "item view" widgets to display items of data quickly and efficiently. Standard item views found in modern GUI toolkits include list views containing simple lists of items, tree views with hierarchical lists of items, and table views which provide layout features similar to those found in spreadsheet applications.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/cleanlooks-treeview.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/cleanlooks-treeview.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/cleanlooks-treeview.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/plastique-listview.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/plastique-listview.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/plastique-listview.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-tableview.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-tableview.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/macintosh-tableview.png</a>
</p><p><i>Qt provides standard item views for trees, lists and tables of items.</i>
</p><p>Qt's item view classes are available in two different forms: as classic item view widgets and as model/view components. Classic list, table and tree widgets are self-contained item views that manage item objects explicitly created by the developer.
</p><p><b>QListView</b>, <b>QTableView</b> and <b>QTreeView</b> are the equivalent model/view components to the classic item views. These model/view components provide a cleaner, component-oriented way to handle data sets. Additionally, a set of standard models are provided to help developers organize their data.
</p>
<h2><span class="mw-headline" id="Standard_Item_Views">Standard Item Views</span></h2>
<p>Standard implementations of list widgets, icon views, tree widgets, and tables are supplied with Qt. These support drag and drop operations within the same view and between different views. As with all Qt widgets, they are also fully integrated with Qt's resource system.
</p><p>Item view classes are used to display data for various standard dialogs in Qt (Figure ) and are extensively used in <i>Qt Designer</i>, <i>Qt Assistant</i>, and <i>Qt Linguist</i>.
</p><p>Classic item views are typically used to display and manage a few hundred items of data, using an architecture that uses individual objects to encapsulate pieces of data. This approach should be familiar to existing Qt developers, and provides a convenient way to rapidly construct rich user interfaces for handling moderate amounts of data.
</p><p>For consistency and reliability, the classic item views are built upon Qt's model/view framework, which provides a more scalable and customizable way to handle item view data.
</p>
<h2><span class="mw-headline" id="Qt.27s_Model.2FView_Framework">Qt's Model/View Framework</span></h2>
<p>The model/view framework provided by Qt is a variation of the well-known <i>Model-View-Controller</i> pattern, adapted specially for Qt's item views. In this approach, models are used to supply data to other components, views display items of data to the user, and delegates handle aspects of the rendering and editing processes.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/modelview-delegates.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/modelview-delegates.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/modelview-delegates.png</a>
</p><p><i>The component-oriented architecture of the model/view framework makes it easy to customize item views.</i>
</p><p>Models are wrappers around sources of data that are written to conform to a standard interface provided by <b>QAbstractItemModel</b>. This interface enables widgets derived from <b>QAbstractItemView</b> to access data supplied via the model, irrespective of the nature of the original data source.
</p><p>The separation between data and its presentation which this approach enables provides a number of improvements over classic item views:
</p>
<ul>
<li> Since models provide a standard interface for accessing data, they can be designed and written separately from other components, and replaced if necessary.
</li>
<li> Data obtained from models can be shared between views. This enablesapplications to provide multiple views onto the same data set, andpotentially show different representations of data.
</li>
<li> Selections can be shared between views, or kept separate, dependingon the user's requirements and expectations.
</li>
<li> For standard list, tree, and table views, most of the rendering isperformed by delegates. This makes it easy to customize views formost purposes without having to write a lot of new code.
</li>
<li> By using <i>proxy models</i>, data supplied by models can be transformed before it is supplied to views. This enablesapplications to provide sorting and filtering facilities that can be shared between multiple views.
</li>
</ul>
<p>The model/view system is also used by Qt's SQL models to make database integration simpler for non-database developers.
</p>
<h3><span class="mw-headline" id="Online_References_6">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/model-view-programming.html">Model/View Programming</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/all-examples.html">Qt Examples</a>
</p>
<h1><span class="mw-headline" id="Text_Handling">Text Handling</span></h1>
<p><i>Qt provides a powerful text editor widget that allows the user to create and edit rich text documents, and can be used to prepare documents for printing. The underlying document structure used by the editor is fully accessible to developers, allowing both the structure and content of documents to be manipulated.</i>
</p><p>Rich text documents typically contain text in a variety of fonts, colors, and sizes arranged in a series of paragraphs. Text can also be organized using lists and tables, and may be visually separated from the main body of a document by using frames. The appearance of each document element can be precisely adjusted using the many properties made available to developers through the rich text API.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/textedit-demo.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/textedit-demo.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/textedit-demo.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/textedit-OpenOffice.org.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/textedit-OpenOffice.org.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/textedit-OpenOffice.org.png</a>
</p><p><i>Qt's advanced rich text document features allow complex documents to be created and edited in <b>QTextEdit</b> (left). Documents can be exported in OpenDocument format for use in suitable document processors (right).</i>
</p>
<h2><span class="mw-headline" id="Rich_Text_Editing">Rich Text Editing</span></h2>
<p>Interactive rich text display and editing are handled in Qt by the <b>QTextBrowser</b> and <b>QTextEdit</b> widgets. These widgets fully support Unicode and are built on a structured document representation provided by <b>QTextDocument</b> that removes the need to use intermediate mark up languages to create rich text. <b>QTextDocument</b> also provides support for importing and exporting a subset of HTML 4.0, full undo/redo capabilities (including grouping of operations), and resource handling.
</p><p>Qt provides an object-based API for documents that helps developers obtain a high-level overview of their structures. A cursor-based API is also provided to allow convenient exploration, processing and transformation of documents. In addition to the classes corresponding to structure and content, there are a number of classes which control the appearance of text and document elements. These allow the text styles for tables, lists, frames, and ordinary paragraphs to be customized to give documents the desired appearance.
</p><p>Documents created programatically remain editable in <b>QTextEdit</b> widgets and maintain a full undo/redo history. Developers can augment the standard editing features available to let users add custom structures and content.
</p>
<h2><span class="mw-headline" id="Customization.2C_Printing_and_Document_Export">Customization, Printing and Document Export</span></h2>
<p>Qt's text handling features can also be used to provide specialized text formatting for custom widgets and rich text documents. These can be written using low-level classes such as <b>QTextLayout</b> to lay out the text line by line, and integrated into the extensible text layout system provided by <b>QTextDocument</b> for use with <b>QTextEdit</b>.
</p><p>Syntax highlighting rules can also be applied to rich text documents with the <b>QSyntaxHighlighter</b> class. This allows a standard <b>QTextEdit</b> widget to be used as the basis for a code editor, or to provide highlighting facilities for document search tools.
</p><p>Documents can also be formatted according to information obtained from a <b>QPrintDialog</b> into a series of pages suitable for printing with a <b>QPrinter</b>.
</p><p>The <b>QTextDocumentWriter</b> class provides support for document export to HTML, plain text and OpenDocument Format (ODF) files. This class exposes its functionality via a generic API and is designed to be extended to support additional formats in future releases.
</p>
<h3><span class="mw-headline" id="Online_References_7">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-4.8/qt4-scribe.html">The Scribe Classes</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/richtext.html">Rich Text Processing</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/qtextdocumentwriter.html">QTextDocumentWriter Class Reference</a>
</p>
<h1><span class="mw-headline" id="Web_Integration_with_WebKit">Web Integration with WebKit</span></h1>
<p><i>Qt's integration with the WebKit browser engine enables developers to introduce Web functionality into their applications by using Qt-style APIs and paradigms to display and interact with Web content.</i>
</p><p>Qt includes integrated support for WebKit, a fully-featured open source Web rendering engine with a focus on stability and performance. The version of WebKit supplied with Qt supports a number of Web standards, including HTML 4.01, XHTML 1.1, CSS 2.1 and JavaScript 1.5. More advanced features are also available — these are presented in the <a rel="nofollow" class="external text" href="http://qt.digia.com/forms/whitepapers/reg-whitepaper-hybrid/">WebKit in Qt</a> whitepaper.
</p><p>WebKit's networking is transparently handled using Qt's networking classes, providing browser components with a fully-compliant HTTP 1.1 implementation support for Secure Sockets Layer (SSL) communication and proxy support.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/webkit-plus-graphics-view.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/webkit-plus-graphics-view.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/webkit-plus-graphics-view.png</a>
</p><p><i>Qt widgets can be embedded into Web pages displayed with Qt's WebKit integration; Web Pages can be displayed as items in the Graphics View framework.</i>
</p>
<h2><span class="mw-headline" id="Native_Application_Integration">Native Application Integration</span></h2>
<p>Qt's support for WebKit goes beyond just rendering HTML by exposing features of WebKit to applications using Qt's paradigms. For example, support for Qt's signals and slots communication mechanism makes it easier for developers to connect Web components to widgets and other application objects.
</p><p>Conversely, the integration between Qt and the browser engine enables native Qt controls to be included within Web pages, making it possible to combine Web content with highly-dynamic native user interfaces.
</p><p>WebKit also enables Web applications to use native storage for persistent data, and this features is supported by Qt. Developers can enable native storage for applications that interoperate with remote services, and take advantage of configuration options to set an appropriate location and quota for it on the user's system.
</p>
<h2><span class="mw-headline" id="DOM_Access_API">DOM Access API</span></h2>
<p>The standard way to manipulate the structure of Web pages is via a Document Object Model (DOM) API. Qt's WebKit integration includes an implementation of the W3C selector API that provides a very simple way to access and manipulate page structures.
</p><p>This API makes it intuitive to access the DOM by letting developers reuse their CSS selector knowledge, and results in little maintenance or footprint overhead.
</p>
<h2><span class="mw-headline" id="Netscape_Plugin_Support">Netscape Plugin Support</span></h2>
<p>Plugins conforming to the Netscape plugin API, a de-facto standard for third party browser components, can be embedded and displayed in Web pages rendered by Qt's WebKit integration. Configuration of this feature is performed via a Qt class that is also used to configure other kinds of plugins, such as widget plugins exposed by the application to the Web environment.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/webkit-netscape-plugin.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/webkit-netscape-plugin.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/webkit-netscape-plugin.png</a>
</p><p><i>Third party browser plugins are supported by Qt and WebKit via the Netscape plugin API.</i>
</p>
<h3><span class="mw-headline" id="Online_References_8">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtwebkit-index.html">WebKit in Qt</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-4.8/demos-browser.html">Web Browser</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtwebkitexamples-webkitwidgets-browser-example.html">Tab Browser</a>
</p>
<h1><span class="mw-headline" id="Databases">Databases</span></h1>
<p><i>The Qt SQL module simplifies the creation of cross-platform GUI database applications. Programmers can easily execute SQL statements, use database models to supply information to item views for visualization and data entry purposes, and use widget mappers to relate database tables to specific widgets in form-based user interfaces.</i>
</p><p>The Qt SQL module provides a cross-platform interface for accessing SQL databases, and includes native drivers for Oracle, Microsoft SQL Server, Sybase Adaptive Server, IBM DB2, PostgreSQL, MySQL, Borland Interbase, SQLite and ODBC. The drivers work on all platforms supported by Qt for which client libraries are available. Applications can access multiple databases using multiple drivers simultaneously. Distributions of Qt include the SQLite database, and the Qt SQL module is built with support for this database by default.
</p><p>Developers can easily execute any SQL statements. Qt also provides a high-level C++ interface that can be used to generate the appropriate SQL statements automatically.
</p><p>Qt provides a set of SQL models for use with the other model/view components. These enable view widgets to be automatically populated with the results of database queries, and simplify the process of editing for both users and non-database developers.
</p><p>Using the facilities that the SQL module provides, it is straightforward to create database applications that use foreign key lookups and present master-detail relationships.
</p>
<h2><span class="mw-headline" id="Executing_SQL_Commands">Executing SQL Commands</span></h2>
<p>The <b>QSqlQuery</b> class is used to directly execute any SQL statement and navigate the result sets produced by <i><b>SELECT</b></i> statements. The <i><b>INSERT</b></i>, <i><b>UPDATE</b></i>, and <i><b>DELETE</b></i> statements are equally simple to use.
</p><p>Qt's SQL module also supports value binding and prepared queries. Value binding can be achieved using named binding and named placeholders, or using positional binding with named or positional placeholders. Qt's binding syntax works with all supported databases, either using the underlying database support or by emulation.
</p>
<h2><span class="mw-headline" id="SQL_Models">SQL Models</span></h2>
<p>Qt also provides a number of model classes for use with other components in the model/view framework. These allow the developer to set up SQL queries to automatically provide table views with items of data from a database.
</p><p>Using these database models with other components in the model/view framework requires a minimum of work for developers. Setting up a query model is simply a matter of specifying a query and choosing which headers to examine, and setting up a table view to display the results of the query is similarly straightforward.
</p><p>Models are provided for accessing SQL tables in different ways. These include a read-only data model for SQL result sets, an editable data model for a single database table, and a relational model that allows columns to be set as foreign keys into other database tables. The Qt Books demonstration shown in Figure uses a relational database model to find information about each of the books in a table.
</p><p>The model/view framework contains a number of features that accommodate the requirements of database applications. These include support for transactions and the option to allow the contents of table to be edited on a per-row basis to avoid unnecessary round trips to a database.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/books-demo.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/books-demo.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/books-demo.png</a>
</p><p><i>The Qt Books demonstration shows the integration between Qt's SQL classes and the model/view framework.</i>
</p>
<h2><span class="mw-headline" id="Data-Aware_Widgets">Data-Aware Widgets</span></h2>
<p>Qt provides facilities to allow data obtained from models, such as the SQL models described above, to be related to specific widgets in a window, allowing the user to see a cross-section of the data available from different locations in the underlying data store. This makes it easier to create data-entry applications with conventional form-based user interfaces.
</p><p>The <b>QDataWidgetMapper</b> class is used to set up the mapping between a model and a selection of widgets. In the Books demonstration supplied with Qt (see above), a data mapper is constructed and assigned to a model, then each of the widgets used to edit fields in the database is mapped to a column.
</p><p>The data mapper can be used directly to step through rows in a model, mapping the item in each column to a specific widget, and using it to display the data obtained. Navigation functions make it simple to connect easy-to-use navigation controls to the mapper.
</p><p>Since the class also provides a similar API to the item view classes, different cross-sections of a model can be obtained by changing the mapper's configuration. The use of the model/view API also makes it possible for a data mapper to respond to changes to the underlying model. The Books demonstration updates the mapping whenever the user selects a different row in a table view; this behavior is set up with a simple signal-to-slot connection.
</p>
<h3><span class="mw-headline" id="Online_References_9">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtsql-index.html">QtSql Module</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-4.8/qt4-sql.html">The Qt 4 Database GUI Layer</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/examples-sql.html">SQL Examples</a>
</p>
<h1><span class="mw-headline" id="Internationalization">Internationalization</span></h1>
<p><i>Qt fully supports Unicode, the international standard character set. Programmers can freely mix Arabic, English, Hebrew, Japanese, Russian, and other languages supported by Unicode in their applications. Qt also includes tools to support application translation and localization.</i>
</p><p>Qt supports the Unicode version 5.0 character encoding and uses the <b>QString</b> class to store Unicode strings, both for the API and internally.
</p><p>An extensible set of text codecs provide support for different encodings and charsets, including Big5 and GBK for Chinese, EUC-JP, JIS, and Shift-JIS for Japanese, KOI8-R for Russian, and the ISO-8859 series of standard encodings^1. Qt uses text codecs for fonts, input-output, and input methods.
</p><p>Built-in locale support enables number-to-string and string-to-number conversions to be adapted to suit the user's geographical location and language preferences.
</p><p>Qt includes a set of tools to facilitate the translation process that support XML Localization Interchange File Format (XLIFF), GNU Gettext PO format and Qt's Translation Source (TS) files.
</p>
<h2><span class="mw-headline" id="Text_Entry_and_Rendering">Text Entry and Rendering</span></h2>
<p>Far-Eastern writing systems require many more characters than are available on a keyboard. The conversion from a sequence of key presses to actual characters is performed at the window-system level by software called <i>input methods</i>. Qt automatically supports the installed input methods on a user's system.
</p><p>Qt provides a powerful text-rendering engine for all on-screen text, supporting advanced features such as special line breaking behavior, bidirectional writing, and diacritical marks. It renders most of the world's writing systems, including Arabic, Chinese, Cyrillic, English, Greek, Hebrew, Japanese, Korean, Latin, and Vietnamese. Qt will automatically combine the installed fonts to render multi-language text.
</p>
<h2><span class="mw-headline" id="Translating_Applications">Translating Applications</span></h2>
<p>Qt provides tools and functions to help developers provide applications in their users' native languages. Qt itself contains about several hundred user-visible strings, for which Qt Development Frameworks provides French, German and Simplified Chinese translations.
</p><p>To make strings translatable, developers simply wrap them in calls to the <i><b>tr()</b></i> translation function, and can supply additional information to human translators with special C and C++ comments.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="co1">//: This name refers to a host name.</span>
hostNameLabel<span class="sy0">-&gt;</span><span class="me3">setText</span><span class="br0">&#40;</span>tr<span class="br0">&#40;</span><span class="st0">&quot;Name:&quot;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="coMULTI">/*: This text refers to a C++ code example. */</span>
<span class="kw5">QString</span> example <span class="sy0">=</span> tr<span class="br0">&#40;</span><span class="st0">&quot;Example&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>Along with the context, this comment information helps translators to accurately translate user-visible strings. Optional arguments can also be used to help with the translation of plural forms.
</p><p>Qt provides tools to extract user-visible source texts from files in Qt projects, convert between common translation file formats, and generate compressed message files for use in applications. The process of extracting source texts and updating partially-complete translations is integrated into the build system for Qt applications, and can be modified to suit different translation workflows.
</p><p>At run-time, applications use <b>QTranslator</b> objects to load translation files. Each file contains the translations for a particular language. The language can be chosen at run-time, in accordance with the locale or user preferences.
</p><p>Translators can edit translation files conveniently using <i>Qt Linguist</i>, a GUI application for performing translation work. The contexts are listed in the left-hand side of the application's window, and the list of source texts for the current context is displayed in the top-right area, along with translations and their current states (unfinished, obsolete, done). The user interface can be navigated via the keyboard; its dockable windows can be reorganized to suit the translators' preferences.
</p><p>Applications often use the same phrases many times in different source texts. <i>Qt Linguist</i> automatically displays intelligent guesses based on previously translated strings and predefined translations; these often serve as a good starting point for new translations. Common translations can also be stored in phrasebooks to make the translation of future applications more efficient. <i>Qt Linguist</i> can optionally validate translations to ensure that accelerators and ending punctuation are translated correctly.
</p><p><i>Qt Linguist'</i>s comprehensive manual provides relevant information about the translation process for release managers, translators, and programmers.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qt-linguist.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qt-linguist.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qt-linguist.png</a>
</p><p><i>Working on French and Simplified Chinese translations simultaneously with Qt Linguist.</i>
</p>
<h3><span class="mw-headline" id="Online_References_10">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/i18n.html">Qt Classes for Internationalization</a> <a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtlinguist-index.html">Qt Linguist Manual</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/unicode.html">Unicode in Qt</a> <a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/qtextcodec.html">QTextCodec Class Reference</a>
</p>
<h1><span class="mw-headline" id="Qt_Script">Qt Script</span></h1>
<p><i>Qt Script is an interpreted ECMAScript-based language which can be used to script Qt applications. The QtScript module provides an API that makes it easy to expose parts of an application to the scripting environment, including support for signals-slot communication and other standard Qt features.</i>
</p><p>Application scripting allows users to customize and extend the features of applications by accessing simple APIs for user-oriented scripting languages. Traditionally, Qt developers have used a variety of separate solutions to provide scripting support in their applications. The inclusion of Qt Script as a Qt module is intended to reduce the amount of effort required to implement scripting, while also making the process easier for developers who simply require scripting "out of the box".
</p>
<h2><span class="mw-headline" id="Scripting_Architecture">Scripting Architecture</span></h2>
<p>The QtScript module provides an API based around the <b>QScriptEngine</b> and <b>QScriptValue</b> classes. These provide execution and data marshalling facilities.
</p><p>Instances of <b>QScriptEngine</b> are responsible for executing Qt Script code within a scripting environment and provide facilities to expose instances of <b>QObject</b> subclasses to this environment. Additionally, <b>QScriptEngine</b> allows C++ data types to be converted to their Qt Script equivalents and inserted into the scripting environment. Qt Script data types are represented in C++ as <b>QScriptValue</b> instances which provide functions to convert data to C++ types.
</p><p>Additionally, signals and slots can be used to communicate between Qt Script and applications. Qt Script objects can emit the signals of the objects they wrap, and any Qt Script function can be used as a slot. This provides the additional level of flexibility that script authors require and expect from a dynamic scripting language.
</p><p>The simplest use of the QtScript module is to provide an interpreter for Qt Script that executes user-defined code.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw5">QScriptEngine</span> engine<span class="sy0">;</span>
<span class="kw5">QScriptValue</span> result <span class="sy0">=</span> engine.<span class="me1">evaluate</span><span class="br0">&#40;</span>userCode<span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>The <b>QScriptEngine</b> instance is also able to provide information about any syntax and run-time errors that occur.
</p><p>In the above image, we can see the use of the QtScript module's features for integrating Qt Script into an application. A <b>QObject</b>-based wrapper for an image, providing a variety of functions and properties, is exposed to the scripting environment in the following way:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">image <span class="sy0">=</span> <span class="kw1">new</span> ImageWrapper<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw5">QScriptValue</span> imageObject <span class="sy0">=</span> engine.<span class="me1">newQObject</span><span class="br0">&#40;</span>image<span class="br0">&#41;</span><span class="sy0">;</span>
engine.<span class="me1">globalObject</span><span class="br0">&#40;</span><span class="br0">&#41;</span>.<span class="me1">setProperty</span><span class="br0">&#40;</span><span class="st0">&quot;image&quot;</span><span class="sy0">,</span> imageObject<span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>Once defined in the environment, the user can manipulate the image using a simplified API that hides all the low-level details of managing the application's user interface.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qtscript-debugger.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qtscript-debugger.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qtscript-debugger.png</a>
</p><p><i>Debugging a function using the Qt Script debugger's user interface.</i>
</p>
<h2><span class="mw-headline" id="Debugging">Debugging</span></h2>
<p>Support for debugging of scripts is provided by the QtScriptTools module, which includes a set of integrated graphical components that developers can use when creating scriptable applications.
</p><p>The <b>QScriptEngineDebugger</b> class has been designed to be simple to use. The separation between the implementation of the debugger and the script engine means that the process of attaching a debugger is simple and non-invasive; code that attaches the debugger to a script engine is self-contained and can be removed when no longer required.
</p><p>The debugger provides a set of common debugging widgets that show source code, breakpoints, the contents of variables, and other useful information about the script that is being executed. These can be used together in a standard window (see Figure ) or as separate widgets.
</p><p>In addition to these widgets, the debugger also provides a standard menu and toolbar that can be used separately to create a custom debugging interface. The toolbar contains a set of buttons that are linked to actions (see sub:Actions ) which can be triggered programmatically to control the execution of scripts.
</p><p>If preferred, the debugger can be used without showing any of the user interface components; the developer has the option of keeping these hidden until an error occurs or a breakpoint is encountered.
</p><p>A comprehensive user manual documents how to use the debugger's user interface, and contains information on the commands that can be entered at the debugging console.
</p>
<h3><span class="mw-headline" id="Online_References_11">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-4.8/qtscript.html">QtScript Module</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-4.8/qtscripttools.html">QtScriptTools Module</a>
</p>
<h1><span class="mw-headline" id="Styles_and_Themes">Styles and Themes</span></h1>
<p><i>Qt automatically uses the native desktop style for an application's look and feel. Qt applications respect user preferences for colors, fonts, sounds, and other desktop settings. Qt programmers are free to use any of the supplied styles and can override any preferences. Programmers can modify existing styles or implement their own styles using Qt's powerful style engine.</i>
</p><p>A style implements the "look and feel" of the user interface on a particular platform. A style is a <b>QStyle</b> subclass that implements basic drawing functions such as drawing frames, buttons, and images. Qt performs all the widget drawing itself for maximum speed and flexibility.
</p>
<h2><span class="mw-headline" id="Built-in_Styles">Built-in Styles</span></h2>
<p>Qt provides the following built-in styles: CDE, Cleanlooks, GTK, Motif, Mac OS X, Plastique, Windows, Windows XP, and Windows Vista. By default, Qt uses the appropriate style for the user's platform and desktop environment. The style can also be chosen programmatically by the application developer, or by the user with the <i>-style</i> command line option.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qstyle-comboboxes.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qstyle-comboboxes.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qstyle-comboboxes.png</a>
</p><p><i>Combo boxes in the different native styles.</i>
</p><p>A style is complemented by the user's desktop settings, which include the user's preferences for colors, fonts, sounds, etc. Qt automatically adapts to the computer's active theme. For example, Qt supports scroll and fade transition effects for menus and tooltips.
</p><p>The Windows and Mac OS X styles are built on top of native style managers, and are available only on their respective platforms. The other styles are emulated by Qt and are available everywhere.
</p><p>The default styles on many modern X11 platforms are <i>Plastique</i>, a style inspired by the Plastik widget style for KDE, and <i>GTK</i>, which uses the GTK+ theme engine on GNOME desktops. An alternative style for GTK-based environments is Cleanlooks, a style designed to look like the Clearlooks theme for GNOME.
</p><p>Qt's built-in widgets are style-aware. Custom widgets and dialogs are almost always combinations of built-in widgets and layouts, and automatically adapt to the style in use. On the rare occasions when it is necessary to write a custom widget from scratch, developers can use Qt's style API to draw basic user-interface elements rather than drawing raw graphics primitives directly.
</p><p>Based on the translation file loaded, Qt applications automatically use right-to-left widget layouts rather than the default left-to-right scheme normally used. Additionally, when used in reversed mode, well-behaved styles render widgets with areas of light and shadow that are appropriate for the user's desktop environment.
</p>
<h2><span class="mw-headline" id="Widget_Style_Sheets">Widget Style Sheets</span></h2>
<p>Qt supports the use of widget style sheets with almost all standard widgets. These textual descriptions, written in a language similar to Cascading Style Sheets (CSS), are used to customize the appearance of widgets in much the same way that CSS descriptions are used to customize HTML rendering in WWW browsers. Each widget's style sheet is accessed via its <i><b>styleSheet</b></i> property, available in <b>QWidget</b> and its subclasses, and this enables customizations to be easily applied to style-aware widgets while an application is running. Since this property is also available for editing in <i>Qt Designer</i>, graphic designers can directly influence the look and feel of applications. For many common situations where customizations to standard widgets are required, the use of style sheets can eliminate the need for a custom style to be written.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-coffee.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-coffee.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-coffee.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-pagefold.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-pagefold.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/stylesheets-pagefold.png</a>
</p><p><i>The Style Sheet example allows interactive experiments with style sheets.</i>
</p>
<h2><span class="mw-headline" id="Custom_Styles">Custom Styles</span></h2>
<p>Custom styles are used to provide a distinct look to an application or family of applications. Custom styles can be defined by subclassing <b>QStyle</b> or any of its subclasses. It is easy to make small modifications to existing styles by reimplementing one or two virtual functions from the appropriate base class.
</p><p>The style API provides information about each of the constituent components used to draw widgets, making it possible for highly customized styles to be created and fine-tuned.
</p><p>A style can also be compiled as a plugin. Plugins make it possible to preview a form using a custom style in <i>Qt Designer</i> without recompiling either Qt or <i>Qt Designer</i> itself. The style of an existing Qt application can be changed using a style plugin without recompiling the application. This enables applications like the Qt Styles example and the <i>qtconfig</i> tool to switch styles on-the-fly to provide previews for each of the available styles.
</p>
<h3><span class="mw-headline" id="Online_References_12">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/widgets-styles.html">Qt Widget Style Gallery</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/stylesheet.html">Qt Style Sheets</a>
</p>
<h1><span class="mw-headline" id="Input.2FOutput_and_Networking">Input/Output and Networking</span></h1>
<p><i>Qt can load and save data in plain text, XML, and binary formats. Qt handles local files using its own classes, and remote files using the FTP and HTTP protocols. Inter-process communication and socket-based TCP and UDP networking are fully supported, and information about the network interfaces available can be easily obtained.</i>
</p>
<h2><span class="mw-headline" id="File_Handling">File Handling</span></h2>
<p>At the heart of Qt's device handling infrastructure is <b>QIODevice</b>, a general base class for files, sockets and other devices, which can be subclassed to add support for custom devices. All devices are able to communicate using signals and slots, making it straightforward to integrate file and network communications into applications.
</p><p>The <b>QFile</b> class supports large files, long file names, and internationalized file names. The <b>QDir</b> and <b>QDirIterator</b> classes are used to read and traverse directories, and can be used to manipulate path names, create directories, delete files, and perform other common operations. <b>QFileInfo</b> provides more detailed information about a file, such as its size, permissions and last modification time.
</p><p>Qt includes classes similar to the standard iostream classes that operate on any device. Classes for text and raw data streams are used to stream text to and from devices, and these support the encodings provided by <b>QTextCodec</b>. Data streams can be used to serialize basic C++ types and many Qt types in a platform-independent binary format.
</p><p>Transparent access to remote files is provided via a unified network access API, though specialized classes for HTTP and FTP protocols can also be used if required, building on Qt's networking classes (see page) . URLs can easily be parsed and reconstructed by using the <b>QUrl</b> class.
</p><p>Some types of file can be read directly without requiring the use of a <b>QFile</b> object. For example, image files are usually read via the <b>QImage</b> class with its extensible plugin mechanism. Printing text and images is handled by <b>QPrinter</b>.
</p><p>Qt can also be used to monitor files and directories for changes made by other applications and services. The <b>QFileSystemWatcher</b> class acts as a registry of file paths that need to be monitored, and emits a signal whenever a file or directory on any of these paths is changed.
</p>
<h2><span class="mw-headline" id="XML">XML</span></h2>
<p>Qt's XML module provides a SAX parser and a DOM parser, both of which read well-formed XML and are non-validating. The SAX (Simple API for XML) implementation follows the design of the SAX2 Java implementation, with adapted naming conventions. The DOM (Document Object Model) Level 2 implementation follows the W3C recommendation and includes namespace support.
</p><p>Qt's stream reading and writing classes present an alternative approach to reading and writing XML files in which tokens are "pulled" from an input stream and "pushed" to an output stream. The design of these classes makes it easy to write lightweight, high-level parsers for XML-based file formats.
</p><p>Higher level XML manipulation, including support for XQuery 1.0 and XPath 2.0, is provided by an additional module. This separation between basic XML handling and more powerful querying facilities allows developers to decide the level of XML support used in applications. Partial support for XSLT 2.0 adds another processing option for developers familiar with common XML technologies.
</p><p>Validation of XML documents is performed by classes representing XML schemas and validators for those schemas. These implement the W3C XML Schema specification as specified by version 1.0 of the standard.
</p>
<h2><span class="mw-headline" id="Inter-Process_Communication">Inter-Process Communication</span></h2>
<p>Qt provides a process class that is used to start external programs and to communicate with them in a platform-independent way. Communication is achieved by writing to the external program's standard input and reading from its standard output and standard error streams. The <b>QProcess</b> class is derived from <b>QIODevice</b>, meaning that data can be streamed to and from it with text and data streams.
</p><p><b>QProcess</b> works asynchronously, reporting the availability of data by emitting signals. Qt applications can connect to the signals to retrieve the data for processing, and optionally respond by sending data back to the external program. Qt's process handling also supports a blocking mode of operation, and can redirect input and output from external programs to files.
</p><p>Additionally, higher-level communication between applications, components and the operating system can be achieved on Unix platforms that support the D-Bus protocol. The QtDBus module allows applications to expose services by creating XML-based interface files. These are converted to C++ source code by a tool supplied with Qt.
</p><p>Access to low-level shared resources, such as shared memory and system semaphores, is provided by dedicated classes. These provide the basis for building alternative communication mechanisms.
</p>
<h2><span class="mw-headline" id="Networking">Networking</span></h2>
<p>Qt provides a cross-platform interface for writing TCP/IP clients and servers, supporting IPv4 and IPv6. All of the networking classes provided are reentrant and can be used from any thread.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/ftp-example.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/ftp-example.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/ftp-example.png</a>
</p><p><i>The Qt FTP example uses Qt's networking features to provide simple FTP browsing capabilities.</i>
</p><p>The <b>QTcpSocket</b> class provides an asynchronous, buffered TCP connection. As with other <b>QIODevice</b> subclasses, text and data streams can be used to handle socket-level communications. Similarly, <b>QUdpSocket</b> handles UDP socket operations. Both classes support blocking and non-blocking modes of operation. All of Qt's networking classes are reentrant and can be used from any thread.
</p><p>Custom TCP servers can be implemented by subclassing <b>QTcpServer</b>, which provides an asynchronous framework for handling incoming connections and serving clients. Servers can operate in blocking and non-blocking modes.
</p><p>Support for proxy servers is available through the <b>QNetworkProxy</b> class, enabling both application-wide and per-socket proxying facilities. HTTP, FTP and SOCKS 5 proxy types are supported, and caching facilities can be employed to improve performance. Customization features enable an application-wide policy to be employed that can set up proxies based on the socket type, the protocol in use, and other criteria.
</p><p>The <b>QAbstractSocket</b> class is a platform-independent wrapper for native socket APIs. It provides the underlying functionality for TCP, UDP and local domain sockets. Support for proxy servers is available through the <b>QNetworkProxy</b> class, enabling both application-wide and per-socket proxying facilities.
</p><p>A management infrastructure for network operations is provided in the form of <b>QNetworkAccessManager</b>, which is used to dispatch requests over common protocols, such as HTTP and FTP, and handle replies. Specific classes for requests and replies make common communication easy, while allowing the developer to customize particular requests.
</p><p>Information about a machine's network interfaces is provided by the <b>QNetworkInterface</b> class. This exposes details of each interface, their capabilities, the IP addresses assigned to them, and other interface-dependent information. For example, for Ethernet interfaces, the MAC address of the underlying hardware can be obtained, and the broadcast address and netmask can be obtained in addition to the IP address.
</p>
<h3><span class="mw-headline" id="Encrypted_Communications">Encrypted Communications</span></h3>
<p>Qt includes features for secure network communications through the use of encrypted TCP connections based on Secure Socket Layer (SSL) protocols, including SSLv3 and TLSv1.
</p><p><b>QSslSocket</b> provides an SSL encrypted socket that can be used for both clients and servers. Abstractions for other aspects of the encryption and authentication processes are addressed by classes for ciphers, keys, certificates.
</p>
<h3><span class="mw-headline" id="Online_References_13">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/qiodevice.html">QIODevice Class Reference</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtxml-index.html">QtXml Module</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtnetwork-index.html">QtNetwork Module</a>
</p>
<h1><span class="mw-headline" id="Collection_Classes">Collection Classes</span></h1>
<p><i>Collection classes are used to store groups of items in memory. Qt provides a set of classes that are compatible with the Standard Template Library (STL), and that work regardless of whether the compiler supports STL or not. Java-style iterators are also provided for safety and convenience.</i>
</p><p>Applications often need to manage items in memory, such as groups of images, widgets, or custom objects. Many C++ compilers support the STL, which provides ready-made data structures for storing items. Qt provides lists, stacks, queues, and dictionaries with STL-syntax. Qt's collection classes even work with compilers that are not capable of supporting the STL.
</p><p>Qt's rich set of portable collection classes ("containers") and associated iterators are heavily used inside Qt, and are provided as part of the Qt API. Qt's containers are optimized for speed and memory efficiency. Programmers can also use STL containers on the platforms that support them, at the cost of losing Qt's optimizations.
</p><p>Unlike many template classes, which increase the size of executables dramatically when used, Qt's template collection classes are optimized for minimal code expansion.
</p>
<h2><span class="mw-headline" id="Containers">Containers</span></h2>
<p>Qt provides sequential container classes for lists, linked lists, vectors, stacks and queues, each with an interface very similar to the corresponding STL container, and each fully compatible with the STL algorithms. Qt provides some STL-equivalent algorithms for copying, finding and sorting items. On platforms with STL support, Qt provides automatic conversion operators between STL and Qt containers.
</p><p>Additionally, Qt provides Java-style iterators for developers who are more familiar with Java containers than the STL.
</p><p>Qt provides associative container classes for maps, hashes and sets. The "hash" containers use a hash function to improve search performance. One-to-one and one-to-many variants of the map and hash containers are available.
</p><p>Qt's sequential and associative collection classes can be used to store both value-based and pointer-based types, making them especially useful for handling <b>QWidget</b> and <b>QObject</b> pointers. When used to hold pointer-based items, convenience functions can be used to delete the contents of collections in one pass before the collection is destroyed.
</p>
<h2><span class="mw-headline" id="Implicit_Sharing">Implicit Sharing</span></h2>
<p>When used with Qt's value classes, the items held in these collection classes are implicitly shared ("copy on write"). Copies of these classes share the same data in memory. The data sharing is handled automatically; if the application modifies the contents of one of the copied objects, a deep copy of the data is made so that the other objects are left unchanged. When an object is copied, only a pointer is passed and a reference count incremented, which is much faster than actually copying the data, and also saves memory.
</p><p>Sharing is used wherever it makes sense: in Qt's value-based collection classes, and in other commonly-used classes. Programmers can safely and efficiently copy objects of these classes by value, avoiding the risks related to optimizing pointer-based code by hand. In particular, the implicitly shared <b>QString</b> and <b>QRegExp</b> classes makes string processing easy and fast.
</p><p>Qt also provides low-level bit and byte array classes which are very efficient for handling basic data types.
</p>
<h3><span class="mw-headline" id="Online_References_14">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/containers.html">Container Classes</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/implicit-sharing.html">Implicit Sharing</a>
</p>
<h1><span class="mw-headline" id="Plugins_and_the_Meta-Object_System">Plugins and the Meta-Object System</span></h1>
<p><i>Qt applications can access functions from dynamic libraries using a platform-independent API. Qt also supports plugins, allowing developers to create and distribute codecs, database drivers, image format converters, styles, and custom widgets as separate components.</i>
</p>
<h2><span class="mw-headline" id="Plugins_and_Libraries">Plugins and Libraries</span></h2>
<p>Converting a Qt component into a plugin is achieved by subclassing the appropriate plugin base class, implementing a few simple functions, and adding a macro. Plugins written in this way can expose properties and interact with applications via the signals and slots mechanism.
</p><p>Components supplied as plugins are detected and used by the application automatically. Many third parties provide Qt components in source form, as precompiled dynamic libraries, and as plugins.
</p><p>The <b>QLibrary</b> class provides a cross-platform API for loading dynamic libraries, providing a type-safe way to call functions exported as symbols with C linkage.
</p>
<h2><span class="mw-headline" id="The_Meta-Object_System">The Meta-Object System</span></h2>
<p>The meta-object system enhances Qt components with additional data at compile-time in order to provide extended run-time type information and other dynamic features. This approach makes it possible for Qt to provide features such as run-time object introspection, a translation mechanism for internationalization purposes, signals and slots, and a generic way to invoke functions and methods.
</p><p>The use of a richly-typed object system makes it possible for applications to be scripted using Qt Script or any other programming language solution that is integrated with the meta-object system.
</p><p>As mentioned above, these features can also be exposed by plugins to applications and vice versa.
</p>
<h3><span class="mw-headline" id="Online_References_15">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/plugins-howto.html">How to Create Qt Plugins</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/metaobjects.html">The Meta-Object System</a>
</p>
<h1><span class="mw-headline" id="Building_Qt_Applications">Building Qt Applications</span></h1>
<p><i>Qt developers can take advantage of a suite of tools to simplify the process of building applications on all supported platforms. Applications, libraries, and plugins are described by project files that are processed to produce suitable Makefiles for each platform.</i>
</p><p>Qt is designed to work with a range of development tools and environments, from simple command line tools to integration with popular integrated development environments (IDEs). Alternatively, Qt Creator (see page) is a lightweight, cross-platform IDE that is specifically tailored to development of Qt applications.
</p>
<h2><span class="mw-headline" id="Qt.27s_Build_System">Qt's Build System</span></h2>
<p>Projects are described by project files that contain terse, but readable descriptions of source and header files, <i>Qt Designer</i> forms, and other resources. These are processed by the <a href="http://wiki.qt.io/index.php?title=Qmake&amp;action=edit&amp;redlink=1" class="new" title="Qmake (page does not exist)">qmake</a> tool to produce suitable Makefiles for the project on each platform.
</p><p>All of the Qt libraries, tools, and examples are described by project files. A simple example can be described in a few lines of declarations.
</p><p>Support for conditional builds means that platform-specific code can be incorporated into projects, and will only be built for the appropriate platform.
</p><p>When <i>qmake</i> is used to build a project, all the enhanced features of Qt are automatically handled by the other tools in the build suite: <i>moc</i> processes the header files to enable signals and slots, <i>rcc</i> compiles the specified resources, and <i>uic</i> is used to create code from user interface forms created with <i>Qt Designer</i>.
</p><p>Precompiled header support, <i>pkg-config</i> integration, the ability to generate Visual Studio project files, and other advanced features allow developers to take advantage of platform-specific tools while retaining the use of a cross-platform build system for common project components.
</p>
<h2><span class="mw-headline" id="Qt.27s_Resource_System">Qt's Resource System</span></h2>
<p>Qt provides a resource system that allows data files to be stored inside executables, so that any resources required by applications can be accessed at run-time. Qt's widgets support a naming scheme that allows developers to directly refer to these packaged resources.
</p><p>The resources to be packaged with an application are listed in a Qt Resource Collection file, containing a list of files in the build directory along with the resource paths that are used in the application. These files are processed using <i>rcc</i> to create data that is compiled into the application. This approach ensures that certain critical resources are always available to applications, avoiding possible distribution and installation problems.
</p><p>The resource system can also be extended at run-time with the <b>QResource</b> class, allowing additional paths to be searched for resources, and enabling additional resources to be loaded on demand, augmenting those built into the application.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qt-creator-overview.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qt-creator-overview.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/qt-creator-overview.png</a>
</p><p><i>An overview of Qt Creator.</i>
</p>
<h2><span class="mw-headline" id="Testing_and_Benchmarking_Qt_Applications">Testing and Benchmarking Qt Applications</span></h2>
<p>Support for unit testing is provided as a standard Qt module. Unit tests are written in C++ as <b>QObject</b>-based classes that contain test functions, and these are compiled into executables that can be run independently of any testing framework. Qt's unit testing library also provides extensions to allow graphical user interfaces to be tested.
</p><p>Unit tests can also be set up to perform benchmarking operations with the use of a simple macro. Test cases can be configured to measure and report performance via the use of different backends, allowing performance data to be visualized using standard tools.
</p>
<h2><span class="mw-headline" id="Qt_Creator">Qt Creator</span></h2>
<p>Qt Creator is Qt Development Frameworks's lightweight IDE for C++ and Qt software development. Although it is designed to be easy to use, Qt Creator provides all the features developers have come to expect from IDEs, including syntax coloring and code completion, quick location of classes, functions and other C++ structures, and integrated debugging support.
</p><p>Qt-specific features include signals and slots signature completion, integrated support for Qt Designer, and built-in Qt documentation. The <a rel="nofollow" class="external text" href="http://wiki.qt.io/QtCreatorWhitepaper">Qt Creator whitepaper</a> contains a more detailed introduction to this product.
</p>
<h3><span class="mw-headline" id="Online_References_16">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/qmake-manual.html">qmake Manual</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qttest-index.html">QTestLib Manual</a>
</p>
<h1><span class="mw-headline" id="Qt.27s_Architecture">Qt's Architecture</span></h1>
<p><i>Qt's functionality is built on the low-level APIs of the platforms it supports. This makes Qt flexible and efficient, and enables Qt applications to fit in with single-platform applications.</i>
</p><p>Qt is a cross-platform framework which uses native style APIs to accurately follow the human interface guidelines on each supported platform. All widgets are drawn by Qt, and programmers can extend or customize them by reimplementing virtual functions. Qt's widgets accurately emulate the look and feel of the supported platforms, as described in sec:Styles-and-Themes (see page). This technique also enables developers to derive their own custom styles to provide a distinct look and feel for their applications.
</p><p>Qt uses the low-level APIs of the different platforms it supports. This differs from traditional "layered" cross-platform toolkits that are thin wrappers over single-platform toolkits (e.g., MFC on Windows and Motif on X11). Layered toolkits are usually slow, since every function call to the library results in many additional calls down through the different API layers. Layered toolkits are often restricted by the features and behavior of the underlying toolkits, leading to obscure bugs in applications.
</p><p>Qt is professionally supported, and takes advantage of the available platforms: Microsoft Windows, X11, Mac OS X, and Embedded Linux. Using a single source tree, a Qt application can be compiled to an executable for each target platform. Although Qt is a cross-platform framework, customers have found it to be easier to learn and more productive than many platform-specific toolkits. Many customers use Qt for single-platform development, preferring Qt's fully object-oriented approach.
</p>
<h2><span class="mw-headline" id="X11">X11</span></h2>
<p>Qt for X11 uses Xlib to communicate with the X server directly. Qt does not use Xt (X Toolkit), Motif, Athena, or any other toolkit.
</p><p>Qt supports the following versions of Unix: AIX (R), FreeBSD®, HP-UX, Linux, NetBSD, OpenBSD, and Solaris. See the Qt Development Frameworks Web site for an up-to-date list of supported compilers and operating system versions.
</p><p>Qt applications automatically adapt to the user's window manager or desktop environment, and have a native look and feel under Motif, CDE, GNOME (TM), and KDE (TM). This contrasts with most other Unix toolkits, which lock users into their own look and feel.
</p><p>Qt provides full Unicode support (see page). Qt applications automatically support both Unicode and non-Unicode fonts. Qt combines multiple X fonts to render multi-lingual text. Qt's font handling is intelligent enough to search all the installed fonts for characters unavailable in the current font.
</p><p>Qt takes advantage of X extensions where they are available. Qt supports the RENDER extension for anti-aliased and alpha-blended fonts and vector graphics. Qt provides on-the-spot editing for X Input Methods. Qt supports multiple screens both with traditional multi-head and with Xinerama.
</p>
<h2><span class="mw-headline" id="Microsoft_Windows">Microsoft Windows</span></h2>
<p>Qt for Windows uses the Win32® API and GDI for low-level events and drawing. Qt does not use MFC or any other toolkit, but provides its own more powerful, customizable widgets that are rendered using a fast, yet accurate painting engine. (For non-specialized uses, Qt uses the native Windows file and print dialogs.)
</p><p>Customers using Windows can create Qt applications using Microsoft Visual Studio that will run on Windows 98, NT4, ME, 2000, XP and Vista. Qt performs a run-time check for the Windows version, and uses the most advanced capabilities available. Qt developers are insulated from differences in the Windows APIs.
</p><p>The Microsoft accessibility interfaces are supported by Qt. Unlike the common controls on Windows, Qt widgets can be extended without losing the accessibility information of the base widget. Custom widgets can also provide accessibility. Qt also supports multiple screens on Microsoft Windows.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/architecture-diag.png" class="new" title="File:Http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/architecture-diag.png">http://doc.qt.digia.com/whitepapers/qt-whitepaper/wiki-images/architecture-diag.png</a>
</p><p><i>An overview of Qt's architecture on supported desktop platforms.</i>
</p>
<h2><span class="mw-headline" id="Mac_OS_X">Mac OS X</span></h2>
<p>Qt supports Mac OS X by using a combination of Cocoa® and Carbon® APIs. On 64-bit hardware, Qt uses the Cocoa libraries to enable integration with Mac OS X native widgets and Cocoa views.
</p><p>Qt for Mac OS X introduces layouts and straightforward internationalization support, standardized access to OpenGL, and powerful visual design with <i>Qt Designer</i>. Qt handles files and asynchronous socket input/output in the event loop. Qt provides solid database support. Developers can create Mac OS X applications using a modern object-oriented API that includes comprehensive documentation and full source code.
</p><p>Developers can create applications on their favorite platform and broaden their market hugely by simply recompiling on the other supported platforms. Support for universal binaries on Mac OS X means that Qt applications can be created for Intel and PowerPC-based Macs. If desired, developers can take advantage of Qt's integration with native components to add platform-specific features to their applications.
</p>
<h3><span class="mw-headline" id="Online_References_17">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/supported-platforms.html">Supported Platforms</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-4.8/installation.html">Qt 4.8 Installation</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5.5/deployment.html">Deploying Qt Applications</a>
</p>
<h1><span class="mw-headline" id="Platform_Specific_Extensions_and_Qt_Solutions">Platform Specific Extensions and Qt Solutions</span></h1>
<p><i>In addition to being complete in itself, Qt provides some platform-specific extensions to assist developers in certain contexts. The ActiveQt extension allows developers to use ActiveX controls within their Qt applications, and also allows them to make their Qt applications into ActiveX servers. Other platform-specific extensions are made available through Qt Solutions.</i>
</p>
<h2><span class="mw-headline" id="ActiveX_Interoperability">ActiveX Interoperability</span></h2>
<p>ActiveX is built on Microsoft's COM technology. It allows applications and libraries to use components provided by component servers, and to be component servers in their own right. Qt for Windows provides the ActiveQt module that allows developers to turn their applications into ActiveX servers, and to make use of the ActiveX controls provided by other applications.
</p><p>Integration with Microsoft's .NET (TM) technology is also possible with ActiveQt. Applications can use ActiveQt's COM support to automatically give .NET developers access to Qt widgets and data types.
</p><p>ActiveQt seamlessly integrates ActiveX into Qt: ActiveX properties, methods, and events become Qt properties, slots, and signals. This makes it straightforward for Qt developers to work with ActiveX using a familiar programming paradigm, and insulates them from all the different kinds of generated code that is normally part of an ActiveX implementation.
</p><p>ActiveQt automatically handles the conversions between ActiveX and Qt data types. ActiveQt supports the <i><b>dynamicCall()</b></i> function to control an ActiveX component through the control's <b>IDispatch</b> interface implementation.
</p><p>Turning a Qt application into an ActiveX server is simple. If we only need to export a single class, little more is required than the inclusion of a single header file. Once the class is compiled, its properties, slots, and signals become ActiveX properties, methods, and events to ActiveX clients. ActiveQt also provides facilities to determine if the application is being run in its own right or being used as an ActiveX control, so that developers can control which functionality is available in which context.
</p>
<h2><span class="mw-headline" id="Qt_Solutions">Qt Solutions</span></h2>
<p>In addition to all the classes supplied with Qt, Qt Development Frameworks also produces Qt Solutions, an optional service available to Qt licensees either at the time of purchase or as an add-on product. Qt Solutions offers a regularly updated set of components and widgets, many of which are available under the same dual licensing scheme as Qt. Almost all of the Solutions made available to Qt 3 developers are also available for Qt 4, and many new Solutions for Qt 4 have already been released.
</p>
<h3><span class="mw-headline" id="Online_References_18">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/activeqt-index.html">Qt's ActiveX Framework (ActiveQt)</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.io/qt-5/qtdbus-index.html">Qt D-Bus</a>
</p><p><a rel="nofollow" class="external free" href="http://qt.digia.com/products/appdev/add-on-products/qt-solutions">http://qt.digia.com/products/appdev/add-on-products/qt-solutions</a>
</p>
<h1><span class="mw-headline" id="The_Qt_Development_Community">The Qt Development Community</span></h1>
<p><i>Companies and independent developers from around the world are joining the Qt development community every day. They have recognized that Qt's architecture lends itself to rapid application development. These developers, whether they are targeting one or many platforms, benefit from Qt's consistent and straightforward API, powerful build system, and supporting tools such as Qt Designer.</i>
</p><p>Qt has an active and helpful user community who communicate using the <i>qt-interest</i> mailing list, the <i>Qt Centre</i> Web site at <a rel="nofollow" class="external text" href="http://www.qtcentre.org/">www.qtcentre.org</a>, and a number of other community Web sites and Weblogs. In addition, many Qt developers are active members of the <a rel="nofollow" class="external text" href="http://www.kde.org/">KDE</a> community. We publish <a rel="nofollow" class="external text" href="http://doc.qt.digia.com/qq/">Qt Quarterly</a>, an online developers' newsletter, for commercial customers and open source developers. A growing number of commercial and open source add-ons from third parties are also available; see the <a rel="nofollow" class="external text" href="http://qt.io/">Qt Project</a> site for the most up-to-date information.
</p><p>Qt's extensive documentation is available online at <a rel="nofollow" class="external free" href="http://doc.qt.io/">http://doc.qt.io</a>. There are also a number of books in English, French, German, Russian, Chinese and Japanese, that present and explain Qt programming. A number of books about Qt are described on the <a rel="nofollow" class="external text" href="http://qt.io/books">Qt Books</a> page.
</p><p>Companies participating in the Qt Project provide a range of training options for Qt and C++, including open enrollment courses for the general public and on-site courses for customers who have more specific training needs.
</p><p>As well as providing a comprehensive framework for C++ developers, Qt can also be used with a variety of other programming languages. Qt itself includes the QtScript module, a JavaScript-oriented technology that enables developers to give users access to restricted parts of their applications for scripting purposes.
</p><p>Language bindings for Python, Ruby, Java, JavaScript, BASIC, Ada 2005, C#, Pascal, Lua, Perl and Scheme are also available from third parties; many of these solutions are produced and maintained by teams of open source developers.
</p><p>Developers can evaluate Qt, with support, for 30 days on their preferred platform. For further information, visit <a rel="nofollow" class="external free" href="http://qt.digia.com/products">http://qt.digia.com/products</a>. Qt is also available under a LGPL license from <a rel="nofollow" class="external free" href="https://qt.io/download">https://qt.io/download</a>.
</p>
<h3><span class="mw-headline" id="Online_References_19">Online References</span></h3>
<p><a rel="nofollow" class="external text" href="http://qt.io/videos#c-99">Videos: Qt Training Materials</a>
</p><p><a rel="nofollow" class="external text" href="http://lists.qt-project.org/mailman/listinfo/interest">Interest Mailing List</a>
</p><p><a rel="nofollow" class="external text" href="http://doc.qt.digia.com/qq/">Qt Quarterly</a>
</p><p>This document is licensed under the <a rel="nofollow" class="external text" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-Share Alike 2.5</a> license.
</p><p><a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/share.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/share.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/share.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/remix.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/remix.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/remix.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/by.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/by.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/by.png</a> <a href="http://wiki.qt.io/index.php?title=Special:Upload&amp;wpDestFile=Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/sa.png" class="new" title="File:Http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/sa.png">http://doc.qt.nokia.com/whitepapers/qt-whitepaper/wiki-images/sa.png</a>
</p><p>For more information, see <a rel="nofollow" class="external free" href="http://creativecommons.org/licenses/by-sa/2.5/legalcode">http://creativecommons.org/licenses/by-sa/2.5/legalcode</a> for the full terms of the license.
</p><p>^1 ISO is a registered trademark of the International Organization for Standardization.
</p>
<!-- 
NewPP limit report
CPU time usage: 0.263 seconds
Real time usage: 0.533 seconds
Preprocessor visited node count: 470/1000000
Preprocessor generated node count: 614/1000000
Post‐expand include size: 1770/2097152 bytes
Template argument size: 745/2097152 bytes
Highest expansion depth: 5/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key qtio_wiki:pcache:idhash:1882-0!*!0!!en!2!* and timestamp 20151105100600 and revision id 19205
 -->
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;oldid=19205">http://wiki.qt.io/index.php?title=QtWhitepaper&amp;oldid=19205</a>"				</div>
												<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://wiki.qt.io/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="http://wiki.qt.io/Category:Articles_needing_cleanup" title="Category:Articles needing cleanup">Articles needing cleanup</a></li><li><a href="http://wiki.qt.io/index.php?title=Category:Pages_with_broken_file_links&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages with broken file links (page does not exist)">Pages with broken file links</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=QtWhitepaper" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/QtWhitepaper"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk"><span><a href="http://wiki.qt.io/Talk:QtWhitepaper"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="http://wiki.qt.io/QtWhitepaper" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/QtWhitepaper" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/QtWhitepaper" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;oldid=19205&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;oldid=19205" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=QtWhitepaper&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 23 August 2015, at 13:05.</li>
											<li id="footer-info-viewcount">This page has been accessed 4,548 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":302});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=QtWhitepaper&oldid=19205 by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 12:29:07 GMT -->
</html>
