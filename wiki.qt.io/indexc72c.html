<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/mk&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:58:33 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>View source for Getting Started Programming with QML/mk - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Getting_Started_Programming_with_QML/mk","wgTitle":"Getting Started Programming with QML/mk","wgCurRevisionId":16532,"wgRevisionId":0,"wgArticleId":2834,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Getting_Started_Programming_with_QML/mk","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Getting_Started_Programming_with_QML_mk skin-vector action-edit vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for Getting Started Programming with QML/mk</span></h1>
						<div id="bodyContent">
								<div id="contentSub">← <a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/mk" title="Getting Started Programming with QML/mk">Getting Started Programming with QML/mk</a></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in one of the groups: <a href="http://wiki.qt.io/index.php?title=Qt_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Qt Wiki:Users (page does not exist)">Users</a>, KnowledgeBase, QtWS.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Cleanup | reason=Auto-imported from ExpressionEngine.}}


= Започнување на програмирање со QML =

Добредојдовте во светот на QML, декларативниот UI јазик. Во овој почетнички водич, ќе создадеме едноставен текст едитор користејќи QML. По читањето на ова упаство, треба да бидете подготвени да развивате сопствена апликација со употреба на QML и Qt C+''.

== QML за градење на кориснички интерфејси ==
Апликацијата што ја градиме е едноставен текст едитор кој ќе вчитува, снима, и врши некаква текст манипулација. Овој водич ќе се состои од два дела. Првиот дел ќе вклучи дизајнирање на распоредот (layout) на апликацијата и однесување со користење на QML декларативниот јазик. За вториот дел, вчитување и снимање на фајлови ќе биде имплементирано со користење на Qt C. Со користење на [http://doc.qt.nokia.com/4.7/metaobjects.html Мета-Објектниот Систем], можеме да ги изложиме C''+ функциите како својства (properties) што QML елементите можат да ги користат. Со користењето на QML и Qt C+'', ние можеме ефикасно да ја одвоиме интерфејс логиката од апликациската логика.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor5_editmenu.png|QML текст едитор]]

За да се стартува QML кодот со примери, доволно е да се вклучи [http://doc.qt.nokia.com/4.7/qmlviewer.html qmlviewer] алатката заедно со QML фајлот како аргумент. C''+ делот од овој туторијал претпоставува дека читателот има основни познавања на Qt компилациските процедури.

== Дефинирање на копче и мени ==

=== Базична компонента - копче ===

Го започнуваме нашиот текст едитор со изградба на копче (button). Функционално, копчето има област сензитивна на глувче и етикета (label). Копчињата вршат дејствија кога корисникот ќе го притисне копчето.

Во QML, основниот визуелен елемент е [http://doc.qt.nokia.com/4.7/qml-rectangle.html Rectangle] елементот. ''Rectangle'' (правоаголник) елементот има својства за контрола на изгледот и локацијата на елементот.

&lt;code>
import Qt 4.7

Rectangle{
 id:simplebutton
 color: "grey"
 width: 150
 height: 80
 Text{
 id: buttonLabel
 text: "button label"
 anchors.centerIn: simplebutton;
 anchors.verticalCenterOffset: –1
 }
 }
&lt;/code>

Прво, ''import Qt 4.7'' овозможува qmlviewer алатката да импортира QML елементи кои покасно ќе ги користиме. Оваа линија мора да постои во секој QML фајл. Забележете дека верзијата на Qt модулите е ставена во импорт изјавата.

Овој едноставен правоаголник има единствен идентификатор, ''simplebutton'', кој е врзан за id својството. Својствата на ''Rect'' елементот се врзуваат на вредности со листање на својството, следено од две точки, потоа вредноста. Во ова парче код, бојата ''grey'' (сива) е врзана за својството ''color'' (боја) на правоаголникот. Слично, ги врзуваме ''width'' (ширина) и ''height'' (висина) на правоаголникот.

[http://doc.qt.nokia.com/4.7/qml-text.html Тext] елементот е текст поле без можност за едитирање. Го крстиме овој ''Text'' елемент ''buttonLabel''. За да го поставите стрингот во Текст полето, ние ја врзуваме вредноста на ''text'' својството. Етикетата е во рамките на правоаголникот и со цел да ја центрираме во средината, ние доделуваме сидра (''anchors'') на Текст елементот на неговиот родител, кој се вика ''simplebutton''. Сидрата може да се врзуваат на сидра на други елементи, дозволувајќи поедноставно доделување на распоредот.

Треба овој код да го снимиме како SimpleButton.qml. Стартувањето на qmlviewer со овој фајл како аргумент ќе прикаже сив правоаголник со текст етикета.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor1_simplebutton.png|Simple Button]]

За имплементирање на клик функционалноста на копчето, можеме да користиме QML-овото справување со настани. Справувањето со настани во QML е доста сличен на Qt-овиот механизам на сигнали и слотови. Сигналите се емитираат и поврзаниот слот е повикан.

&lt;code>
Rectangle{
 id:simplebutton
 …
 MouseArea{
 id: buttonMouseArea
 anchors.fill: parent //усидри ги сите страни на областа на глушецот на сидрата на правоаголникот
 //сигналот onClicked ги справува валидните кликови на копчињата на глушецот
 onClicked: console.log(buttonLabel.text + " clicked" )
 }
 }
&lt;/code>

Го користиме [http://doc.qt.nokia.com/4.7/qml-mousearea.html MouseArea] елементот во нашиот ''simplebutton''. ''MouseArea'' елементите опишуваат интерактивна област каде движењата на глушецот се детектираат. За нашето копче, го усидруваме целиот [http://doc.qt.nokia.com/4.7/qml-mousearea.html MouseArea] на неговиот родител, кој е ''simplebutton''. синтаксата ''anchors.fill'' е еден начин на пристапување на специфично својство наречен ''fill'' внатре во групата на својства наречени ''anchors'' (сидра). QML користи [http://doc.qt.nokia.com/4.7/qml-anchor-layout.html распоред базиран на сидра] каде елементите можат да се усидрат со други елементи, креирајќи робустни распореди.

''MouseArea'' има многу справувачи со сигнали кои се повикуваат ако има движења на глушецот внатре во специфираните ''MouserArea'' граници. Еден од нив е ''onClicked'' и се повикува кога копчето на глушецот е кликнато, каде левиот клик е стандарден. Можеме да врземе акции на ''onClicked'' справувачот. Во нашиот пример, ''console.log()'' испишува текст кога областа на глувчето е кликната. Функцијата ''console.log()'' е корисна алатка за дебагирање и испишување текст.

Кодот во ''SimpleButton.qml'' е доволен да прикаже копче на екранот и да испише текст кога ќе се кликне на глувчето.

&lt;code>
Rectangle {
 id:Button
 …

property color buttonColor: "lightblue"
 property color onHoverColor: "gold"
 property color borderColor: "white"

signal buttonClick()
 onButtonClick: {
 console.log(buttonLabel.text + " clicked" )
 }

MouseArea{
 onClicked: buttonClick()
 hoverEnabled: true
 onEntered: parent.border.color = onHoverColor
 onExited: parent.border.color = borderColor
 }

//ја одредува бојата на копчето со користење на условниот оператор
 color: buttonMouseArea.pressed ? Qt.darker(buttonColor, 1.5) : buttonColor
 }
&lt;/code>

Целосно функционално копче е во ''Button.qml''. Некој код во оваа статија е испуштен, означено со три точки бидејќи тие биле претходно воведени во претходните секции или се ирелевантни за тековната дискусија.

Приспособените својства се декларираат со користење на ''property type name'' синтаксата. Во овој код, својството ''buttonColor'', од типот ''color'', е декларирано и врзано за вредноста ''"lightblue"''. ''buttonColor'' подоцна се користи во условна операција за да се одреди бојата со која ќе се исполни копчето. Да се забележи дека доделување на вредност на својството е можно со користење на = еднакво симболот, а врзување на вредноста со : две точки карактерот. Приспособените својства овозможуваат интерните елементи да бидат пристапни надвор од Rectangle опсегот (scope). Постојат основни [http://doc.qt.nokia.com/4.7/qdeclarativebasictypes.html QML типови на податоци] како што се ''int'', ''string'', ''real'' како и тип наречен ''variant''.

Врзувањето на ''onEntered'' и ''onExited'' справувачите на сигнали со боите овозможува границата на копчето да стане жолта кога глувчето лебди на копчето и ја враќа бојата кога глувчето ќе излезе од областа.

''buttonClick()'' сигналот е деклариран во ''Button.qml'' со ставање на ''signal'' пред името на сигналот. Кај сите сигнали справувачите автоматски се креираат, нивните имиња стартуваат со ''on''. Како резултат, ''onButtonClick'' е справувач на ''buttonClick''. На ''onButtonClick'' потоа му се доделува акција за извршување. Во нашиот пример, ''onClicked'' справувачот едноставно ќе го повика ''onButtonClick'', кој ќе прикаже текст. ''onButtonClick'' овозможува надворешни објекти едноставно да пристапат на ''Button'' областа на глувчето. На пример, елементите може да имаат повеќе од една ''MouseArea'' декларација и ''buttonClick'' сигналот може да направи разлика помеѓу неколку ''MouseArea'' справувачи со сигнал подобро.

Сега имаме основно познавање како да имплементираме елементи во QML кои можат да се справат со основните потези на глувчето. Креиравме ''Text'' етикета внатре во ''Rectangle'', приспособувајќи ги нивните својства, и имплементиравме однесувања кои реагираат на движење на глувчето.

Копчето не е корисно освен ако не се користи како компонента која врши акција. Во наредната секција, ќе креираме мени кој ќе ги содржи овие копчиња.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor1_button.png|button label]]

=== Креирање на страница со мени ===

До ова ниво, ние покривме како се креираат елементи и доделуваат однесување внатре во единечен QML фајл. Во оваа секција, ќе покажеме како да се импортираат QML елементи и како повторно да се искористат веќе креираните компоненти за да се изградат други компоненти.

Менито прикажува содржина на листа, секој елемент има можност да изврши одредена акција. Во QML, можеме да креираме мени на неколку начини. Прво, ќе креираме мени кое ќе содржи неколку копчиња кои евентуално би извршувале различни акции. Кодот за мени е во ''FileMenu.qml''.

&lt;code>
 import Qt 4.7 импортирање на главниот Qt QML модул
 import "folderName" импортирање на содржината на фолдерот
 import "script.js" as Script импортирање на Javascript фајл кој би се именувал како Script
&lt;/code>

Синтаксата прикажана горе покажува како се употребува ''import''. Ова е потребно за користење на [https://developer.mozilla.org/en/JavaScript Javascript] фајлови, или QML фајлови кои не се во истиот директориум. Бидејќи ''Button.qml'' е во ист директориум како и ''FileMenu.qml'' нема потреба да се импортира ''Button.qml'' за да се користи. Можеме директно да креираме ''Button'' елемент со декларирање на ''Button{}'', слично на ''Rectangle'' декларацијата.

&lt;code>
 В файле FileMenu.qml:

Row{
 anchors.centerIn: parent
 spacing: parent.width/6

Button{
 id: loadButton
 buttonColor: "lightgrey"
 label: "Load"
 }
 Button{
 buttonColor: "grey"
 id: saveButton
 label: "Save"
 }
 Button{
 id: exitButton
 label: "Exit"
 buttonColor: "darkgrey"

onButtonClick: Qt.quit()
 }
 }
&lt;/code>

Во ''FileMenu.qml'', ние декларираме три ''Button'' елементи. Тие се декларирани внатре во [http://doc.qt.nokia.com/4.7/qml-row.html ''Row''] елементот, позицинионер кој ќе ги позиционира неговите деца во вертикална линија. ''Button'' декларацијата останува во ''Button.qml'', која е иста како и ''Button.qml'' што ја користевме во претходната секција. Нови врзувања на својствата може да бидат декларирани во новите креирани копчиња, ефективно пребришувајќи ги својствата сетирани во ''Button.qml''. Копчето наречено ''exitButton'' ќе излезе и затвори прозорот кога е кликнато. Да се забележи дека справувачот со сигнали ''onButtonClick'' во ''Button.qml'' ќе биде повикан заедно со ''onButtonClick'' справувачот во ''exitButton''.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor1_filemenu.png|filemenu]]

''Row'' декларацијата е декларирана во ''Rectangle'', креирајќи правоаголен контејнер за редица од копчиња. Овој додатен правоаголник креира индиректен начин на организирање на редица на копчиња внатре во менито.

Декларацијата на менито за едитирање е многу слична во оваа фаза. Менито има копчиња кои имаат етикети: ''Copy'', ''Paste'', и ''Select All''.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor1_editmenu.png|editmenu]]

Вооружани со нашето знаење за импортирање и прилагодување на претходно направени компоненти, сега можеме да ги комбинираме овие страници со менија за да креираме мени лента, која ќе е составена од копчиња за селекција на менито, и да видиме како можеме да ги структуираме податоците со користење на QML.

=== Имплементирање на мени лента ===

Нашата апликација ќе има потреба некако да ги прикаже менијата со користење на мени лента. Мени лентата ќе префрли на различни менија и корисникот ќе може да одбере кое мени да се прикаже. Менувањето на менито имплицира дека менијата имаат потреба од нешто повеќе отколку само да се прикажуваат во редица. QML користи модели и прикази (views) за да ги структуира податоците и да прикаже структуирани податоци.

== Користење на податочни модели и прикази ==

QML има различни [http://doc.qt.nokia.com/4.7/qdeclarativemodels.html податочни прикази] кои прикажуваат "податочни модели"http://doc.qt.nokia.com/4.7/qdeclarativemodels.html. Нашата мени лента ќе ги прикажува менијата во листа, со заглавје кое прикажува редица на имиња на менијата. Листата на менијата се декларирани внатре во ''VisualItemModel''. [http://doc.qt.nokia.com/4.7/qml-visualitemmodel.html VisualItemModel] елементот содржи елементи кои веќе имаат свои прикази како што се ''Rectangle'' елементите и импортираните UI елементи. Други типови на модели како што е [http://doc.qt.nokia.com/4.7/qml-listmodel.html ListModel] елементот имаат потреба од делегат за да ги прикажуваат нивните податоци.

Декларираме два визуелни елементи во ''menuListModel'', ''FileMenu'' и ''EditMenu''. Ги прилагодуваме двете менија и ги прикажуваме со користење на [http://doc.qt.nokia.com/4.7/qml-listview.html ListView]. ''MenuBar.qml'' фајлот содржи QML декларации и едноставно мени за едитирање е дефинирано во ''EditMenu.qml''.

&lt;code>
 VisualItemModel{
 id: menuListModel
 FileMenu{
 width: menuListView.width
 height: menuBar.height
 color: fileColor
 }
 EditMenu{
 color: editColor
 width: menuListView.width
 height: menuBar.height
 }
 }
&lt;/code>

[http://doc.qt.nokia.com/4.7/qml-listview.html ListView] елементот ќе го прикаже моделот во зависност од делегатот. Делегатот може да ги декларира елементите на моделот за прикажување во ''Row'' елемент или да ги прикаже елементите во мрежа. Нашето ''menuListModel'' веќе има видливи елементи, затоа, нема потреба од декларирање на делегат.

&lt;code>
 ListView{
 id: menuListView

//сидрата се сетирани да реагираат на сидрата на прозорецот
 anchors.fill:parent
 anchors.bottom: parent.bottom
 width:parent.width
 height: parent.height

//моделот ги содржи податоците
 model: menuListModel

//контрола на движењето на менувањето на менито
 snapMode: ListView.SnapOneItem
 orientation: ListView.Horizontal
 boundsBehavior: Flickable.StopAtBounds
 flickDeceleration: 5000
 highlightFollowsCurrentItem: true
 highlightMoveDuration:240
 highlightRangeMode: ListView.StrictlyEnforceRange
 }
&lt;/code>

Додатно, ''ListView'' наследува од ''Flickable'', овозможувајќи на листата да реагира на влечења на глувчето и други гестови. Последното парче на кодот погоре ги сетира Flickable својствата за да се создаде пожелно допирно (flicking) движење на нашиот приказ. Конкретно, својството ''highlightMoveDuration'' го менува времетраењето на допирната транзиција. Поголеми ''highlightMoveDuration'' вредности резултира со поспоро менување на менијата.

''ListView'' ги одржува елементите на моделот преку ''index'' и секој визуелен елемент во моделот може да му се пристапи преку ''index'', по редослед на декларацијата. Менувањето на ''currentIndex'' ефективно го менува нагласениот (highlighted) елемент во ''ListView''. Заглавјето на нашата мени лента е пример на овој ефект. Постојат две копчиња во редица, двете го менуваат моментално мени кога се кликнати. ''fileButton'' го менува моменталното мени во мени за фајлови кога е кликнато, каде ''index'' станува 0 бидејќи ''FileMenu'' е декларирано прво во ''menuListModel''. Слично, ''editButton'' ќе го промени менито во ''EditMenu'' кога е кликнато.

''labelList'' правоаголникот има z вредност 1, означувајќи дека мора да се прикаже пред мени лентата. Елементите со поголема z вредност се прикажуваат пред елементите со помали z вредности. Стандардната вредност на z е 0.

&lt;code>
 Rectangle{
 id: labelList
 …
 z: 1
 Row{
 anchors.centerIn: parent
 spacing:40
 Button{
 label: "File"
 id: fileButton
 …
 onButtonClick: menuListView.currentIndex = 0
 }
 Button{
 id: editButton%0 …
 onButtonClick: menuListView.currentIndex = 1
 }
 }
 }
&lt;/code>

Мени лентата што ја креиравме може да се движи со допир за да се пристапи на менијата или со кликање на имињата на менијата. Менувањето на менијата е интуитивно и респонзивно.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor2_menubar.png|мени лента]]

== Градење на текст едитор ==

=== Декларирање на TextArea (текстуална област) ===

Нашиот текст едитор не е текст едитор ако не содржи област за едитирање на текстот. QML-овиот [http://doc.qt.nokia.com/4.7/qml-textedit.html TextEdit] елемент овозможува декларирање на мултилиниска област за едитирање на текст. [http://doc.qt.nokia.com/4.7/qml-textedit.html TextEdit] е различен од [http://doc.qt.nokia.com/4.7/qml-text.html Text] елементот, кој не дозволува на корисникот директно да го едитира текстот.

&lt;code>
TextEdit{
 id: textEditor
 anchors.fill:parent
 width:parent.width; height:parent.height
 color:"midnightblue"
 focus: true

wrapMode: TextEdit.Wrap

onCursorRectangleChanged: flickArea.ensureVisible(cursorRectangle)
 }
&lt;/code>

Својството на боја за фонтот е сетирано, исто така сетирано е текстот да се замотува (wrap). ''TextEdit'' областа е внатре во допирната (flickable) област која ќе го скролува текстот ако курсорот на текстот е надвор од видливата област. Функцијата ''ensureVisible()'' ќе провери дали правоаголникот на курсорот е надвор од видливите граници и ќе ја помести текстуалната област соодветно. QML користи Javascript синтакса за неговите скрипти, и како што беше претходно спомнато, Javascript фајловите може да бидат импортирани и користени внатре во QML фајлот.

&lt;code>
function ensureVisible®{
 if (contentX >= r.x)
 contentX = r.x;
 else if (contentX+width &lt;= r.x+r.width)
 contentX = r.x+r.width-width;
 if (contentY >= r.y)
 contentY = r.y;
 else if (contentY+height &lt;= r.y+r.height)
 contentY = r.y+r.height-height;
 }
&lt;/code>

=== Комбинирање на компонентите за текст едиторот ===

Сега ние сме спремни да креираме распоред на нашиот текст едитор користејќи QML. Текст едиторот има две компоненти, мени лента која што ја креиравме и текстуална област. QML овозможува повторно користење на компонентите, а со тоа правејќи го нашиот код полесен, со импортирање компоненти и прилагодувајќи ги ако е потребно. Нашиот текст едитор го разделува прозорот на два дела; една третина на екранот е посветен на мени лентата, а другите две третини на екранот е текстуалната област. Мени лентата се прикажува пред другите компоненти.

&lt;code>
Rectangle{

id: screen
 width: 1000; height: 1000

//екранот е поделен на MenuBar и TextArea. 1/3 од екранот е доделен на MenuBar
 property int partition: height/3

MenuBar{
 id:menuBar
 height: partition
 width:parent.width
 z: 1
 }

TextArea{
 id:textArea
 anchors.bottom:parent.bottom
 y: partition
 color: "white"
 height: partition*2
 width:parent.width
 }
 }
&lt;/code>

Со импортирање на повторно употребливи компоненти, кодот на нашиот ''TextEditor'' изгледа многу поедноставно. Ние потоа можеме да ја прилагодиме главната апликација, без да се секираме за својствата кои имаат дефинирани однесувања. Со користење на овој пристап, распоредите на апликацијата и UI компонентите може лесно да се креираат.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor3_texteditor.png|Едноставен едитор]]

== Декорирање на текст едиторот ==

=== Имплементирање на фиока (drawer) интерфејс ===

Нашиот текст едитор изгледа едноставно и ние имаме потреба да го декорираме. Користејќи QML, можеме да декларираме транзиции и да го анимираме нашиот текст едитор. Нашата мени лента опфаќа една третина од екранот и би било фино да се појави тогаш кога ние сакаме.

Можеме да додадеме фиока интерфејс, кој би ја собирал и ширел мени лентата кога е кликнат. Во нашата имплементација, ние имаме тенок правоаголник кој реагира на кликови на глувчето. ''drawer'', како и апликацијата, имаат две состојби: „фиоката отворена“ состојба и „фиоката затворена“ состојба. ''drawer'' елементот е лента од правоаголникот со мала висина. Постои и вгнезден [http://doc.qt.nokia.com/4.7/qml-image.html Image] елемент деклариран така да иконата со стрелка биде центрирана внатре во фиоката. Фиоката доделува состојба на целата апликација, со идентификатор ''screen'', било кога корисникот ќе кликна на областа на глувчето.

&lt;code>
Rectangle{
 id:drawer
 height:15

Image{
 id: arrowIcon
 source: "images/arrow.png"
 anchors.horizontalCenter: parent.horizontalCenter
 }

MouseArea{
 id: drawerMouseArea
 anchors.fill:parent
 onClicked:{
 if (screen.state  "DRAWER_CLOSED"){
                     screen.state = "DRAWER_OPEN"
                 }
                 else if (screen.state  "DRAWER_OPEN"){
 screen.state = "DRAWER_CLOSED"
 }
 }
 …
 }
 }
&lt;/code>

Состојба (state) е едноставно колекција на конфигурации и се декларира со [http://doc.qt.nokia.com/4.7/qml-state.html State] елементот. Листа на состојби може да бидат листани и врзани за ''states'' својството. Во нашата апликација, две состојби се наречени ''DRAWER_CLOSED'' и ''DRAWER_OPEN''. Конфигурациите на елементите се декларирани во [http://doc.qt.nokia.com/4.7/qml-propertychanges.html PropertyChanges] елементите. Во ''DRAWER_OPEN'' состојбата, постојат четири елементи кои ќе примат промени на својствата. Првиот таргет, ''menuBar'', ќе го промени своето y својство во 0. Слично, ''textArea'' ќе оди на пониска нова позиција кога состојбата е ''DRAWER_OPEN''. ''textArea'', ''drawer'', и иконата на фиоката ќе ги менат своите својства за да ја задоволат моменталната состојба.

&lt;code>
states:[
 State {
 name: "DRAWER_OPEN"
 PropertyChanges { target: menuBar; y: 0}
 PropertyChanges { target: textArea; y: partition + drawer.height}
 PropertyChanges { target: drawer; y: partition}
 PropertyChanges { target: arrowIcon; rotation: 180}
 },
 State {
 name: "DRAWER_CLOSED"
 PropertyChanges { target: menuBar; y:-height; }
 PropertyChanges { target: textArea; y: drawer.height; height: screen.height- drawer.height}
 PropertyChanges { target: drawer; y: 0 }
 PropertyChanges { target: arrowIcon; rotation: 0 }
 }
 ]
&lt;/code>

Промените на состојбите се нагли и имаат потреба од помеки транзиции. Транзициите помеѓу својствата се дефинирани со [http://doc.qt.nokia.com/4.7/qml-transition.html Transition] елементот, кој може да е врзан за ''transitions'' својството. Нашиот текст едитор има транзиција било кога состојбата се менува од/во ''DRAWER_OPEN'' или од/во ''DRAWER_CLOSED''. Поважно, транзицијата има потреба од ''from'' и ''to'' состојба но за нашите транзиции, можеме да користиме џокер * симбол да обележиме дека транзициите се однесуваат на сите промени на состојбите.

Во текот на транзициите, можеме да доделиме анимации на промените на својствата. Нашиот ''menuBar'' ја менува позицијата од ''y:0'' во ''y:-partition'' и ние можеме да ја анимираме оваа транзиција со користење на [http://doc.qt.nokia.com/4.7/qml-numberanimation.html ''NumberAnimation''] елементот. Ние ги декларираме кои својства ќе се анимираат за одредено времетраење и со која одредена транзициона крива (easing curve). Кривата ја контролира стапката на анимација и интерполациското однесување во текот на транзицијата. Кривата што ја одбравме е [http://doc.qt.nokia.com/4.7/qml-propertyanimation.html#easing.type-prop Easing.OutQuint], која го успорува движењето близу крајот на анимацијата. Прочитајте ја [http://doc.qt.nokia.com/4.7/qdeclarativeanimation.html статијата] за QML анимациите.

&lt;code>
transitions: [
 Transition {
 to: "*"
 NumberAnimation { target: textArea; properties: "y, height"; duration: 100; easing.type:Easing.OutExpo }
 NumberAnimation { target: menuBar; properties: "y"; duration: 100; easing.type: Easing.OutExpo }
 NumberAnimation { target: drawer; properties: "y"; duration: 100; easing.type: Easing.OutExpo }
 }
 ]
&lt;/code>

Друг начин за анимирање на промени на својствата е со декларирање на [http://doc.qt.nokia.com/4.7/qml-behavior.html Behavior] елементот. Транзицијата работи дури има промена на состојбата и ''Behavior'' може да ја сетира анимацијата за генерална промена на својството. Во текст едиторот, стрелката има ''NumberAnimation'' анимирајќи го ''rotation'' својството било кога својството ќе се промени.

&lt;code>
In TextEditor.qml:

Behavior{
 NumberAnimation{property: "rotation";easing.type: Easing.OutExpo }
 }
&lt;/code>

Кога ќе се вратиме на нашите компоненти со познавање на состојби и анимации, може да го подобриме изгледот на компонентите. Во Button.qml ќе додадеме ''color'' и ''scale'' промени на својства кога копчето е притиснато. Бојата се анимира со користење на [http://doc.qt.nokia.com/4.7/qml-coloranimation.html ColorAnimation] и бројките се анимираат со користење на [http://doc.qt.nokia.com/4.7/qml-numberanimation.html NumberAnimation]. ''on propertyName'' синтаксата подолу помага кога се таргетира единечно својство.

&lt;code>
In Button.qml:
 …

color: buttonMouseArea.pressed ? Qt.darker(buttonColor, 1.5) : buttonColor
 Behavior on color { ColorAnimation{ duration: 55} }

scale: buttonMouseArea.pressed ? 1.1 : 1.00
 Behavior on scale { NumberAnimation{ duration: 55} }
&lt;/code>

Додатно, можеме да го подобриме изгледот на нашите QML компоненти со додавање колор ефекти како што се градиенти или транспаретност. Декларирањето на [http://doc.qt.nokia.com/4.7/qml-gradient.html Gradient] елементот ќе го надреди ''color'' својството на елементот. Можете да декларирате боја во градиентот со користење на [http://doc.qt.nokia.com/4.7/qml-gradientstop.html GradientStop] елементот. Градиентот е позициониран со користење на скала, од 0.0 до 1.0.

&lt;code>
In MenuBar.qml
 gradient: Gradient {
 GradientStop { position: 0.0; color: "#8C8F8C" }
 GradientStop { position: 0.17; color: "#6A6D6A" }
 GradientStop { position: 0.98;color: "#3F3F3F" }
 GradientStop { position: 1.0; color: "#0e1B20" }
 }
&lt;/code>

Градиентот е искористен во мени лентата за да симулира длабочина. Првата боја стартува од 0.0 а последната на 1.0.

=== Што понатаму ===

Ние го завршивме градењето на кориснички интерфејс на едноставен текст едитор. Одејќи нанапред, корисничкиот интерфејс е имплементиран, и можеме да имплементираме логика на апликацијата со користење на регуларен Qt и C+''. QML работи добро како прототипна алатка, одвојувајќи ја логиката на апликацијата од UI дизајнот. 

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor4_texteditor.png|Текст едитор]]

== Проширување на QML со користење на Qt C''+ ==
Сега кога го имаме распоредот на нашиот текст едитор, ние можеме да имплементираме додатни функционалности во C+''. Користење на QML со C''+ ни овозможува да ја креираме апликациската логика со користење на Qt. Можеме да креираме QML контекст во C++ апликација со користење на [http://doc.qt.nokia.com/4.7/qtbinding.html декларативните класи на Qt] и да прикажеме QML елементи користејќи графичка сцена (Graphics Scene). Алтернативно, можеме да го експортираме C++ кодот во дополнителна компонента (plugin) кој [http://doc.qt.nokia.com/4.7/qmlviewer.html qmlviewer] алатката може да ја прочита. За нашата апликација, ќе имплементираме функции на вчитување и снимање во C++ и ќе ги експортираме како плагин. На овој начин, нас ни е доволно да го вчитаме QML фајлот директно наместо да го стартуваме како апликација.

=== Изложување на C++ класите во QML ===

Ќе имплементираме вчитување и снимање на фајлови со користење на Qt и C+''. C''+ класите и функциите може да бидат користени во QML со нивно регистрирање. Класата е доволно да биде компајлирана како Qt плагин и на QML фајлот доволно ќе му биде каде е плагинот лоциран.

За нашата апликација, потребно е да се креираат следниве елементи:

# ''Directory'' класа која ќе се справува со директориумите
# ''File'' класа која е [http://doc.qt.nokia.com/4.7/qobject.html QObject], што ќе симулира листа на фајлови во директориум
# плагин класа која ќе регистрира класа во QML контекстот
# Qt проект фајл кој ќе го компајлира плагинот
# ''qmldir'' фајл кој ќе му каже на qmlviewer алатката каде да го најде плагинот

=== Градење на Qt плагин ===

За да се изгради плагинот, мораме следниве работи да ги сетираме во Qt проект фајлот. Прво, неопходните сорсови, заглавја, и Qt модули треба да се додадат во нашиот проект фајл. Сиот C++ код и проект фајлови се во ''filedialog'' директориумот.

&lt;code>
Во cppPlugins.pro:

TEMPLATE = lib
 CONFIG ''= qt plugin
 QT''= declarative

DESTDIR ''= ../plugins
 OBJECTS_DIR = tmp
 MOC_DIR = tmp

 TARGET = FileDialog

 HEADERS''= directory.h  file.h  dialogPlugin.h

SOURCES += directory.cpp  file.cpp  dialogPlugin.cpp
&lt;/code>

Конкретно, компајлираме со ''declarative'' модулот и го конфигурираме како ''plugin'', на што му треба ''lib'' шаблонот (template). Ќе го ставиме компајлираниот плагин во родителот на ''plugins'' директориум.

=== Регистрирање на класа во QML ===

&lt;code>
 Во dialogPlugin.h:

#include &lt;QDeclarativeExtensionPlugin>

class DialogPlugin : public QDeclarativeExtensionPlugin
 {
 Q_OBJECT

public:
 void registerTypes(const char *uri);

};
&lt;/code>

Во нашата плагин класа, ''DialogPlugin'' e подкласа на [http://doc.qt.nokia.com/4.7/qdeclarativeextensionplugin.html QDeclarativeExtensionPlugin]. Треба да имплементираме наследената функција, [http://doc.qt.nokia.com/4.7/qdeclarativeextensionplugin.html#registerTypes registerTypes()]. ''dialogPlugin.cpp'' изгледа вака:

&lt;code>
DialogPlugin.cpp:

#include "dialogPlugin.h"
 #include "directory.h"
 #include "file.h"
 #include &lt;qdeclarative.h>

void DialogPlugin::registerTypes(const char '''uri){

 qmlRegisterType&lt;Directory>(uri, 1, 0, "Directory");
 qmlRegisterType&lt;File>(uri, 1, 0,"File");
 }

 Q_EXPORT_PLUGIN2(FileDialog, DialogPlugin);
&lt;/code>

[http://doc.qt.nokia.com/4.7/qdeclarativeextensionplugin.html#registerTypes registerTypes()] функцијата ги регистрира нашите File и Directory класи во QML. На оваа функција и потребно името на класата за нејзиниот шаблон, броевите на верзијата, и името на нашите класи.

Треба да го експортираме плагинот со користење на [http://doc.qt.nokia.com/4.7/qtplugin.html#Q_EXPORT_PLUGIN2#q-export-plugin2 Q_EXPORT_PLUGIN2] макрото. Да се забележи дека во нашиот ''dialogPlugin.h'', мора да имаме [http://doc.qt.nokia.com/4.7/qobject.html#Q_OBJECT Q_OBJECT] макро на врвот на нашата класа. Исто така, мораме да го стартуваме ''qmake'' на нашиот проект фајл за да се генерира неопходниот мета-објектен код.

=== Креирање на QML својства во C++ класа ===
Можеме да креираме QML елементи и својства со користење на C++ и [http://doc.qt.nokia.com/4.7/metaobjects.html мета-објектниот систем]. Можеме да имплементираме својства користејќи слотови и сигнали, правејќи Qt да е свесно за овие својства. Овие својства може да се употребат во QML.

За нашиот текст едитор, нас ни треба да можеме да вчитуваме и снимаме фајлови. Типично, вакви карактерстики се содржани во фајл дијалог. За наша среќа, можеме да ги користиме [http://doc.qt.nokia.com/4.7/qdir.html QDir], [http://doc.qt.nokia.com/4.7/qfile.html QFile] и [http://doc.qt.nokia.com/4.7/qtextstream.html QTextStream] за да имплементираме читање на директориум и влезни/излезни текови (streams).

&lt;code>
 class Directory : public QObject{

 Q_OBJECT

 Q_PROPERTY(int filesCount READ filesCount CONSTANT)
 Q_PROPERTY(QString filename READ filename WRITE setFilename NOTIFY filenameChanged)
 Q_PROPERTY(QString fileContent READ fileContent WRITE setFileContent NOTIFY fileContentChanged)
 Q_PROPERTY(QDeclarativeListProperty&lt;File> files READ files CONSTANT )

 …
&lt;/code>

''Directory'' класата користи мета-објектен систем за да ги регистрира потребните својства за да постигне справување со фајловите. ''Directory'' класата е експортирана како плагин и е употреблива во QML како ''Directory'' елемент. Секој од излистаните својства го користи [http://doc.qt.nokia.com/4.7/qobject.html#Q_PROPERTY Q_PROPERTY] макрото и е истовремено QML својство.

[http://doc.qt.nokia.com/4.7/qobject.html#Q_PROPERTY Q_PROPERTY] декларира својство, како и функциите за читање и запишување во мета-објектниот систем. На пример, ''filename'' својството, од типот [http://doc.qt.nokia.com/4.7/qstring.html QString] може да се чита користејќи ја ''filename()'' функцијата и може да се запишува користејќи ја ''setFilename()'' функцијата. Додатно, постои сигнал асоциран со filename својството наречен ''filenameChanged()'', кој се емитира кога својството ќе се промени, Функциите за читање и запишување се декларирани како ''public'' во заглавјето.

Слично, ние имаме други својства декларирани според нивната употреба. ''filesCount'' својството го покажува бројот на фајлови во директориумот. filename својството е сетирано на моменталниот селектиран фајл и вчитувањето/снимањето на содржината на фајлот е во ''fileContent'' својството.

&lt;code>
Q_PROPERTY(QDeclarativeListProperty&lt;File> files READ files CONSTANT )
&lt;/code>

''files'' својството е листа на сите филтрирани фајлови во директориумот. ''Directory'' класата е имплементирана за да ги филтрира невалидните текст фајлови; фајловите со екстензија ''.txt'' се валидни. Понатаму, [http://doc.qt.nokia.com/4.7/qlist.html QList] класите можат да бидат користени во QML фајловите декларирајќи ги како [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html QDeclarativeListProperty] во C+''. Шаблонизираниот објект мора да наследува од [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html QObject], затоа, ''File'' класата мора да наследува од [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html QObject]. Во ''Directory'' класата, листата на ''File'' објекти се чуваат во [http://doc.qt.nokia.com/4.7/qlist.html QList] наречено ''m_fileList''.

&lt;code>
 class File : public QObject{

 Q_OBJECT
 Q_PROPERTY(QString name READ name WRITE setName NOTIFY nameChanged)

 …
 };
&lt;/code>

Својствата потоа може да бидат користени во QML како дел од ''Directory'' својствата. Да се забележи дека ние не креиравме својство индентификатор ''id'' во нашиот C''+ код.

&lt;code>
 Directory{
 id: directory

 filesCount
 filename
 fileContent
 files

 files[0].name
 }
&lt;/code>

Бидејќи QML користи Javascript синтакса и структура, ние можеме да итерираме низ листата на фајлови и да ги превземеме нивните својства. Да се превземе својството име на првиот фајл, ние повикуваме ''files[0].name''.

Регуларните C++ функции исто така се пристапни во QML. Функциите на вчитување и снимање на фајлови се имплементирано во C++ и декларирани користејќи го [http://doc.qt.nokia.com/4.7/qobject.html#Q_INVOKABLE Q_INVOKABLE] макрото. Алтернативно, можеме да декларираме функции како слот и тие функции ќе бидат пристапни во QML.

&lt;code>
 Во Directory.h:

 Q_INVOKABLE void saveFile();
 Q_INVOKABLE void loadFile();
&lt;/code>

''Directory'' класата исто така мора да ги извести другите објекти кога и да има промена содржината на директориумот. Оваа особеност се прави со користење на ''signal''. Како што спомнавме претходно, QML сигналите имаат соодветен справувач каде нивните имиња имаат префикс ''on''. Сигналот се нарекува ''directoryChanged'' и се емитира кога и да има освежување на директориумот. Освежувањето едноставно ја вчитува повторно содржината на директориумот и ја освежува листата на валидни фајлови во директориумот. QML елементите потоа можат да бидат известени со закачување на акцијата во ''onDirectoryChanged'' справувачот на сигнал.

''list'' својствата треба да се истражат повеќе. Ова е потрено затоа што листа својствата користат обратни повици (callbacks) за пристап и модификација на содржината на листата. Листа својството е од типот ''QDeclarativeListProperty&lt;File>''. Кога ќе се пристапи на листата, акцесор функција (accessor function) треба да врати ''QDeclarativeListProperty&lt;File>''. Типот на шаблон, ''File'', мора да е наследува од ''QObject''. Понатаму, за да се креира [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html QDeclarativeListProperty], акцесорот на листата и модификаторите треба да бидат предадени во конструкторот како функциски поинтери. Листата, ''QList'' во нашиот случај, исто така мора да е листа од ''File'' поинтери.

Конструкторот на [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html QDeclarativeListProperty] и ''Directory'' имплементацијата:

&lt;code>
 QDeclarativeListProperty ( QObject''' object, void * data, AppendFunction append, CountFunction count = 0, AtFunction at = 0, ClearFunction clear = 0 )
 QDeclarativeListProperty&lt;File>( this, &amp;m_fileList, &amp;appendFiles, &amp;filesSize, &amp;fileAt, &amp;clearFilesPtr );
&lt;/code>

Конструкторот ги предава поинтерите кон функции кои ќе додаваат на листата, бројат на листата, да се добие елемент со користење на индекс, и да се испразни листата. Само функцијата за додавање е мандаторна. Да се примети дека функциските поинтери мора да одговара на дефиницијата на [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#AppendFunction-typedef AppendFunction], [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#CountFunction-typedef CountFunction], [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#AtFunction-typedef AtFunction], или [http://doc.qt.nokia.com/4.7/qdeclarativelistproperty.html#ClearFunction-typedef ClearFunction].

&lt;code>
 void appendFiles(QDeclarativeListProperty&lt;File> * property, File * file)
 File* fileAt(QDeclarativeListProperty&lt;File> * property, int index)
 int filesSize(QDeclarativeListProperty&lt;File> * property)
 void clearFilesPtr(QDeclarativeListProperty&lt;File> *property)
&lt;/code>

За да го поедноставиме нашиот фајл дијалог, ''Directory'' класата ги филтрира сите невалидни текст фајлови, фајлови кои немаат ''.txt'' екстензија. Ако фајлот нема ''.txt'' екстензија, тогаш нема да прикажан на нашиот дијалог. Исто така, имплементацијата се осигурува да снимените фајлови имаат ''.txt'' екстензија. ''Directory'' користи [http://doc.qt.nokia.com/4.7/qtextstream.html QTextStream] за читање на фајлот и запишување на содржината во фајлот.

Со нашиот ''Directory'' елемент, можеме да ги земеме фајловите како листа, да знаеме колку текст фајлови има во директориумот, да се прочита името на фајлот и содржината како стринг, и да бидеме известени кога ќе има промени во содржината на директориумот.

За да се изгради плагинот, стартувајте го ''qmake'' на ''cppPlugins.pro'' проектниот фајл, потоа стартувајте го ''make'' за да се изгради и пренесе плагинот во ''plugins'' директориумот.

=== Импортирање на плагинот во QML ===

qmlviewer алатката импортира фајлови кои се во истиот директориум како и апликацијата. Можеме исто така да креирамe ''qmldir'' фајл кој ќе содржи локации на QML фајлови кои сакаме да се импортираат. ''qmldir'' фајлот може да зачува локации на плагини и други ресурси.

&lt;code>
 Во qmldir:

Button ./Button.qml
 FileDialog ./FileDialog.qml
 TextArea ./TextArea.qml
 TextEditor ./TextEditor.qml
 EditMenu ./EditMenu.qml

plugin FileDialog plugins
&lt;/code>

Плагинот што ние го креиравме се нарекува ''FileDialog'', како што се гледа во ''TARGET'' полето во проектниот фајл. Компајлираниот плагин е во ''plugins'' директориум.

=== Интегрирање на File Dialog во File Menu ===

Нашето ''FileMenu'' има потреба да го прикаже ''FileDialog'' елемент, кој ќе содржи листа на текст фајлови во директориумот, а со тоа, овозможувајќи на корисникот да селектира фајл со кликање на листата. Нас ни е уште потребно да доделиме save, load и new копчињата на нивните соодветни акции. ''FileMenu'' содржи влезен едитирачки текст да му овозможи на корисникот да го напише името на фајлот со користење на тастатура.

''Directory'' елементот е искористен во ''FileMenu.qml'' фајлот и го известува ''FileDialog'' елементот дека директориумот ја освежил својата содржина. Ова известување се извршува со справувач на сигнали, ''onDirectoryChanged''.

&lt;code>
Во FileMenu.qml:

Directory{
 id:directory
 filename: textInput.text
 onDirectoryChanged: fileDialog.notifyRefresh()
 }
&lt;/code>

Зачувувајќи ја едноставноста на нашата апликација, дијалогот секојпат ќе биде видлив, и нема да прикажува невалидни текст фајлови, кои немаат ''.txt'' екстензија на нивните имиња.

&lt;code>
Во FileDialog.qml:

signal notifyRefresh()
 onNotifyRefresh: dirView.model = directory.files
&lt;/code>

''FileDialog'' елементот ќе ја прикаже содржината на директориумот со читање на листа својството наречено ''files''. Фајловите се користат како модел во [http://doc.qt.nokia.com/4.7/qml-gridview.html GridView] елементот, кој прикажува податочни елементи во мрежа одредено од делегатот. Делегатот е одговорен за изгледот на моделот и нашиот дијалог едноставно ќе креира мрежа со текст центриран во средината. Со кликање на името на фајлот ќе резултира со појавување на правоаголник кој ќе го означи името на фајлот. ''FileDialog'' се известува кога ''notifyRefresh'' сигналот е емитиран, вчитувајќи ги повторно фајловите во директориумот.

&lt;code>
В FileMenu.qml:

Button{
 id: newButton
 label: "New"
 onButtonClick:{
 textArea.textContent = ""
 }
 }
 Button{
 id: loadButton
 label: "Load"
 onButtonClick:{
 directory.filename = textInput.text
 directory.loadFile()
 textArea.textContent = directory.fileContent
 }
 }
 Button{
 id: saveButton
 label: "Save"
 onButtonClick:{
 directory.fileContent = textArea.textContent
 directory.filename = textInput.text
 directory.saveFile()
 }
 }
 Button{
 id: exitButton
 label: "Exit"
 onButtonClick:{
 Qt.quit()
 }
 }
&lt;/code>

Нашето ''FileMenu'' сега може да се поврзе со соодветните акции. ''saveButton'' ќе го пренесе текстот од ''TextEdit'' во ''fileContent'' својството на директориумот, потоа ќе го копира името на фајлот во влезен едитирачки текст. Конечно, копчето ја повикува ''saveFile()'' функција, снимајќи го со тоа фајлот. ''loadButton'' се извршува слично. Исто така, ''New'' акцијата ќе ја испразни содржината на ''TextEdit''.

Понатаму, ''EditMenu'' копчињата се конектирани со ''TextEdit'' функциите за копирање, лепење и селектирање на сиот текст во текст едиторот.

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor5_filemenu.png|File Menu]]

== Завршување со текст едиторот ==

[[Image:http://doc.qt.nokia.com/4.7/images/qml-texteditor5_newfile.png|New File]]
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="http://wiki.qt.io/Template:Ambox" title="Template:Ambox">Template:Ambox</a> (<a href="http://wiki.qt.io/index.php?title=Template:Ambox&amp;action=edit" title="Template:Ambox">view source</a>) </li><li><a href="http://wiki.qt.io/Template:Cleanup" title="Template:Cleanup">Template:Cleanup</a> (<a href="http://wiki.qt.io/index.php?title=Template:Cleanup&amp;action=edit" title="Template:Cleanup">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/mk" title="Getting Started Programming with QML/mk">Getting Started Programming with QML/mk</a>.</p>
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/mk">http://wiki.qt.io/Getting_Started_Programming_with_QML/mk</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=Getting+Started+Programming+with+QML%2Fmk" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/mk"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:Getting_Started_Programming_with_QML/mk&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="http://wiki.qt.io/Getting_Started_Programming_with_QML/mk" >Read</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="http://wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/mk&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/mk&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/Getting_Started_Programming_with_QML/mk" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/Getting_Started_Programming_with_QML/mk" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/mk&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":308});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=Getting_Started_Programming_with_QML/mk&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:58:33 GMT -->
</html>
