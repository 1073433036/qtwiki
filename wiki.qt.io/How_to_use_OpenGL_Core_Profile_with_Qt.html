<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 08:39:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>How to use OpenGL Core Profile with Qt - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<link rel="shortcut icon" href="favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="api251f.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="apidf90.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="load771b.css?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="loadc6d2.css?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="load8478.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"How_to_use_OpenGL_Core_Profile_with_Qt","wgTitle":"How to use OpenGL Core Profile with Qt","wgCurRevisionId":18223,"wgRevisionId":18223,"wgArticleId":989,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Articles needing cleanup","HowTo","Developing with Qt::General","Tutorial","Developing with Qt::QtOpenGL"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"How_to_use_OpenGL_Core_Profile_with_Qt","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp-qt {line-height: normal;}
.source-cpp-qt li, .source-cpp-qt pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp-qt
 * CSS class: source-cpp-qt, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp-qt.source-cpp-qt .de1, .cpp-qt.source-cpp-qt .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.cpp-qt.source-cpp-qt  {font-family:monospace;}
.cpp-qt.source-cpp-qt .imp {font-weight: bold; color: red;}
.cpp-qt.source-cpp-qt li, .cpp-qt.source-cpp-qt .li1 {font-weight: normal; vertical-align:top;}
.cpp-qt.source-cpp-qt .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp-qt.source-cpp-qt .li2 {font-weight: bold; vertical-align:top;}
.cpp-qt.source-cpp-qt .kw1 {color: #000000; font-weight:bold;}
.cpp-qt.source-cpp-qt .kw2 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .kw4 {color: #0057AE;}
.cpp-qt.source-cpp-qt .kw5 {color: #22aadd;}
.cpp-qt.source-cpp-qt .co1 {color: #888888;}
.cpp-qt.source-cpp-qt .co2 {color: #006E28;}
.cpp-qt.source-cpp-qt .coMULTI {color: #888888; font-style: italic;}
.cpp-qt.source-cpp-qt .es0 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es1 {color: #000099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es2 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es3 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es4 {color: #660099; font-weight: bold;}
.cpp-qt.source-cpp-qt .es5 {color: #006699; font-weight: bold;}
.cpp-qt.source-cpp-qt .br0 {color: #006E28;}
.cpp-qt.source-cpp-qt .sy0 {color: #006E28;}
.cpp-qt.source-cpp-qt .st0 {color: #BF0303;}
.cpp-qt.source-cpp-qt .nu0 {color: #B08000;}
.cpp-qt.source-cpp-qt .nu6 {color: #208080;}
.cpp-qt.source-cpp-qt .nu8 {color: #208080;}
.cpp-qt.source-cpp-qt .nu12 {color: #208080;}
.cpp-qt.source-cpp-qt .nu16 {color:#800080;}
.cpp-qt.source-cpp-qt .nu17 {color:#800080;}
.cpp-qt.source-cpp-qt .nu18 {color:#800080;}
.cpp-qt.source-cpp-qt .nu19 {color:#800080;}
.cpp-qt.source-cpp-qt .me1 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me2 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .me3 {color: #2B74C7;}
.cpp-qt.source-cpp-qt .ln-xtra, .cpp-qt.source-cpp-qt li.ln-xtra, .cpp-qt.source-cpp-qt div.ln-xtra {background-color: #ffc;}
.cpp-qt.source-cpp-qt span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-How_to_use_OpenGL_Core_Profile_with_Qt skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">How to use OpenGL Core Profile with Qt</span></h1>
						<div id="bodyContent">
								<div id="siteSub">From Qt Wiki</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table style="center; margin: -1px auto 0px;border: 1px solid rgb(127, 194, 66); border-left: 10px solid rgb(127, 194, 66); background:rgb(250,250,250); width:600px">

<tr>
<td style="padding: 0.25em 0.5em;"> <b>This article may require cleanup to meet the Qt Wiki's quality standards.</b> Reason: Article needs to be updated to Qt 5.<br /><small>Please <b><a rel="nofollow" class="external text" href="index272c.html?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=edit">improve this article</a></b> if you can. Remove the {{cleanup}} tag and add this page to <b><a href="Updated_pages.html" title="Updated pages">Updated pages</a></b> list after it's clean.</small>
</td></tr></table>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Specifying_the_OpenGL_Format"><span class="tocnumber">2</span> <span class="toctext">Specifying the OpenGL Format</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#The_GLWidget_Class_Declaration"><span class="tocnumber">3</span> <span class="toctext">The GLWidget Class Declaration</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#The_GLWidget_Class_Implementation"><span class="tocnumber">4</span> <span class="toctext">The GLWidget Class Implementation</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Initialisation"><span class="tocnumber">4.1</span> <span class="toctext">Initialisation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Drawing"><span class="tocnumber">5</span> <span class="toctext">Drawing</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Miscellaneous"><span class="tocnumber">6</span> <span class="toctext">Miscellaneous</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#The_Shaders"><span class="tocnumber">7</span> <span class="toctext">The Shaders</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#The_Vertex_Shader"><span class="tocnumber">7.1</span> <span class="toctext">The Vertex Shader</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#The_Fragment_Shader"><span class="tocnumber">7.2</span> <span class="toctext">The Fragment Shader</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Building_and_Running"><span class="tocnumber">8</span> <span class="toctext">Building and Running</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Introduction">Introduction</span></h2>
<p>Qt's support for OpenGL has now been extended to provide access to the OpenGL Core profile. When using the Core profile, all access to the legacy fixed-functionality pipeline is removed. This means that to get anything drawn on screen we have to make use of glsl shaders and vertex arrays or buffers.
</p><p>The OpenGL Core profile is available when using Qt 4.8.0 or newer and OpenGL 3.1 or newer. Since Qt 4.8.0 has not yet been released you will need to get a development version of Qt. The easiest way to do this is to get it from the gitorious repository.
</p><p>A complete copy of the source code for this tutorial can be obtained by doing:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">svn co https<span class="sy0">:</span><span class="co1">//svn.theharmers.co.uk/svn/codes/public/opengl/trunk opengl</span>
cd opengl<span class="sy0">/</span><span class="nu8">07</span><span class="sy0">-</span>core<span class="sy0">-</span>profile</pre></div></div>
<p>Why would we want to use the OpenGL Core profile? Well, for a start OpenGL 3.0 deprecated much of the old fixed-functionality pipeline entry points. Yes, at present these are still available when using the Compatibility profile in order to keep old applications working. However, many of these deprecated functions encourage poor or out-dated practises. For example it is much more efficient to use vertex arrays or even better vertex buffer objects to send geometry to the OpenGL pipeline than the old glVertex family of functions. The same is true for all other per-vertex attributes too (e.g. normals, texture coordinates, colours etc.).
</p><p>Using the Core profile also means that the OpenGL driver has to track far fewer states per-context. Using the Core profile the developer is responsible for configuring which states their shaders care about and these are all passed in by means of a much simpler and more consistent set of functions.
</p><p>The Khronos Group that oversees the OpenGL specification recommends to use the Core profile in new OpenGL applications.
</p><p>Some OpenGL drivers (e.g. nVidia) may incur a small performance penalty when using the Core profile as internally this enables checks to see if a feature should be enabled or not. So to get the very best performance one method is to develop your app using only the Core profile but then when you release build and test it using the Compatibility profile. This way you can be sure that you are only using non-deprecated feature but still getting the very best performance.
</p><p><b>This is known to work under Linux but Windows and Mac OSX have some issues inside of Qt for creating Core Profile contexts.</b>
</p>
<h2><span class="mw-headline" id="Specifying_the_OpenGL_Format">Specifying the OpenGL Format</span></h2>
<p>The first stage in being able to use the OpenGL Core profile is to prepare a QGLFormat object that describes the OpenGL context we would like to use. The following simple main function does just that:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="co2">#include &lt;QApplication&gt;</span>
<span class="co2">#include &lt;QGLFormat&gt;</span>
&#160;
<span class="co2">#include &quot;glwidget.h&quot;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span> <span class="kw4">int</span> argc<span class="sy0">,</span> <span class="kw4">char</span><span class="sy0">*</span> argv<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 <span class="kw5">QApplication</span> a<span class="br0">&#40;</span> argc<span class="sy0">,</span> argv <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="co1">// Specify an OpenGL 3.3 format using the Core profile.</span>
 <span class="co1">// That is, no old-school fixed pipeline functionality</span>
 <span class="kw5">QGLFormat</span> glFormat<span class="sy0">;</span>
 glFormat.<span class="me1">setVersion</span><span class="br0">&#40;</span> <span class="nu0">3</span><span class="sy0">,</span> <span class="nu0">3</span> <span class="br0">&#41;</span><span class="sy0">;</span>
 glFormat.<span class="me1">setProfile</span><span class="br0">&#40;</span> <span class="kw5">QGLFormat</span><span class="sy0">::</span><span class="me2">CoreProfile</span> <span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// Requires &gt;=Qt-4.8.0</span>
 glFormat.<span class="me1">setSampleBuffers</span><span class="br0">&#40;</span> <span class="kw2">true</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="co1">// Create a GLWidget requesting our format</span>
 GLWidget w<span class="br0">&#40;</span> glFormat <span class="br0">&#41;</span><span class="sy0">;</span>
 w.<span class="me1">show</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw1">return</span> a.<span class="me1">exec</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>We first create a QApplication as usual. We then create a QGLFormat object and set it to OpenGL version 3.3 (the newest that my card and driver combination supports). We then request to use the Core profile and for nicer looking results we also ask to enable multi-sampling. We then pass the glFormat object through to the constructor of our custom subclass of QGLWidget, GLWidget (yes imaginative I know). Finally we show the widget and enter the event loop.
</p>
<h2><span class="mw-headline" id="The_GLWidget_Class_Declaration">The GLWidget Class Declaration</span></h2>
<p>Here is the declaration of the simple class we will use to demonstrate usage of the OpenGL Core profile:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="co2">#ifndef GLWIDGET_H</span>
<span class="co2">#define GLWIDGET_H</span>
&#160;
<span class="co2">#include &lt;QGLWidget&gt;</span>
&#160;
<span class="co2">#include &lt;QGLBuffer&gt;</span>
<span class="co2">#include &lt;QGLShaderProgram&gt;</span>
&#160;
<span class="kw2">class</span> GLWidget <span class="sy0">:</span> <span class="kw2">public</span> <span class="kw5">QGLWidget</span>
<span class="br0">&#123;</span>
 <span class="kw2">Q_OBJECT</span>
<span class="kw2">public</span><span class="sy0">:</span>
 GLWidget<span class="br0">&#40;</span> <span class="kw4">const</span> <span class="kw5">QGLFormat</span><span class="sy0">&amp;</span> format<span class="sy0">,</span> <span class="kw5">QWidget</span><span class="sy0">*</span> parent <span class="sy0">=</span> <span class="nu0">0</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw2">protected</span><span class="sy0">:</span>
 <span class="kw2">virtual</span> <span class="kw4">void</span> initializeGL<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw2">virtual</span> <span class="kw4">void</span> resizeGL<span class="br0">&#40;</span> <span class="kw4">int</span> w<span class="sy0">,</span> <span class="kw4">int</span> h <span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw2">virtual</span> <span class="kw4">void</span> paintGL<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw2">virtual</span> <span class="kw4">void</span> keyPressEvent<span class="br0">&#40;</span> <span class="kw5">QKeyEvent</span><span class="sy0">*</span> e <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw2">private</span><span class="sy0">:</span>
 <span class="kw4">bool</span> prepareShaderProgram<span class="br0">&#40;</span> <span class="kw4">const</span> <span class="kw5">QString</span><span class="sy0">&amp;</span> vertexShaderPath<span class="sy0">,</span>
 <span class="kw4">const</span> <span class="kw5">QString</span><span class="sy0">&amp;</span> fragmentShaderPath <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
QGLShaderProgram m_shader<span class="sy0">;</span>
 QGLBuffer m_vertexBuffer<span class="sy0">;</span>
<span class="br0">&#125;</span><span class="sy0">;</span>
&#160;
<span class="co2">#endif // GLWIDGET_H</span></pre></div></div>
<p>We inherit a class from QGLWidget as normal. Note that the constructor accepts a constant reference to a QGLFormat. We override the initialiseGL(), resizeGL(), and paintGL() functions to provide our custom functionality. For convenience we also override the keyPressEvent() function so that the Escape key quits the application.
</p><p>The prepareShaderProgram() function is a simple wrapper function that takes care of loading the vertex and fragment shader source, compiling the shaders, and linking them into a functional shader program. The shader program is stored in the m_shader member. The m_vertexBuffer member, as its name suggests, encapsulates and OpenGL vertex buffer that holds the vertex data for our geometry.
</p>
<h2><span class="mw-headline" id="The_GLWidget_Class_Implementation">The GLWidget Class Implementation</span></h2>
<h3><span class="mw-headline" id="Initialisation">Initialisation</span></h3>
<p>The constructor is very simple:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">GLWidget<span class="sy0">::</span><span class="me2">GLWidget</span><span class="br0">&#40;</span> <span class="kw4">const</span> <span class="kw5">QGLFormat</span><span class="sy0">&amp;</span> format<span class="sy0">,</span> <span class="kw5">QWidget</span><span class="sy0">*</span> parent <span class="br0">&#41;</span>
 <span class="sy0">:</span> <span class="kw5">QGLWidget</span><span class="br0">&#40;</span> format<span class="sy0">,</span> parent <span class="br0">&#41;</span><span class="sy0">,</span>
 m_vertexBuffer<span class="br0">&#40;</span> QGLBuffer<span class="sy0">::</span><span class="me2">VertexBuffer</span> <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>We pass the requested QGLFormat object through to the QGLWidget constructor along with the usual pointer to the parent. QGLWidget tries its best to supply a QGLContext that matches our requested format. If it is unable to get an exact match it tries to create a close approximation. You can explicitly check the created OpenGL context properties by way of the QGLWidget::format() function.
</p><p>We also initialise the QGLBuffer object by telling it that we wish to use it to store vertex data.
</p><p>Following construction Qt calls the initialiseGL() function for us to allow us to do any OpenGL initialisation. Note that this function is only called once so only do setup that will persist for as long as this widget here.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw4">void</span> GLWidget<span class="sy0">::</span><span class="me2">initializeGL</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 <span class="kw5">QGLFormat</span> glFormat <span class="sy0">=</span> <span class="kw5">QGLWidget</span><span class="sy0">::</span><span class="me2">format</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>glFormat.<span class="me1">sampleBuffers</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#41;</span>
 qWarning<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;Could not enable sample buffers&quot;</span><span class="sy0">;</span>
&#160;
<span class="co1">// Set the clear color to black</span>
 glClearColor<span class="br0">&#40;</span> <span class="nu17">0.0f</span><span class="sy0">,</span> <span class="nu17">0.0f</span><span class="sy0">,</span> <span class="nu17">0.0f</span><span class="sy0">,</span> <span class="nu17">1.0f</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="co1">// Prepare a complete shader program…</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>prepareShaderProgram<span class="br0">&#40;</span> <span class="st0">&quot;:/simple.vert&quot;</span><span class="sy0">,</span> <span class="st0">&quot;:/simple.frag&quot;</span> <span class="br0">&#41;</span> <span class="br0">&#41;</span>
 return<span class="sy0">;</span>
&#160;
<span class="co1">// We need us some vertex data. Start simple with a triangle&#160;;-)</span>
 <span class="kw4">float</span> points<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span> –<span class="nu17">0.5f</span><span class="sy0">,</span> –<span class="nu17">0.5f</span><span class="sy0">,</span> <span class="nu17">0.0f</span><span class="sy0">,</span> <span class="nu17">1.0f</span><span class="sy0">,</span>
 <span class="nu17">0.5f</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu17">0.5f</span><span class="sy0">,</span> <span class="nu17">0.0f</span><span class="sy0">,</span> <span class="nu17">1.0f</span><span class="sy0">,</span>
 <span class="nu17">0.0f</span><span class="sy0">,</span> <span class="nu17">0.5f</span><span class="sy0">,</span> <span class="nu17">0.0f</span><span class="sy0">,</span> <span class="nu17">1.0f</span> <span class="br0">&#125;</span><span class="sy0">;</span>
 m_vertexBuffer.<span class="me1">create</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
 m_vertexBuffer.<span class="me1">setUsagePattern</span><span class="br0">&#40;</span> QGLBuffer<span class="sy0">::</span><span class="me2">StaticDraw</span> <span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>m_vertexBuffer.<span class="me1">bind</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#41;</span>
 <span class="br0">&#123;</span>
 qWarning<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;Could not bind vertex buffer to the context&quot;</span><span class="sy0">;</span>
 return<span class="sy0">;</span>
 <span class="br0">&#125;</span>
 m_vertexBuffer.<span class="me1">allocate</span><span class="br0">&#40;</span> points<span class="sy0">,</span> <span class="nu0">3</span> <span class="sy0">*</span> <span class="nu0">4</span> <span class="sy0">*</span> <span class="kw3">sizeof</span><span class="br0">&#40;</span> <span class="kw4">float</span> <span class="br0">&#41;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
 <span class="co1">// Bind the shader program so that we can associate variables from</span>
 <span class="co1">// our application to the shaders</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>m_shader.<span class="me1">bind</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#41;</span>
 <span class="br0">&#123;</span>
 qWarning<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;Could not bind shader program to context&quot;</span><span class="sy0">;</span>
 return<span class="sy0">;</span>
 <span class="br0">&#125;</span>
&#160;
 <span class="co1">// Enable the &quot;vertex&quot; attribute to bind it to our currently bound</span>
 <span class="co1">// vertex buffer.</span>
 m_shader.<span class="me1">setAttributeBuffer</span><span class="br0">&#40;</span> <span class="st0">&quot;vertex&quot;</span><span class="sy0">,</span> GL_FLOAT<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">4</span> <span class="br0">&#41;</span><span class="sy0">;</span>
 m_shader.<span class="me1">enableAttributeArray</span><span class="br0">&#40;</span> <span class="st0">&quot;vertex&quot;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>We begin by checking that we do in fact have an OpenGL context with multi-sampling enabled. We then set the clear colour to black.
</p><p>Next we call the prepareShaderProgram() passing in the paths of the vertex and fragment shader sources. In this case the sources are in the project's resource file. We will look at this function in more detail shortly.
</p><p>The next step is to define a simple array of floats representing the vertices of our geometry- a single triangle. We then ask the QGLBuffer object to actually create the underlying OpenGL buffer object and we tell it the intended usage pattern for this buffer. In this case we will never be changing the vertices so QGLBuffer::StaticDraw is a sensible choice. The next step is to bind the buffer to the OpenGL context and insert the actual vertex data into it. The above is likely to result in the vertex data being uploaded to the dedicated graphics memory of your GPU. I say likely as the final choice of where to locate the data is left to the OpenGL driver.
</p><p>Now that the OpenGL driver knows about our vertex buffer we can associate it with a variable in the shader program. As we will see shortly, the vertex shader contains an input variable called "vertex". The final part of the initialiseGL() function tells OpenGL context and driver that we wish to use the currently bound vertex buffer as the "vertex" variable in the shader, what type the buffer contains (GL_FLOAT) and how many elements are in each vertex (4 in this case).
</p><p>On some setups (Windows 7, NVidia 9800 GT using drivers 285.62), it is required to bind a VAO before setting up the attributes. This behavior is part of the OpenGL 3.3 core profile. This is done by calling:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"> uint vao<span class="sy0">;</span>
 glGenVertexArrays<span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span> <span class="sy0">&amp;</span>vao<span class="br0">&#41;</span><span class="sy0">;</span>
 glBindVertexArray<span class="br0">&#40;</span>vao<span class="br0">&#41;</span><span class="sy0">;</span></pre></div></div>
<p>Unfortunately, those functions are not loaded by Qt and they must be accessed using a GL loader library or by manually calling wglGetProcAddress.
</p><p>Here is the prepareShaderProgram() function mentioned above:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw4">bool</span> GLWidget<span class="sy0">::</span><span class="me2">prepareShaderProgram</span><span class="br0">&#40;</span> <span class="kw4">const</span> <span class="kw5">QString</span><span class="sy0">&amp;</span> vertexShaderPath<span class="sy0">,</span>
 <span class="kw4">const</span> <span class="kw5">QString</span><span class="sy0">&amp;</span> fragmentShaderPath <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 <span class="co1">// First we load and compile the vertex shader…</span>
 <span class="kw4">bool</span> result <span class="sy0">=</span> m_shader.<span class="me1">addShaderFromSourceFile</span><span class="br0">&#40;</span> QGLShader<span class="sy0">::</span><span class="me2">Vertex</span><span class="sy0">,</span> vertexShaderPath <span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>result <span class="br0">&#41;</span>
 qWarning<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">&lt;&lt;</span> m_shader.<span class="kw3">log</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="co1">// …now the fragment shader…</span>
 result <span class="sy0">=</span> m_shader.<span class="me1">addShaderFromSourceFile</span><span class="br0">&#40;</span> QGLShader<span class="sy0">::</span><span class="me2">Fragment</span><span class="sy0">,</span> fragmentShaderPath <span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>result <span class="br0">&#41;</span>
 qWarning<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">&lt;&lt;</span> m_shader.<span class="kw3">log</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="co1">// …and finally we link them to resolve any references.</span>
 result <span class="sy0">=</span> m_shader.<span class="me1">link</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="kw1">if</span> <span class="br0">&#40;</span> <span class="sy0">!</span>result <span class="br0">&#41;</span>
 qWarning<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">&lt;&lt;</span> <span class="st0">&quot;Could not link shader program:&quot;</span> <span class="sy0">&lt;&lt;</span> m_shader.<span class="kw3">log</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="kw1">return</span> result<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>All this function does is to load and compile the source code for the vertex and fragment shaders respectively and then link them together into a complete shader program handily encapsulated in a QGLShaderProgram. Individual shaders are analogous to compilation units in C/C++ and must go through a final linking stage to make a functional binary or in this case a shader program. The linking stage, amongst other things, ensures that the variables used to interface between the vertex and fragment shaders match up.
</p><p>The final part of the OpenGL initialisation is the implementation of the resizeGL() function:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw4">void</span> GLWidget<span class="sy0">::</span><span class="me2">resizeGL</span><span class="br0">&#40;</span> <span class="kw4">int</span> w<span class="sy0">,</span> <span class="kw4">int</span> h <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 <span class="co1">// Set the viewport to window dimensions</span>
 glViewport<span class="br0">&#40;</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> w<span class="sy0">,</span> qMax<span class="br0">&#40;</span> h<span class="sy0">,</span> <span class="nu0">1</span> <span class="br0">&#41;</span> <span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Qt calls this function for us in response to a resizeEvent. In our case all we need to do is to adjust the OpenGL viewport transformation that is performed after the fragment shader. All we do is make sure that our viewport fills the available space.
</p><p>Note that in this simple example we are not using any custom perspective or orthogonal view transformations. Instead we are relying on the default OpenGL view transformation that maps the rectangle (–1, -1)- (1, 1) to the viewport.
</p>
<h2><span class="mw-headline" id="Drawing">Drawing</span></h2>
<p>Now we are ready to draw something! Note that following the above initialiseGL() function we still have our shader program and vertex buffer bound to the OpenGL context so there is no need to rebind them each time we draw. This results in a trivial paintGL() function:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw4">void</span> GLWidget<span class="sy0">::</span><span class="me2">paintGL</span><span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 <span class="co1">// Clear the buffer with the current clearing color</span>
 glClear<span class="br0">&#40;</span> GL_COLOR_BUFFER_BIT <span class="sy0">|</span> GL_DEPTH_BUFFER_BIT <span class="br0">&#41;</span><span class="sy0">;</span>
&#160;
<span class="co1">// Draw stuff</span>
 glDrawArrays<span class="br0">&#40;</span> GL_TRIANGLES<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">3</span> <span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>All we do is clear the colour and depth buffers and tell OpenGL to draw our currently bound vertex buffer using the currently bound shader program. What could be easier?&#160;;-)
</p>
<h2><span class="mw-headline" id="Miscellaneous">Miscellaneous</span></h2>
<p>The only remaining part of the C++ implementation is the keyPressEvent() handler.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="kw4">void</span> GLWidget<span class="sy0">::</span><span class="me2">keyPressEvent</span><span class="br0">&#40;</span> <span class="kw5">QKeyEvent</span><span class="sy0">*</span> e <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 <span class="kw1">switch</span> <span class="br0">&#40;</span> e<span class="sy0">-&gt;</span><span class="me3">key</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#41;</span>
 <span class="br0">&#123;</span>
 <span class="kw1">case</span> <span class="kw5">Qt</span><span class="sy0">::</span><span class="me2">Key_Escape</span><span class="sy0">:</span>
 <span class="kw5">QCoreApplication</span><span class="sy0">::</span><span class="me2">instance</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me3">quit</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
 break<span class="sy0">;</span>
&#160;
<span class="kw1">default</span><span class="sy0">:</span>
 <span class="kw5">QGLWidget</span><span class="sy0">::</span><span class="me2">keyPressEvent</span><span class="br0">&#40;</span> e <span class="br0">&#41;</span><span class="sy0">;</span>
 <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>This just makes the application quit when the escape key is pressed.
</p>
<h2><span class="mw-headline" id="The_Shaders">The Shaders</span></h2>
<h3><span class="mw-headline" id="The_Vertex_Shader">The Vertex Shader</span></h3>
<p>The vertex shader is simplicity itself:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="co2">#version 330</span>
&#160;
in vec4 vertex<span class="sy0">;</span>
&#160;
<span class="kw4">void</span> main<span class="br0">&#40;</span> <span class="kw4">void</span> <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 gl_Position <span class="sy0">=</span> vertex<span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>It begins with a pre-processing instruction telling the glsl compiler that it requires glsl version 330 which corresponds to OpenGL 3.3. We then declare an input variable of type vec4 (a 4D vector as you might expect). This is the variable to which we linked the vertex buffer object at the end of the initialiseGL() function.
</p><p>The shader entry point is the main() function. This is called once per vertex. So in this simple example it will get called 3 times, once for each vertex of our triangle, per redraw. All it does is to assign the vextex coordinates to the built-in (implicitly declared) variable gl_Position.
</p><p>Following execution of the vertex shader the OpenGL drivers performs some fixed functionality such as primitive assembly and rasterisation. The output of the rasterisation stage is a stream of "fragments". Fragments are a data structure corresponding to a pixel plus some additional data. These fragments are then operated on by the fragment shader.
</p>
<h3><span class="mw-headline" id="The_Fragment_Shader">The Fragment Shader</span></h3>
<p>The fragment shader is also simple:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1"><span class="co2">#version 330</span>
&#160;
layout<span class="br0">&#40;</span>location <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">,</span> index <span class="sy0">=</span> <span class="nu0">0</span><span class="br0">&#41;</span> out vec4 fragColor<span class="sy0">;</span>
&#160;
<span class="kw4">void</span> main<span class="br0">&#40;</span> <span class="kw4">void</span> <span class="br0">&#41;</span>
<span class="br0">&#123;</span>
 fragColor <span class="sy0">=</span> vec4<span class="br0">&#40;</span> <span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span> <span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Once again we have the pre-processor instruction as in the vertex shader.
</p><p>Next we declare the output variable, fragColor, that will hold the colour for this fragment that will be passed onto the last parts of the OpenGL pipeline (depth-testing, scissor-testing, blending etc.). The layout() syntax just tells OpenGL which variable in the blending equation the output of this fragment shader maps to.
</p><p>The entry-point is once again the main() function which simply forces each fragment to an opaque red colour.
</p>
<h2><span class="mw-headline" id="Building_and_Running">Building and Running</span></h2>
<p>The example application can be built by doing the usual:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="cpp-qt source-cpp-qt"><pre class="de1">qmake <span class="sy0">&amp;&amp;</span> make</pre></div></div>
<p>or by using Qt-Creator. Upon running the application you should see the following on screen:
</p>
<!-- 
NewPP limit report
CPU time usage: 0.255 seconds
Real time usage: 0.264 seconds
Preprocessor visited node count: 172/1000000
Preprocessor generated node count: 380/1000000
Post‐expand include size: 1360/2097152 bytes
Template argument size: 435/2097152 bytes
Highest expansion depth: 5/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key qtio_wiki:pcache:idhash:989-0!*!0!!en!*!* and timestamp 20151104152811 and revision id 18223
 -->
</div>								<div class="printfooter">
				Retrieved from "<a href="index9030.html?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;oldid=18223">http://wiki.qt.io/index.php?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;oldid=18223</a>"				</div>
												<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Categories</a>: <ul><li><a href="Category_Articles_needing_cleanup.html" title="Category:Articles needing cleanup">Articles needing cleanup</a></li><li><a href="Category_HowTo.html" title="Category:HowTo">HowTo</a></li><li><a href="Category_Developing_with_Qt__General.html" title="Category:Developing with Qt::General">Developing with Qt::General</a></li><li><a href="Category_Tutorial.html" title="Category:Tutorial">Tutorial</a></li><li><a href="Category_Developing_with_Qt__QtOpenGL.html" title="Category:Developing with Qt::QtOpenGL">Developing with Qt::QtOpenGL</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="User_10.0.113.html" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="User_talk_10.0.113.html" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="https://login.qt.io/authorize?client_id=one-qt-server-003&amp;response_type=code&amp;state=becd3486871bab6a&amp;scope=authorizations&amp;redirect_uri=https%3A%2F%2Fwiki.qt.io%2FSpecial%3AQtLogin%2Fcallback" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="How_to_use_OpenGL_Core_Profile_with_Qt.html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="Talk_How_to_use_OpenGL_Core_Profile_with_Qt.html?title=Talk:How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="How_to_use_OpenGL_Core_Profile_with_Qt.html" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="index272c.html?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="indexf722.html?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(skins/common/images/wiki.png);" href="Main_Page.html"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="How_to_create_columns_in_a_QML_ListView.html" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/How_to_use_OpenGL_Core_Profile_with_Qt.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/How_to_use_OpenGL_Core_Profile_with_Qt.html" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-print"><a href="index420f.html?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
			<li id="t-permalink"><a href="index9030.html?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;oldid=18223" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="index691e.html?title=How_to_use_OpenGL_Core_Profile_with_Qt&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 27 June 2015, at 21:05.</li>
											<li id="footer-info-viewcount">This page has been accessed 5,947 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="load55ad.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":199});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/How_to_use_OpenGL_Core_Profile_with_Qt by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 08:40:06 GMT -->
</html>
