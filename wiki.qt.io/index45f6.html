<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=API_Design_Principles/ru&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:54:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>View source for API Design Principles/ru - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"API_Design_Principles/ru","wgTitle":"API Design Principles/ru","wgCurRevisionId":19208,"wgRevisionId":0,"wgArticleId":36,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"API_Design_Principles/ru","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-API_Design_Principles_ru skin-vector action-edit vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for API Design Principles/ru</span></h1>
						<div id="bodyContent">
								<div id="contentSub">← <a href="http://wiki.qt.io/API_Design_Principles/ru" title="API Design Principles/ru">API Design Principles/ru</a></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in one of the groups: <a href="http://wiki.qt.io/index.php?title=Qt_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Qt Wiki:Users (page does not exist)">Users</a>, KnowledgeBase, QtWS.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{Cleanup | reason=Auto-imported from ExpressionEngine.}}

[[Category:Developing_Qt::Guidelines]]
'''Русском''' [[API-Design-Principles|English]]

= Принципы проектирования API =

Одно из достоинств Qt — это его логичный, легкий для изучения и мощный API. С помощью этой статьи мы попытаемся подытожить все те знания, которые мы получили, проектируя API для Qt. Часть рекомендаций являются универсальными, а другие — более традиционными, и мы следуем им в основном для совместимости с уже существующими API.

Эти рекомендации в первую очередь касаются внешних API, но их так же можно использовать и для проектирования внутренних, тем самым помогая вашим коллегам разработчикам.

Если вам интересна эта тема, то можно почитать [http://chaos.troll.no/~shausman/api-design/api-design.pdf "Маленькая инструкция по проектированию API"] Жасмин Бланшет.

== Шесть характеристик хорошего API ==

API для программиста — это как GUI для пользователя. Буква "P" в аббревиатуре API означает "Программист", а не "Программа", что бы подчеркунуть тот факт, что API пользуются программисты.

В статье [http://doc.qt.nokia.com/qq/qq13-apis.html Qt Quarterly 13 article about API design] Маттиас считает, что API должен быть минимальным и полным, иметь прозрачную и простую семантику, быть интуитивно понятным и легко запоминаться, а также способствовать написанию читаемого кода.

* '''Быть минимальным''': Минимальный API содержит как можно меньше открытых методов на класс и как можно меньше классов. Благодаря этому можно легко понять, запомнить, тестировать и изменять API.
* '''Быть полным''': Полное API подразумевает покрытие всей функциональности. Правда, это мешает сохранению минимальности. А еще, если член класса, находится в неправильном классе, то это приведет к тому, что пользователи не смогут найти эту функцию.
* '''Обладать прозрачной и просто семантикой''': Необходимо следовать принципу наименьшего удивления: сделать общие задачи проще. Должна быть возможность выполнять редкие задачи, но не стоит заострять внимание на них. Надо решать конкретные проблемы, а не делать общие решения, когда в этом нет необходимости. (Например, QMimeSourceFactory в Qt 3 можно было бы назвать QImageLoader с иным API.)
* '''Интуитивно понятный''': API, как и все остальное в компьютере, должно быть интуитивно понятным. Разные условия и опыт приводят к разным взглядам на то, что является интуитивным, а что — нет. Интуитивно понятное API, это такое API, которым может пользоваться среднестатистический пользователь, не читая документацию и программист, который не знает API, может понять код, в котором он используется.
* '''Легко запоминающийся''': Что бы сделать API легко запоминающимся, необходимо использовать прямые и точные названия. Использовать наглядные шаблоны и концепции, избегая сокращений.
* '''Способствовать написанию читаемого кода''': Код пишется один раз, но затем читается (и тестируется, и изменяется) множество раз. Написание читаемого кода может потребовать больше времени, чем обычно, но сэкономит время на протяжении всего жизненного цикла продукта.

Ну и наконец, имейте ввиду, что разные пользователи будут пользоваться разными частями API. Даже если пользоваться экземпляром класса Qt легко, пользователь все же прочтет документацию, прежде чем наследовать этот класс.

== Статический полиморфизм ==

У похожих классов должно быть cхожее API. Это можно реализовать с помощью наследования, когда в этом есть смысл (при условии, что используется полиморфизм времени выполнения). Но полиморфизм всречается и во время проектирования. Например, решив заменить QProgressBar на QSlider или QString на QByteArray, можно обнаружить, что схожесть API позволяет очень легко выполнить эту замену. Мы называем это "статический полиморфизм".

Благодаря статическому полиморфизму легко запоминать API и шаблоны проектирования. Как следствие, схожее API для множества связанных классов иногда лучше, чем безупречные разные API для каждого класса.

В основном, в Qt, мы предпочитаем использовать статический полиморфизм, а не наследование, если на то нет никаких веских причин. Благодаря этому сохраняется набор открытых классов в Qt, а новички в Qt легко находят необходимые функции в документации.

'''Хорошо''': QDialogButtonBox и QMessageBox обладают схожим API для работы с кнопками (addButton(), setStandardButtons(), и др.), не наследуя какой нибудь "QAbstractButtonBox" класс.

'''Плохо''': QAbstractSocket наследуют и QTcpSocket и QUdpSocket: два класса с разными видами взаимодействия. Никто, кажется, никогда не пользовался указателем на QAbstractSocket универсальным или полезным способом.

'''Сомнительно''': QBoxLayout — базовый класс для QHBoxLayout и QVBoxLayout. Преимущество: можно использовать QBoxLayout и вызывать метод setOrientation() в панели инструментов, чтобы сделать его вертикальным/горизонтальным. Недостатки: Один лишний класс, и пользователи могут писать ((QBoxLayout*)hbox)->setOrientation(Qt::Vertical), что лишено смысла.

== API, основанное на свойствах ==
Новые классы Qt, как правило, используют API, основанное на свойствах. Например:

&lt;code>
 QTimer timer;
 timer.setInterval(1000);
 timer.setSingleShot(true);
 timer.start();
&lt;/code>

Под ''свойством'' подразумевается любой атрибут, который является частью состояния объекта, пусть даже это не настоящий Q_PROPERTY. По-возможности, пользователь должен уметь устанавливать свойства в любом порядке, т.е. свойства должны быть ортогональными. Например, предыдущий код можно записать так

&lt;code>
 QTimer timer;
 timer.setSingleShot(true);
 timer.setInterval(1000);
 timer.start();
&lt;/code>

Для ''удобства'' мы можем написать так &lt;tt>timer.start(1000)&lt;/tt>.

Аналогично для QRegExp

&lt;code>
 QRegExp regExp;
 regExp.setCaseSensitive(Qt::CaseInsensitive);
 regExp.setPattern("'''.'''");
 regExp.setPatternSyntax(Qt::WildcardSyntax);
&lt;/code>

Платой, за реализацию такого API, является позднее конструирование объекта. Например, в случае с QRegExp, нет возможности выполнить преждевременную компиляцию шаблона "'''.'''" в setPattern(), потому что мы не знаем, какой стиль шаблона будем использовать.

Зачастую надо быть осторожным, потому что свойства часто устанавливаются каскадно. Обратите внимание на "размер иконки по-умолчанию" в текущем стиле и свойство "iconSize" QToolButton:

&lt;code>
 toolButton->iconSize(); // возвращает значение по-умолчанию для текущего стиля
 toolButton->setStyle(otherStyle);
 toolButton->iconSize(); // возвращает значение по-умолчанию для otherStyle
 toolButton->setIconSize(QSize(52, 52));
 toolButton->iconSize(); // возвращает (52, 52)
 toolButton->setStyle(yetAnotherStyle);
 toolButton->iconSize(); // возвращает (52, 52)
&lt;/code>

Обратите внимание, что единожды установив iconSize, это свойство больше не изменяется, даже если изменить текущий стиль. Это очень удобно. Иногда, этим можно воспользоваться для сброса свойства. Отсюда вытекает два подхода:

* для "сброса", воспользоваться специальным значением (например QSize(), –1, Qt::Alignment(0))
* иметь специальную функцию resetFoo() или unsetFoo()

Для "сброса" свойства iconSize достаточно установить ему значение QSize() (что эквивалентно, QSize(–1, -1))

Иногда, геттеры возвращают не те значения, которые мы записали перед этим. Например, если вызвать widget->setEnabled(true), то widget->isEnabled() может вернуть false, при условие, что родительский виджет будет в выключенном состоянии. И это нормально, потому что нас интересует действительное состояние (виджет, родитель которого находится в выключенном состоянии, должен быть тоже неактивным и вести себя, как будто он тоже выключен. В то же время, где-то внутри, он все же "включен" и просто ждет, пока родитель снова перейдет во включенное состояние), но такие ситуации должны быть документированы.

== Особенности С++ ==

=== Значение против Объекта ===

=== Указатели против Ссылок ===

Какой тип для выходных параметров лучше, указатели или ссылки?

&lt;code>
 void getHsv(int *h, int *s, int *v) const
 void getHsv(int &amp;h, int &amp;s, int &amp;v) const
&lt;/code>

В книгах по С++ рекомендуют использовать ссылки, где только есть возможность, аргументируя это тем, что в основном, ссылки "приятнее и безопаснее" указателей. А мы, в Qt Software предпочитаем чаще использовать указатели, потому что код пользователя становиться более читабельным. Сравните:

&lt;code>
 color.getHsv(&amp;h, &amp;s, &amp;v);
 color.getHsv(h, s, v);
&lt;/code>

Только в первой строчке сразу становится понятно, что h, s, и v с высокой долей вероятности, будут модифицированы функцией.

=== Виртуальные функции ===

Когда метод класса объявлен, как виртуальный, то напрямую можно изменить поведение функции, если перегрузить ее в производном классе. Делать функции виртуальными надо в том случае, если есть необходимость вызвать ваш код, вместо кода функции. Нужно хорошо подумать, прежде чем объявить функцию виртуальной, если извне класса никто не может ее вызвать.

&lt;code>
 // QTextEdit в Qt 3: методы, которые нет смысла делать виртуальными
 virtual void resetFormat();
 virtual void setUndoDepth( int d );
 virtual void setFormat( QTextFormat '''f, int flags );
 virtual void ensureCursorVisible();
 virtual void placeCursor( const QPoint &amp;pos;, QTextCursorc = 0 );
 virtual void moveCursor( CursorAction action, bool select );
 virtual void doKeyboardAction( KeyboardAction action );
 virtual void removeSelectedText( int selNum = 0 );
 virtual void removeSelection( int selNum = 0 );
 virtual void setCurrentFont( const QFont &amp;f );
 virtual void setOverwriteMode( bool b ) { overWrite = b; }
&lt;/code>

Когда мы портировали QTextEdit с Qt 3 на Qt 4, мы удалили практически все виртуальные функции. Интересно (но в то же время неожиданно), что никто на это не жаловался. Почему? Потому что в Qt 3 не использовался полиморфизм. В Qt 3 не вызывались эти функции, их вызывали вы. Проще говоря, не было причин делать производный класс от QTextEdit и переопределять эти функции, если только вы самостоятельно не вызвали эти функции. Если вам нужен полиморфизм в вашем приложении вне Qt, можно добавить полиморфизм самостоятельно.

==== Как избежать виртуальных функций ====
В Qt мы стараемся минимизировать колличество виртуальных функций по ряду причин. Каждый виртуальный вызов усложняет исправление ошибок, вставляя неконтролируемые узлы в список вызовов (результат получается непредсказуемым). Люди, внутри перегруженных функций, делают страшные вещи, например:

''' посылают события
* посылают сигналы
* повторно входят в цикл обработки событий (например, открывают диалог выбора файла)
* удаляют объекты (что иногда приводит к "удалению this")

Есть и другие причины, по которым стоит избегать чрезмерного использования виртуальных функций:

* невозможно добавлять, перемещать или удалять виртуальные функции, не ломая то, что уже написано
* тяжело перегружать виртуальные функции
* компиляторы практически никогда не делают оптимизацию или встраиваемые вызовы виртуальных функций
* для вызова виртуальной функции необходим поиск по таблице виртуальных функций, что замедляет работу, по сравнению с нормальным вызовом, в 2-3 раза
* из-за виртуальных функций тяжело копировать класс по значению (возможно, но грубо, что делать не рекомендуется)

Опыт показал, что в классах без виртуальных функций как правило проявляется меньше ошибок и для их поддержки нужно меньше ресурсов.

Общее правило гласит, если в основном пользователи будут вызывать метод класса, то он скорее всего должен быть не виртуальным.

==== Виртуальность против возможности копировать ====

Полиморфные объекьты и классы, передающиеся по значению — плохие друзья.

В классах, с виртуальными функциям должны быть объявлены виртуальные деструкторы, чтобы избежать утечек памяти, когда удаляется базовый класс и не чистится память производного класса.

Если необходимо копировать и присваивать класс, или сравнивать по значению, скорее всего необходим определить конструктор копирования, оператор присваивания и операторы сравнения.

&lt;code>
 class CopyClass {
 public:
 CopyClass();
 CopyClass(const CopyClass &amp;other;);
 ~CopyClass();
 CopyClass &amp;operator;=(const CopyClass &amp;other;);
 bool operator==(const CopyClass &amp;other;) const;
 bool operator!=(const CopyClass &amp;other;) const;

virtual void setValue(int v);
 };
&lt;/code>

Если создать производный класс от этого класса, ваш код может начать вести себя неожиданно. В обычной ситуации, когда нет виртуальных функций и виртуальных деструкторов, люди не могут создать производный класс и полагаться на полиморфизм. Но если добавить виртуальные функции или виртуальный деструктор, могут возникнуть причины, для создания производного класса, и все становится сложнее. ''На первый взгляд все выглядит просто, ведь можно объявить виртуальные операторы''. Но этот путь может привести к хаосу и падению (не читаемому коду). Взгляните на этот пример:

&lt;code>
 class OtherClass {
 public:
 const CopyClass &amp;instance;() const; // что тут возвращается? Что я могу ему присвоить?
 };
&lt;/code>

(этот раздел находится в разработке)

=== Константность ===

В С++ есть ключевое слово "const", которым можно пометить то, что нельзя менять или то, что имеет побочный эффект. Его можно применить к простым значениям, указателям, тому, на что они указывают и как атрибут к функциям, которые не должны менять состояние объекта.

Стоит отметить что "const", само по себе, не несет никакого смысла — во множестве языков нет эквивалента ключевому слову "const", но это не делает их функционально не полными. На самом деле, если удалить перегруженные функции и, используя поиск и замену, удалить все вхождения слова "const" из С++ кода, с большой вероятностью он откомпилируется и будет нормально работать. Очень важно сохранять прагматичный подход к использованию "const".

Давайте пройдемся по областям, где используется "const" и которые относятся к проектированию API в Qt:

==== Входящие аргументы: константные указатели ====

Константные функции, которые принимают в качестве входящих параметров указатели, практически всегда должны принимать константные указатели.

Если функция определена, как const, это значит, что она никогда не будет подвержена побочному эффекту, т.е. не изменит видимого состояния объекта. Так зачем же тогда передавать не константные входящие аргументы? Давайте вспомним, что константные функции часто вызываются из других константных функций, в которых тяжело использовать не константные параметры (без const_cast и, там, где это возможно, мы действительно стараемся избежать const_cast).

До:

&lt;code>
 bool QWidget::isVisibleTo(QWidget *ancestor) const;
 bool QWidget::isEnabledTo(QWidget *ancestor) const;
 QPoint QWidget::mapFrom(QWidget *ancestor, const QPoint &amp;pos;) const;
&lt;/code>

В QWidget определено много константных функций, которые в качестве входных параметров принимают не константный указатель. Напомним, что такие функции могут модифицировать виджет, но не могут модифицировать объект, которому принадлежат. Такие функции часто сопровождаются const_casts. Было бы неплохо, если бы эти функции принимали константный указатель в качестве аргументов.

После:

&lt;code>
 bool QWidget::isVisibleTo(const QWidget *ancestor) const;
 bool QWidget::isEnabledTo(const QWidget *ancestor) const;
 QPoint QWidget::mapFrom(const QWidget *ancestor, const QPoint &amp;pos;) const;
&lt;/code>

Хочется отметить, что для QGraphicsItem мы это исправили, а вот QWidget должен подождать до Qt 5:

&lt;code>
 bool isVisibleTo(const QGraphicsItem *parent) const;
 QPointF mapFromItem (const QGraphicsItem *item, const QPointF &amp;point;) const;
&lt;/code>

==== Возвращаемые значения: константные значения ====

Результатом вызова функции, которая не возвращает ссылку будет R-value(то, что может стоять справа в операции присвоения).

Даже если синтаксически возможно добавить "const" к встроенным типам данных, в этом нет никакого смысла, т.к. это ничего не изменит в плане прав доступа. Современные компиляторы даже выведут предупреждение, встретив подобный код.

Если добавить "const" к классовому R-value, то доступ к не константным методам будет закрыт, так же, как и прямая работа с его членами.

Если не добавить "const", то такой доступ возможен, но он редко необходим, потому что время жизни R-value объекта ограничено и равно времени выполнения выражения.

Пример:

&lt;code>
 struct Foo
 {
 void setValue(int v) { value = v; }
 int value;
 };

Foo foo()
 {
 return Foo();
 }

const Foo cfoo()
 {
 return Foo();
 }

int main()
 {
 // Следующий код компилируется, foo() не константное R-value значение, которому нельзя ничего
 // присвоить, но можно получить доступ к L-value членам:
 foo().value = 1; // Ok, но значение временное и будет удалено после того, как выражение полностью выполнится.

// Следующий код компилируется, foo() не константное R-value значение, которому нельзя ничего
 // присвоить, но можно получить доступ к его методам (даже не константным):
 foo().setValue(1); // Ok, но значение временное и будет удалено после того, как выражение полностью выполнится.

// Следующий код НЕ компилируется, foo() константное R-value,
 // с константными членами, к которым нет доступа:
 cfoo().value = 1; // Not ok.

// Следующий код НЕ компилируется, foo() константное R-value,
 // у которого нельзя вызвать не константный метод:
 cfoo().setValue(1); // Not ok
 }
&lt;/code>

==== Возвращаемые значения: указатели против константных указателей ====

Тема о том, когда константная функция должна возвращать указатели, а когда константные указатели, склоняет большинство людей к тому, что концепция "правильной константности" в С++ не работает. Проблемы начинаются, когда константная функция, которая не должна модифицировать внутреннее состояние объекта, возвращает не константный указатель на член. Просто действие, по возврату указателя, не меняет ни видимого состояния объекта, ни его возможностей. Но дает программисту косвенный доступ, для модификации данных объекта.

Этот пример демонстрирует один из нескольких способов обойти константность используя константную функцию, которая возвращает не константный указатель:

&lt;code>
 QVariant CustomWidget::inputMethodQuery(Qt::InputMethodQuery query) const
 {
 moveBy(10, 10); // doesn't compile!
 window()->childAt(mapTo(window(), rect().center()))->moveBy(10, 10); // компилируется!
 }
&lt;/code>

Функции, которые возвращают константный указатель, действительно защищают от подобной ситуации (возможно нежелательной\неожиданной), по крайней мере до определенной степени. Но какие функции предпочли бы вы? Те, которые возвращают константный указатель или те, которые возвращают их список? Если следовать концепции "правильной константности", каждая константная функция, которая возвращает указатель на член объекта (или список указателей на члены), должна возвращать константный указатель. На практике, такая концепция приводит к негодному API:

&lt;code>
 QGraphicsScene scene;
 // … populate scene

foreach (const QGraphicsItem '''item, scene.items()) {
 item->setPos(qrand() % 500, qrand() % 500); // не компилируется! Элемент - константный указатель
 }
&lt;/code>

''QGraphicsScene::items()'' — константная функция, и вы наверно подумаете, что она должна возвращать только константный указатель.

В Qt мы используем не константные шаблоны практически повсеместно. Мы выбрали прагматический подход: результат возврата константного указателя приведет к злоупотреблению const_cast, что создаст больше проблем, чем возврат не константного указателя.

==== Возвращаемые значения: по значению или константной ссылке? ====
Если у нас есть копия возвращаемого объекта, быстрее будет работать возврат константной ссылки. Однако, это может помешать нам в будущем, если, например, мы захотим переписать класс. (Используя идеологию d-указателей, мы можем менять представление класса в памяти, но одновременно, мы не можем поменять сигнатуру функций с "const QFoo &amp;" на "QFoo" и при этом не потерять бинарную совместимость.) Именно из-за этого, мы в основном возвращаем "QFoo" вместо "const QFoo &amp;", кроме тех случаев, когда критична скорость, а рефакторинг — не проблема (например, QList::at()).

==== Константность против состояния объекта ====
Константная корректность в С++ активно обсуждается, потому что в некоторых областях она не работает.

Основное правило гласит, что константные функции не меняют видимого состояния класса. Под состоянием подразумевается "себя и свои возможности". Это не значит, что не константные функции, в отличии от константных, меняют приватные члены класса. А значит, что эти функции активные, и могут иметь видимые побочные эффекты. Константные функции в общем случае не обладают обратными эффектами. К примеру:

&lt;code>
 QSize size = widget->sizeHint(); // const
 widget->move(10, 10); // not const
&lt;/code>

Делегат отвечает за рисование на чем-то. Его состояние включает и его возможности, а значит, и состояние того, на чем он рисует. Вызов рисования влечет за собой побочный эффект. Оно меняет внешний вид устройства (а значит и состояние), рисуя на нем. Поэтому, нет смысла делать paint() константным методом, как и paint() диалогов или QIcon. Никто не будет вызывать QIcon::paint() из константной функции. А если уж очень нужно, можно явно снять константность функции, поэтому в таких случая проще воспользоваться const_cast.

&lt;code>
 // QAbstractItemDelegate::paint is const
 void QAbstractItemDelegate::paint(QPainterpainter, const QStyleOptionViewItem &amp;option;, const QModelIndex &amp;index;) const

 // QGraphicsItem::paint is not const
 void QGraphicsItem::paint(QPainter''' painter, const QStyleOptionGraphicsItem '''option, QWidget '''widget = 0)
&lt;/code>
.

== Семантика и документация API ==
Что необходимо делать, когда функция возвращает –1? и т.д.

Предупреждения/ошибки/и т.д.

API должно быть качественным. Первая версия всегда будет с ошибками, поэтому ее нужно протестировать. Взгляните на код, использующий это API и убедитесть в том, что он читабелен.

Еще один прием — попросить кого нибудь воспользоваться вашим API с/без документацией(-ии) и документировать класс (как в общем весь класс, так и каждый метод).

Ключевое слово const не должно "работать" на вас. Попробуйте избавиться от него, чтобы исключить две перегруженные версии функции (константная и не константная).

== Искусство присваивания имен ==
Одна из самых больших проблем проектирования API — присваивание имен. Как должен называться класс? Как должны называться его методы?

=== Главные правила присваивания имен ===
Несколько правил можно отнести ко всем видам имен. Во-первых, как уже было сказано, не пользуйтесь аббревиатурами. Даже если "previous" вы замените на "prev", в будущем это только сыграет против вас, потому что пользователь должен помнить, какие слова используются в виде аббревиатур.

Еще хуже, если в API встречаются двойственные варианты. Например, в Qt 3 есть activatePreviousWindow() и fetchPrev(). Следуя правилу "никаких аббревиатур" легче сделать непротиворечивое API.

Другое, важное, но более тонкое правило: когда проектируются классы, необходимо попытаться сохранить пространство имен для производных классов чистым. В Qt 3, не всегда соблюдается этот принцип. Что бы продемонстрировать это, приведем в пример QToolButton. Если назвать name(), caption(), text(), или textLabel() в QToolButton в Qt 3, к чему это приведет? Попробуйте поиграться с QToolButton в дизайнере:

* Свойство name наследуется от QObject и ссылается на внутреннее имя объекта, которое можно использовать для отладки и тестирования.
* Свойство caption наследуется от QWidget и ссылается на заголовок окна, который никак не влияет на объекты QToolButton, потому что у них очень часто есть родитель.
* Свойство text наследуется от QButton и используется в кнопке, если только useTextLabel не установленно в true.
* Свойство textLabel определено в QToolButton и отображается на кнопке, если useTextLabel установленно в true.

Для облегчения читабельности в Qt 4 в классе QToolButton name преименовано на objectName, caption на windowTitle, а свойство textLabel вообще удалено.

В поиске имен можно воспользоваться хитростью и просто попробовать написать документацию: задокументировать элементы (классы, функции, перечисления и др.) и использовать первое предложения, как основу для создания имени. Если трудно найти подходящее имя, это первый сигнал, который ставит под сомнение необходимость данного элемента. Если не получается найти подходящее имя, но вы уверенны, что такой элемент должен существовать, нужно придумать абсолютно новое имя. Таким образом появились имена "widget", "event", "focus", "buddy".

=== Присвоение имен классам ===
Нужно искать группы классов, вместо того, что бы подбирать каждому классу индивидуальное имя. Например, в Qt 4 классы для отображения моделей имеют суффикс View (QListView, QTableView, и QTreeView), а классы, для отображения элементов — Widget (QListWidget, QTableWidget, and QTreeWidget).

=== Имена для перечисляемых типов и значений ===
Когда мы определяем перечисляемый тип, нужно держать во внимание, что в С++ (в отличии от Java или С#), значения перечисляемого типа используются без названия самого типа. Следующий пример показывает, на сколько опасно использовать общие имена в значениях перечисляемого типа:

&lt;code>
 namespace Qt
 {
 enum Corner { TopLeft, BottomRight, … };
 enum CaseSensitivity { Insensitive, Sensitive };
 …
 };

 tabWidget->setCornerWidget(widget, Qt::TopLeft);
 str.indexOf("$(QTDIR)", Qt::Insensitive);
&lt;/code>

В последней строчке что может значить Insensitive? Одна из рекомендаций: хотя бы один элемент перечислимого типа должен повторяться во всех значениях этого типа:

&lt;code>
 namespace Qt
 {
 enum Corner { TopLeftCorner, BottomRightCorner, … };
 enum CaseSensitivity { CaseInsensitive,
 CaseSensitive };
 …
 };

 tabWidget->setCornerWidget(widget, Qt::TopLeftCorner);
 str.indexOf("$(QTDIR)", Qt::CaseInsensitive);
&lt;/code>

Если перечислимые значения могут подвергаться операции OR и использоваться, как флажки, то результат операции будет храниться в переменной типа int, что не так уж и хорошо. В Qt 4 есть шаблонный класс QFlags, где T — перечислимый тип. Для удобства в Qt определяется новый тип для имен флага, и можно просто писать Qt::Alignment вместо QFlags&lt;Qt::AlignmentFlag>.

Было решено, для перечислимого типа использовать имена в единственном числе (потому что в один момент времени может содержать только один флаг), а для "флажков" — в множественном. Например:

&lt;code>
 enum RectangleEdge { LeftEdge, RightEdge, … };
 typedef QFlags&lt;RectangleEdge> RectangleEdges;
&lt;/code>

В некоторых случаях, имена "флажков" могут быть в единственном числе. Тогда, имя перечислимого типа сдержит суффикс Flag:

&lt;code>
 enum AlignmentFlag { AlignLeft, AlignTop, … };
 typedef QFlags&lt;AlignmentFlag> Alignment;
&lt;/code>

=== Имена функций и параметров ===
Первое правило для присвоения имен функциям — из названия функции должно быть понятно, имеет она побочные эффекты или нет. В Qt 3, константная функция QString::simplifyWhiteSpace() игнорирует это правило, потому что не модифицирует строку, для которой она вызвана, как можно было бы подумать, исходя из имени, а возвращает QString. В Qt 4 функция была переименована в QString::simplified().

Имена параметров — важный источник информации для программиста, даже если он не смотрит в код, который относится к API. С тех пор, как современные IDE научились показывать их, во время написания кода, есть смысл присваивать имена параметрам в заголовочных файлах и использовать эти же имена в документации.

=== Присваивание имен логическим геттерам, сеттерам и свойствам ===
Особую головную боль доставляет поиск имен, для геттеров и сеттеров bool параметров. Геттер должен быть назван checked() или isChecked()? scrollBarsEnabled() или areScrollBarEnabled()?

В Qt 4 мы используем следующий подход при именовании геттер функций:

''' Прилагательные с префиксом is-. Примеры:
''' isChecked()
'''''' isDown()
'''''' isEmpty()
'''''' isMovingEnabled()
* Но, прилагательные применяемые к множественному числу используются без префикса:
'''''' scrollBarsEnabled(), не areScrollBarsEnabled()
* Глаголы не имеют никакого префикса и не используют третье лицо (-s):
'''''' acceptDrops(), не acceptsDrops()
'''''' allColumnsShowFocus()
* Существительные обычно без префикса:
'''''' autoCompletion(), не isAutoCompletion()
'''''' boundaryChecking()
* Иногда, отсутсвие префикса вводит в заблуждение, поэтому мы используем префикс is-:
'''''' isOpenGLAvailable(), не openGL()
'''''' isDialog(), не dialog()
 (Исходя из имени функции dialog() мы легко можем догадаться, что она возвращает QDialog '''.) 

Имя сеттера можно получить из имени геттера, просто удалив все префиксы и в начало имени поставить "set". Например, setDown() и setScrollBarsEnabled(). Имя свойства будет таким же, как и геттер, только без префикса.

== Как избежать распространенных ошибок ==
=== Невидимая ловушка ===
Популярное заблуждение, что чем меньше кода необходимо для реализации чего-то, тем лучше API. Нужно помнить, что код пишется реже, чем читается и осмысливается. К примеру:

&lt;code>
 QSlider *slider = new QSlider(12, 18, 3, 13, Qt::Vertical,
 0, "volume");
&lt;/code>

намного труднее читается (и даже пишется), чем

&lt;code>
 QSlider '''slider = new QSlider(Qt::Vertical);
 slider->setRange(12, 18);
 slider->setPageStep(3);
 slider->setValue(13);
 slider->setObjectName("volume");
&lt;/code>

=== Ловушка с булевыми параметрами ===
Булевы параметры часто приводят к не читаемому коду. Идея добавить bool параметр в функцию чаще всего является ошибочной. В Qt стандартный пример — функция repaint(), которая может принимать bool в качестве необязательного параметра, который определяет, будет ли стираться задний фон (по-умолчанию) или нет. Поэтому мы можем писать так

&lt;code>
 widget->repaint(false);
&lt;/code>

а новичок такой код может прочитать как "Не перерисовывать!"

Размышления приводят к тому, что bool параметры сохраняют одну функцию, а размер уменьшается. А на самом деле, размер только увеличивается. Как много пользователей Qt честно знают, что делают все эти три строчки?

&lt;code>
 widget->repaint();
 widget->repaint(true);
 widget->repaint(false);
&lt;/code>

На сколько лучше был бы такой вариант
&lt;code>
 widget->repaint();
 widget->repaintWithoutErasing();
&lt;/code>

В Qt 4 мы решили проблему просто удалив возможность перерисовки без стирания виджета. Встроенная поддержка двойной буферизации в Qt 4 ликвидировала необходимость в этой возможности.

Приведем еще пример:

&lt;code>
 widget->setSizePolicy(QSizePolicy::Fixed,
 QSizePolicy::Expanding, true);
 textEdit->insert("Where's Waldo?", true, true, false);
 QRegExp rx("moc_''''''.c??", false, true);
&lt;/code>

Очевидное решение проблемы — заменить bool параметры перечислимыми типами. Это именно то, что мы сделали в Qt 4 с учетом регистра в QString. Сравните:

&lt;code>
 str.replace("USER", user, false); // Qt 3
 str.replace("USER", user, Qt::CaseInsensitive); // Qt 4
&lt;/code>

=== Ловушка копировать/вставить ===

== Примеры ==

=== QProgressBar ===

Чтобы продемонстрировать эти концепции на практике, давайте рассмотрим API QProgressBar в Qt 3 и сравним с Qt 4 API. В Qt3:

&lt;code>
 class QProgressBar : public QWidget
 {
 …
 public:
 int totalSteps() const;
 int progress() const;

const QString &amp;progressString;() const;
 bool percentageVisible() const;
 void setPercentageVisible(bool);

void setCenterIndicator(bool on);
 bool centerIndicator() const;

void setIndicatorFollowsStyle(bool);
 bool indicatorFollowsStyle() const;

public slots:
 void reset();
 virtual void setTotalSteps(int totalSteps);
 virtual void setProgress(int progress);
 void setProgress(int progress, int totalSteps);

protected:
 virtual bool setIndicator(QString &amp;progressStr;,
 int progress,
 int totalSteps);
 …
 };
&lt;/code>

API довольно сложный и не логичный. Например, по именам не совсем понятно, что reset(), setTotalSteps(), and setProgress() связанны между собой.

Для улучшения API нужно было просто заметить сходство QProgressBar и класса QAbstractSpinBox в Qt 4, а так же его наследников, QSpinBox, QSlider и QDial. Какое будет решение? Заменить progress и totalSteps на minimum, maximum и value. Добавить сигнал valueChanged(). Добавить вспомогательную функцию setRange().

Следующее замечание по поводу progressString, проценты и индикатор преследуют один и тот же смысл: текст, который отобрадается на прогресс баре. Очень часто текст — это проценты, но его можно поменять, используя setIndicator(). Вот новое API:

&lt;code>
 virtual QString text() const;
 void setTextVisible(bool visible);
 bool isTextVisible() const;
&lt;/code>

По-умолчанию, текст — индикатор процентов. Но его можно изменить, самостоятельно реализовав text().

В API Qt 3 есть две функции, setCenterIndicator() и setIndicatorFollowsStyle(), которые отвечают за выравнивание. Их легко можно заменить на одну, setAlignment():

&lt;code>
 void setAlignment(Qt::Alignment alignment);
&lt;/code>

Если программист не вызовет функцию setAlignment(), выравнивание будет основываться на стиле. Для стиля Motif, текст будет располагаться посередине. Для других стилей, он будет отображаться с правой стороны.

Посмотрим на улучшенное API QProgressBar:

&lt;code>
 class QProgressBar : public QWidget
 {
 …
 public:
 void setMinimum(int minimum);
 int minimum() const;
 void setMaximum(int maximum);
 int maximum() const;
 void setRange(int minimum, int maximum);
 int value() const;

virtual QString text() const;
 void setTextVisible(bool visible);
 bool isTextVisible() const;
 Qt::Alignment alignment() const;
 void setAlignment(Qt::Alignment alignment);

public slots:
 void reset();
 void setValue(int value);

signals:
 void valueChanged(int value);
 …
 };
&lt;/code>

=== QAbstractPrintDialog &amp; QAbstractPageSizeDialog ===

В Qt 4 появились два класса QAbstractPrintDialog и QAbstractPageSizeDialog, которые служат базовыми классами для QPrintDialog и QPageSizeDialog. Но это глупое решение, потому что в Qt API нигде не используются в качестве аргументов указатели на QAbstractPrint- или -PageSizeDialog и над ними не выполняются никакие операции. Это яркий пример, когда нет никакой необходимости в абстрактных классах.

Но нельзя говорить, что хорошая абстракция — это не правильно. Ведь правда, QPrintDialog может использовать фабрику или другой механизм для его модификации, что подтверждает определение #ifdef QTOPIA_PRINTDIALOG.

=== QAbstractItemModel ===
Детально проблемы модели\представления в Qt 4 хорошо описаны и в других местах, но главный вывод, который можно сделать: "QAbstractFoo" не должен объединять все производные классы, и заострять на нем внимание во время написания кода. Потому что модель "объединить все" для базового класса практически всегда является плохим решением. И QAbstractItemModel совершает эту ошибку. На самом деле он представляет из себя всего лишь QTreeOfTablesModel, но со значительно усложненным API, которое затем еще и ''наследуется производными классами''.

Добавление абстракции автоматически не делает API лучше. 

=== QLayoutIterator &amp; QGLayoutIterator ===
В Qt 3, для создания своего класса размещения, необходимо реализовать классы QLayout и QGLayoutIterator ("G" от слова "generic"). Экземпляр QGLayoutIterator используется классом QLayoutIterator, который пользователи могут использовать, как обычный итератор. С помощью QLayoutIterator можно писать такой код:

&lt;code>
 QLayoutIterator it = layout()->iterator();
 QLayoutItem **child;
 while ((child = it.current()) != 0) {
 if (child->widget() == myWidget) {
 it.takeCurrent();
 return;
 }
 ++it;
 }
&lt;/code>

В Qt 4 мы удалили класс QGLayoutIterator (и другие подобные классы для разный размещений) и вместо него, реализуя свой QLayout нужно реализовать функции itemAt(), takeAt(), и count().

=== QImageSink ===

В Qt 3 был целый набор классов для последовательного чтения изображений и вывода их как анимации — классы QImageSource/Sink/QASyncIO/QASyncImageIO. Т.к. все они были необходимы только для анимации, то мы их просто удалили, а на замену им пришел QLabel.

Мораль сей басни такова, что не стоит добавлять абстракцию на туманное будущее. Лучше сделать проще. Когда настанет это будущее, будет намного проще внедрить новшество в простую систему, чем в сложную.

=== другие Qt3 против Qt4?
=== QWidget::setWindowModified(bool) ===
=== Q3Url vs. QUrl ===
=== Q3TextEdit vs. QTextEdit === ===
Как все эти виртуальные функции умирают.

=== Qt's Clipping Story (naming of clipping fns) ===

When you set the clip rect, you actually set a region (should be setClipRegion(QRect) instead of setClipRect()).

(on the right, how it should have been…)
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="http://wiki.qt.io/Template:Ambox" title="Template:Ambox">Template:Ambox</a> (<a href="http://wiki.qt.io/index.php?title=Template:Ambox&amp;action=edit" title="Template:Ambox">view source</a>) </li><li><a href="http://wiki.qt.io/Template:Cleanup" title="Template:Cleanup">Template:Cleanup</a> (<a href="http://wiki.qt.io/index.php?title=Template:Cleanup&amp;action=edit" title="Template:Cleanup">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="http://wiki.qt.io/API_Design_Principles/ru" title="API Design Principles/ru">API Design Principles/ru</a>.</p>
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/API_Design_Principles/ru">http://wiki.qt.io/API_Design_Principles/ru</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=API+Design+Principles%2Fru" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/API_Design_Principles/ru"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:API_Design_Principles/ru&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="http://wiki.qt.io/API_Design_Principles/ru" >Read</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="http://wiki.qt.io/index.php?title=API_Design_Principles/ru&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=API_Design_Principles/ru&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/API_Design_Principles/ru" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/API_Design_Principles/ru" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=API_Design_Principles/ru&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":387});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=API_Design_Principles/ru&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 10:54:42 GMT -->
</html>
