<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.qt.io/index.php?title=Qt_for_Beginners&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 08:18:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>View source for Qt for Beginners - Qt Wiki</title>
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />
<meta name="generator" content="MediaWiki 1.23.3" />
<meta name="robots" content="noindex,nofollow" />
<link rel="shortcut icon" href="http://wiki.qt.io/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.qt.io/opensearch_desc.php" title="Qt Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.qt.io/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="Qt Wiki Atom feed" href="http://wiki.qt.io/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.vector.styles&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: qtio_wiki:resourceloader:filter:minify-css:7:e91d7bc946738c8892a88ad5616a59ba */</style>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Qt_for_Beginners","wgTitle":"Qt for Beginners","wgCurRevisionId":19505,"wgRevisionId":0,"wgArticleId":1488,"wgIsArticle":false,"wgIsRedirect":false,"wgAction":"edit","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":true,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Qt_for_Beginners","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"preview":true,"previewDialog":false,"publish":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"editfont":"default","editondblclick":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":1,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nickname":"","norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rows":25,"showhiddencats":0,"shownumberswatching":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":1,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,
"useeditwarning":1,"prefershttps":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"wikieditor-preview":1,"wikieditor-publish":1,"language":"en","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs500":false,"searchNs501":false,"searchNs700":false,"searchNs701":false,"variant":"en"});},{},{});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: qtio_wiki:resourceloader:filter:minify-js:7:9743cb8b8019d46de5946bfe6dfa04d7 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Qt_for_Beginners skin-vector action-edit vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">View source for Qt for Beginners</span></h1>
						<div id="bodyContent">
								<div id="contentSub">← <a href="http://wiki.qt.io/Qt_for_Beginners" title="Qt for Beginners">Qt for Beginners</a></div>
												<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-navigation">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text"><p>You do not have permission to edit this page, for the following reason:
</p>
<div class="permissions-errors">
<p>The action you have requested is limited to users in one of the groups: <a href="http://wiki.qt.io/index.php?title=Qt_Wiki:Users&amp;action=edit&amp;redlink=1" class="new" title="Qt Wiki:Users (page does not exist)">Users</a>, KnowledgeBase, QtWS.
</p>
</div>
<hr />
<p>You can view and copy the source of this page:
</p><textarea readonly="" accesskey="," id="wpTextbox1" cols="80" rows="25" style="" lang="en" dir="ltr" name="wpTextbox1">{{LangSwitch}}
[[Category:HowTo]]

'''Warning''' : be sure to have some knowledge in C++ before starting!

'''Remark''' : this tutorial series target mainly Qt4. Even if most of these tutorials are also valid for Qt5, the case of Qt5 is discussed in a separate part.

== C++ reminder ==
The '''signature''' of a method or function is simply it's prototype. It completely describes a method or function. It contains the returned type, the name of the method/function (including the class name) and the parameters, including types.

&lt;code>
Type MyObject::myFunction(
 Type1 param1,
 Type2 *param2,
 const Type3 &amp;param3
);
&lt;/code>

New to Qt? Don't know how to start? Then this wiki page is for you! It is a step by step tutorial that presents all specificities and features of Qt.

== Introduction to Qt ==
Qt (pronounce it as "cute", not "cu-tee") is a cross-platform framework, that is usually used as a graphical toolkit, although it is also very helpful in creating CLI applications. It runs on the three major desktop OSes, as well as on mobile OSes, such as Symbian, Nokia Belle, Meego Harmattan, MeeGo or BB10, and on embedded devices. Ports for Android (Necessitas) and iOS are also in development.

Qt has an impressive collection of modules, including

* '''QtCore''', a base library that provides containers, thread management, event management, and much more
* '''QtGui''' and '''QtWidgets''', a GUI toolkit for Desktop, that provides a lot of graphical components to design applications.
* '''QtNetwork''', that provides an useful set of classes to deal with network communications
* '''QtWebkit''', the webkit engine, that enable the use of web pages and web apps in a Qt application.
* '''QtSQL''', a full featured SQL RDBM abstraction layer extensible with own drivers, support for ODBC, SQLITE, MySQL and PostgreSQL is available out of the box
* '''QtXML''', support for simple XML parsing (SAX) and DOM
* '''QtXmlPatterns''', support for XSLT, XPath, XQuery and Schema validation

== Installing Qt SDK ==

To get start to write Qt applications, you have to get Qt libraries, and, if you want, an IDE. They can be build from source, or better, be downloaded as an SDK from [http://www.qt.io/download/ the download page].

This SDK includes a lot of features, like cross compilers for Symbian and the Nokia N9. You might choose not to install them by selecting "custom install". Be sure to keep these packages

* '''QMake Documentation'''
* '''Qt Documentation'''
* '''Qt 4.8.1 (Destkop)''', assuming that Qt 4.8.1 is the latest version.
* '''Qt Creator'''

These packages can also be useful

* Qt Examples
* Qt Linguist

You can select other packages if you want to develop for Symbian / Maemo / Meego, or with older version of Qt.

'''NB''' : On linux, it is better to use the packages that your distribution provides. Qt Creator should be available in nearly all distributions, and installing it should install all dependancies, like libraries, compilers, and developement headers.

'''''Note:''' See the official [http://doc.qt.io/qt-5/gettingstartedqt.html Getting Started with Qt Widgets] page for an alternative tutorial.''

We are now ready to create our first window. And it will be as usual, a ''hello world''.

== Qt Creator features ==
Before writing our first GUI app, let's discover Qt Creator.

Qt Creator is yet another IDE for C++, but it is very well suited for coding Qt applications. It provides a doc browser and the "designer", which makes creation of windows easier, all wrapped in a well-designed user interface. It's also one of the fastest IDE's available.

== Our first window ==
Let's start by creating our first project. It will be an empty project, so we have to proceed with:
File > New file or project > Other Projects > Empty Qt Project

[[File:Beginners-01-NewProject.jpg|600px]]

Follow the wizard, and after selecting the project folder and name, and select the version of Qt to use, you should land on this page

[[File:Beginners-02-HelloWorldPro.jpg|600px]]

This is the project file (extension .pro). Qt uses a command line tool that parses these project files in order to generate "makefiles", files that are used by compilers to build an application. This tool is called '''qmake'''. But, we shouldn't bother too much about qmake, since Qt Creator will do the job for us.

In a project file, there is some minimal code that should always be written :

&lt;code lang="make">
TEMPLATE = app
TARGET = name_of_the_app

QT = core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
&lt;/code>

* ''TEMPLATE'' describes the type to build. It can be an application, a library, or simply subdirectories.
* ''TARGET'' is the name of the app or the library.
* ''QT'' is used to indicate what libraries (Qt modules) are being used in this project. Since our first app is a small GUI, we will need QtCore and QtGui.

Let's now add the entry point of our application. Using File > New file or project > C++ > C++ Source file should do the job.

[[File:Beginners-03-NewFile.jpg|600px]]

Follow the wizard once again, naming the file "main", and you are done.
You will notice that in the project file, a new line has been added automatically by Qt Creator :

&lt;code lang="make">
TEMPLATE = app
TARGET = name_of_the_app

QT = core gui

SOURCES +=  main.cpp
&lt;/code>

Headers and sources files can be added manually with

&lt;code lang="make">
HEADERS += first_file.h second_file.h
SOURCES += first_file.cpp second_file.cpp
&lt;/code>

or 

&lt;code lang="make">
HEADERS += first_file.h  second_file.h
SOURCES += first_file.cpp  second_file.cpp
&lt;/code>

If you use Qt Creator's wizards, this is done automatically. 

The minimal source code of a Qt application is 

&lt;code>
#include &lt;QApplication>

int main(int argc, char **argv)
{
 QApplication app (argc, argv);
 return app.exec();
}
&lt;/code>

'''QApplication''' is a very important class. It takes care of input arguments, but also a lot of other things, and most notably, the ''event loop''. The event loop is a loop that waits for used input in GUI applications.

When calling &lt;tt>app.exec()&lt;/tt> the event loop is launched. 

Let's compile this application. By clicking on the green arrow on the bottom left, Qt Creator will compile and execute it. And what happened ? The application seems to be launched and not responding. That is actually normal. The event loop is running and waiting for events, like mouse clicks on a GUI, but we did not provide any event to be processed, so it will run indefinitely.

Let's add something to be displayed.

&lt;code>
#include &lt;QApplication>
#include &lt;QPushButton>

int main(int argc, char **argv)
{
 QApplication app (argc, argv);

 QPushButton button ("Hello world !");
 button.show();

 return app.exec();
}
&lt;/code>

Compile it, and … here it is ! Our first window !

[[File:Beginners-04-FirstWindow.jpg|600px]]

== How a Qt program is compiled ==

Qt Creator does the job for us, but it might be interesting to know how Qt programs are compiled.

For small programs, it is easy to compile everything by hand, creating objects files, then linking them. But for bigger projects, the command line easily becomes hard to write. If you are familiar with Linux, you may know that all the programs are compiled using a makefile that describes all these command lines to execute. But for some projects, even writing a makefile can become tedious.

''qmake'' generates those makefiles for you. With a simple syntax, it produces the makefile that is used to compile a Qt program. But that is not its only goal. Qt uses meta-objects to extend C++ functionalities, and qmake is responsible to prepare a makefile that contains this meta-object extraction phase. You will see this in another chapter.

So, Qt apps are compiled in 3 steps
# A ''.pro'' file is written to describe the project to compile
# A makefile is generated using ''qmake''
# The program is build using ''make'' (or ''nmake'' or ''jom'' on windows)

== A pretty button ==
This chapter gives an overview of the widgets modules. It will cover widgets properties, the inheritance scheme that is used in widgets, and also the parenting system.

Now that we have our button, we may want to customize it a bit.

[[File:Beginner-Pretty-Button.jpg]]

Qt objects have a lot of attributes that can be modified using getters and setters. In Qt, if an attribute is called ''foo'', the associated getter and setter will have these signatures

&lt;code>
T foo() const;
void setFoo(const T);
&lt;/code>

In fact, Qt extends this system of attributes and getters and setters to something called ''property''. A property is a value of any type that can be accessed, be modified or constant, and can notify a change. The property system is useful, especially in the third part (QML). For now, we will use "attribute" or "property" to do the same thing.

A QPushButton has plenty of properties :

* text
* font
* tooltip
* icon
* ...

So we can use these to customize the button.

Let's first change the text and add a tooltip
&lt;code>
#include &lt;QApplication>
#include &lt;QPushButton>

int main(int argc, char **argv)
{
 QApplication app (argc, argv);

 QPushButton button;
 button.setText("My text");
 button.setToolTip("A tooltip");
 button.show();

 return app.exec();
}
&lt;/code>

Here is the result:

[[File:Beginner-Test-Widget-Tooltip.jpg]]

We can also change the font. In Qt, a font is represented with the {{DocLink|QFont}} class. The documentation provides a lot of information. We are especially concerned here with one of the constructors of QFont.

&lt;code>
QFont(const QString &amp; family, int pointSize = –1, int weight = -1, bool italic = false)
&lt;/code>

In order to change the font, we have to instantiate a &lt;tt>QFont&lt;/tt> class, and pass it to the &lt;tt>QPushButton&lt;/tt> using &lt;tt>setFont&lt;/tt>. The following snippet will change the font to Courier.

&lt;code>
QFont font ("Courier");
button.setFont(font);
&lt;/code>

You can try other parameters of QFont's constructor to reproduce the button that is represented in the first picture in this chapter.

Setting an icon is not very difficult either. An icon is represented with the {{DocLink|QIcon}} class. And you can create an icon provided that it has an absolute (or relative) path in the filesystem. I recommend providing the absolute path in this example. But for deployment considerations, you might use the relative path, or better, the resource system.

&lt;code>
QIcon icon ("/path/to/my/icon/icon.png");
button.setIcon(icon);
&lt;/code>

On Linux, and some other OS's, there is a convenient way to set an icon from an icon theme. It can be done by using the static method

&lt;code>
QIcon Qicon::fromTheme ( const QString &amp;name, const QIcon &amp;fallback = QIcon());
&lt;/code>

For example, in the screenshot at the beginning of this chapter, the smiley comes from the Oxygen KDE icon theme and was set by

&lt;code>
button.setIcon(QIcon::fromTheme("face-smile"));
&lt;/code>

== Qt class hierarchy ==

Qt widely uses inheritance, especially in the Widgets module. The following graph shows some of these inheritance

[[File:Beginner-Class-Hierarchy.jpg]]

{{DocLink|QObject}} is the most basic class in Qt. Most of classes in Qt inherit from this class. QObject provides some very powerful capabilities like:

* '''object name''' : you can set a name, as a string, to an object and search for objects by names.
* '''parenting system''' (described in the following section)
* '''signals and slots''' (described in the next chapter)
* '''event management'''

Widgets are able to respond to events and use parenting system and signals and slots mechanism. All widgets inherit from QObject. The most basic widget is the {{DocLink|QWidget}}. QWidget contains most properties that are used to describe a window, or a widget, like position and size, mouse cursor, tooltips, etc.

'''Remark''' : in Qt, a widget can also be a window. In the previous section we displayed a button, that is a widget, but it appears directly as a window. There is no need of a "QWindow" class.

Nearly all graphical elements inherit from QWidget. We can list for example

 QAbstractButton, a base class for all button types
   QPushButton
   QCheckBox
   QRadioButton
 QFrame, that displays a frame
 QLabel, that displays text or picture

This inheritance is done in order to facilitate properties management. Shared properties like size are cursors can be used on other graphical components, and {{DocLink|QAbstractButton}} provides basic properties that are shared by all buttons.

== Parenting system ==

Parenting system is a convenient way of dealing with objects in Qt, especially widgets. Any object that inherits from {{DocLink|QObject}} can have a parent and children. This hierarchy tree makes many things convenient:

* When an object is destroyed, all of its children are destroyed as well. So calling ''delete'' becomes optional in certain cases
* All QObjects have ''findChild'' and ''findChildren'' methods that can be used to search for children of a given object.
* Child widgets in a {{DocLink|QWidget}} automatically appear inside the parent widget.

The following snippet that creates a {{DocLink|QPushButton}} inside a QPushButton:

&lt;code>
#include &lt;QApplication>
#include &lt;QPushButton>

int main(int argc, char **argv)
{
 QApplication app (argc, argv);

 QPushButton button1 ("test");
 QPushButton button2 ("other", &amp;button1);

 button1.show();

 return app.exec();
}
&lt;/code>

[[File:Beginner-Test-Widget.jpg]]

You can also note that when the application is closed, &lt;tt>button1&lt;/tt>, which is allocated on the stack, is deallocated. Since &lt;tt>button2&lt;/tt> has &lt;tt>button1&lt;/tt> as a parent, it is deleted also. You can even test this in Qt Creator in the analyze section, by searching for a memory leak &amp;mdash; there won't be any.

There is clearly no benefit in putting a button inside a button, but based on this idea, we might want to put buttons inside a container, that does not display anything. This container is simply the {{DocLink|QWidget}}. 

The following code is used to display a button inside a widget:

&lt;code>
#include &lt;QApplication>
#include &lt;QPushButton>

int main(int argc, char **argv)
{
 QApplication app (argc, argv);

 QWidget window;
 window.setFixedSize(100, 50);

 QPushButton *button = new QPushButton("Hello World", &amp;window);
 button->setGeometry(10, 10, 80, 30);

 window.show();
 return app.exec();
}
&lt;/code>

Note that we create a fixed size widget (that acts as a window) using ''setFixedSize''. This method has the following signature

&lt;code>
void QWidget::setFixedSize(int width, int height);
&lt;/code>

We also positioned the button using ''setGeometry''. This method has the following signature

&lt;code>
void QWidget::setGeometry(int x, int y, int width, int height);
&lt;/code>

== Subclassing QWidget ==
Until now, we have put all of our code in the ''main'' function. This was not a problem for our simple examples, but for more and more complex applications we might want to split our code into different classes. What is often done is to create a class that is used to display a window, and implement all the widgets that are contained in this window as attributes of this class.

Inside Qt Creator, you can automatically create a new class with File > New file or project > C++ > C++ Class

[[File:Beginner-Class-Wizard.jpg]]

Make the class inherit from QWidget, and you should obtain code similar to below

''Header''

&lt;code>
#ifndef WINDOW_H
#define WINDOW_H

#include &lt;QWidget>

class Window : public QWidget
{
 Q_OBJECT
 public:
  explicit Window(QWidget *parent = 0);

 signals:
 public slots:
};

#endif // WINDOW_H
&lt;/code>

''Source''

&lt;code>
#include "window.h"

Window::Window(QWidget *parent) :
 QWidget(parent) {}
&lt;/code>

You can see that Qt Creator automatically generates a class template. Notice that there are some new elements in the header :

* The '''Q_OBJECT''' macro.
* A new category of methods : '''signals'''
* A new category of methods : '''public slots'''

All these elements will be explained in the next chapter, and none of them are needed now.
Implementing the window is done in the constructor. We can declare the size of the window, as well as the widgets that this window contains and their positions. For example, implementing the previous window that contains a button can be done in this way :

''main.cpp''

&lt;code>
#include &lt;QApplication>
#include "window.h"

int main(int argc, char **argv)
{
 QApplication app (argc, argv);

 Window window;
 window.show();

 return app.exec();
}
&lt;/code>

''window.h''

&lt;code>
#ifndef WINDOW_H
#define WINDOW_H

#include &lt;QWidget>

class QPushButton;
class Window : public QWidget
{
 public:
  explicit Window(QWidget *parent = 0);
 private:
 QPushButton *m_button;
};

#endif // WINDOW_H
&lt;/code>

''window.cpp''

&lt;code>
#include "window.h"

#include &lt;QPushButton>

Window::Window(QWidget *parent) :
 QWidget(parent)
 {
 // Set size of the window
 setFixedSize(100, 50);

 // Create and position the button
 m_button = new QPushButton("Hello World", this);
 m_button->setGeometry(10, 10, 80, 30);
}
&lt;/code>

Please note that there is no need for writing a destructor for deleting &lt;code>m_button&lt;/code>. With the parenting system, when the &lt;code>Window&lt;/code> instance is out of the stack, the &lt;code>m_button&lt;/code> is automatically deleted.

== Further Reading ==
A better overview of {{DocLink|QPushButton}} is given in this wiki page [[How to Use QPushButton]]

== The observer pattern ==
Nearly all UI toolkits have a mechanism to detect a user action, and respond to this action. Some of them use ''callbacks'', others use ''listeners'', but basically, all of them are inspired by the [http://en.wikipedia.org/wiki/Observer_pattern observer pattern].

Observer pattern is used when an ''observable'' object wants to notify other ''observers'' objects about a state change. Here are some concrete examples:

* A user has clicked on a button, and a menu should be displayed.
* A web page just finished loading, and a process should extract some information from this loaded page.
* An user is scrolling through a list of items (in an app store for example), and reached the end, so other items should be loaded.

Observer pattern is used everywhere in GUI application, and often lead to some [http://en.wikipedia.org/wiki/Boilerplate_code boilerplate code]. Qt was created with the idea of removing these boilerplate code and providing a nice and clean syntax, and the signal and slots mechanism is the answer.

== Signals and slots ==

Instead of having observable and observers, and registering them, Qt provides two high level concepts: '''signals''' and '''slots'''.

* A '''signal''' is a message that an object can send, most of the time to inform of a status change.
* A '''slot''' is a function that is used to respond to a signal.

Here are some example of signals and slots from our well known {{DocLink|QPushButton}} class.

* &lt;tt>clicked&lt;/tt>
* &lt;tt>pressed&lt;/tt>
* &lt;tt>released&lt;/tt>

As you can see, their names are quite explicit. These signals are sent when the user clicked (pressed then released) , pressed or released the button.

Here are some slots, from different classes

* &lt;tt>QApplication::quit&lt;/tt>
* &lt;tt>QWidget::setEnabled&lt;/tt>
* &lt;tt>QPushButton::setText&lt;/tt>

In order to respond to a signal, a slot must be ''connected'' to a signal. Qt provides the method QObject::'''connect'''. It is used this way, with the two macros '''&lt;tt>SIGNAL&lt;/tt>''' and '''&lt;tt>SLOT&lt;/tt>'''

&lt;code>
FooObjectA *fooA = new FooObjectA();
FooObjectB *fooB = new FooObjectB();

QObject::connect(fooA, SIGNAL (bared()), fooB, SLOT (baz()));
&lt;/code>

assuming that &lt;tt>FooObjectA&lt;/tt> have a &lt;tt>bared&lt;/tt> signal, and &lt;tt>FooObjectB&lt;/tt> have a &lt;tt>baz&lt;/tt> slot.

You have to write the signature of the signal and the slot inside the two macros ''SIGNAL'' and ''SLOT''. If you want to get some information about what these macros do, please read the last section of this chapter.

'''Remark''' : Basically, signals and slots are methods, that might or might not have arguments, but that never return anything. While the notion of a signal as a method is generally quite blur, a slot is actually a real method, and can be called as usual in other methods, or while respoing to a signal.

== Transmitting information ==

The signals and slots mechanism is useful to respond to buttons clicks, but it can do much more than that. For example, It can also be used communicate information. Lets say while playing a song, a progress bar is needed to show how much time remains before the song is over. A media player might have a class that is used to check the progress of the media. An instance of this class might periodically send a ''tick'' signal, with the progress. This signal can be connected to a {{DocLink|QProgressBar}}, that can be used to display the progress.

The hypothetical class used to check the progress might have a signal that have this signature :

&lt;code>
void MediaProgressManager::tick(int miliseconds);
&lt;/code>

and we know from the documentation, that the QProgressBar have this slot

&lt;code>
void QProgressBar::setValue(int value);
&lt;/code>

You can see that the signal and the slot have the same kind of parameters, especially the type. If you connect a signal to a slot that do not share the same kind of parameters, while the connection is done (at run-time) you will get a warning like

&lt;code>
QObject::connect: Incompatible sender/receiver arguments
&lt;/code>

It is because the signal transmits the information to the slot using the parameters. The first parameter of the signal is passed to the first one of the slot, and the same for second, third, and so forth.

The code for the connection will look like this:

&lt;code>
MediaProgressManager *manager = new MediaProgressManager();
QProgressBar *progress = new QProgressBar(window);

QObject::connect(manager, SIGNAL (tick(int)), progress, SLOT (setValue(int)));
&lt;/code>

You can see that you have to provide a signature inside the ''SIGNAL'' and ''SLOT'' macro, providing the type of the value that are passed through the signals. You may not provide the name of the variable if you want. (It is actually even better).

== Features of signals and slots ==
*A signal can be connected to several slots
* Many signals can be connected to a slot
* A signal can be connected to a signal : it is signal relaying. The second signal is send if the first signal is sent.

== Examples ==

=== Responding to an event ===

Remember our button app ? Let's try to actually make something with this app, like be able to close it while clicking on the button. We already know that {{DocLink|QPushButton}} provides the ''clicked'' signal. We also have to know that {{DocLink|QApplication}} provides the ''quit'' slot, that closes the application.

In order to make a click on a button to close the app, we have to connect the signal ''clicked'' of the button to the ''quit'' slot of QApplication instance. We can modify the code from previous chapter to do this, but before, you might wonder how to access to the QApplication instance while you are in another class. Actually, it is pretty simple, since there exists a static function in {{DocLink|QApplication}}, with the following signature, that is used to get it

&lt;code>
QApplication * QApplication::instance()
&lt;/code>

This leads to the following modification of our previous code

''window.cpp''

&lt;code>
#include "window.h"

#include &lt;QPushButton>
#include &lt;QApplication>

Window::Window(QWidget *parent) :
 QWidget(parent)
 {
  // Set size of the window
  setFixedSize(100, 50);

  // Create and position the button
  m_button = new QPushButton("Hello World", this);
  m_button->setGeometry(10, 10, 80, 30);

  // NEW : Do the connection
  connect(m_button, SIGNAL (clicked()), QApplication::instance(), SLOT (quit()));
 }
&lt;/code>

While clicking on the button inside of the window, the application should quit.

== Transmitting information with signals and slots ==
Here is a simpler example for information transmission. It only displays a progress bar and a slider (created by {{DocLink|QSlider}}) inside a window, and while the slider is moved, the value of the progress bar is synced with a very simple connection.

The interesting signals and slots are

&lt;code>
void QSlider::valueChanged(int value);
void QProgressBar::setValue(int value);
&lt;/code>

QSlider automatically emits the signal &lt;tt>valueChanged&lt;/tt> with the new value passed as parameter while the value is changed, and the method &lt;tt>setValue&lt;/tt> of QProgressBar, is used, as we have seen, to set the value of the progress bar.

This leads to the following code

&lt;code>
#include &lt;QApplication>
#include &lt;QProgressBar>
#include &lt;QSlider>

int main(int argc, char **argv)
{
 QApplication app (argc, argv);

 // Create a container window
 QWidget window;
 window.setFixedSize(200, 80);

 // Create a progress bar
 // with the range between 0 and 100, and a starting value of 0
 QProgressBar *progressBar = new QProgressBar(&amp;window);
 progressBar->setRange(0, 100);
 progressBar->setValue(0);
 progressBar->setGeometry(10, 10, 180, 30);

 // Create a horizontal slider
 // with the range between 0 and 100, and a starting value of 0
 QSlider *slider = new QSlider(&amp;window);
 slider->setOrientation(Qt::Horizontal);
 slider->setRange(0, 100);
 slider->setValue(0);
 slider->setGeometry(10, 40, 180, 30);

 window.show();

 // Connection
 // This connection set the value of the progress bar
 // while the slider's value changes
 QObject::connect(slider, SIGNAL (valueChanged(int)), progressBar, SLOT (setValue(int)));

 return app.exec();
}
&lt;/code>

== Technical aspect ==

This section can be skipped for now if you only want to program with Qt. Just know that you need to put '''SIGNAL''' and '''SLOT''' around the signals and slots while calling &lt;tt>connect&lt;/tt>. If you want to know how Qt works, it is better to read this.

== The Meta Object ==

Qt provides a ''meta-object'' system. Meta-object (literally "over the object") is a way to achieve some programming paradigms that are normally impossible to achieve with pure C++ like

* '''Introspection''' : capability of examining a type at run-time
* '''Asynchronous function calls''' 

To use such meta-object capabilites in an application, one can subclass {{DocLink|QObject}} and mark it so that the meta-object compiler (moc), can interpret and translate it.

Code produced by moc includes signals and slots signatures, methods that are used to retrieve meta-information from those marked classes, properties handling... All these information can be accessed using the following method

&lt;code>
const QMetaObject * QObject::metaObject () const
&lt;/code>

{{DocLink|QMetaObject}} class contains all the methods that deals with meta-object.

== Important macros ==

The most important macro is '''Q_OBJECT'''. Signal-Slot connections and their syntax cannot be intepreted by regular C++ compiler. The moc is provided to translate the QT syntax like "connect", "signals", "slots", etc into regular C++ syntax.
This is done by specifying the '''Q_OBJECT''' macro in the header containing class definitions that use such syntax.

''mywidget.h''

&lt;code>
class MyWidget : public QWidget
{
 Q_OBJECT
 public:
  MyWidget(QWidget *parent = 0);
}
&lt;/code>

Others marker macros for moc are

* '''signals'''
* public / protected / private '''slots'''

that mark the different methods that need to be extended.

'''SIGNAL''' and '''SLOT''' are also two very important and useful macros. When a signal is emitted, the meta-object system is used to compare the signature of the signal, to check connection, and to find the slot using it's signature. These macros are actually used to convert the provided method signature into a string that match the one stored in the meta-object.

== Creating custom signals and slots ==
This chapter covers the second part of signals and slots: implementing custom signals and slots.

Creating custom slots and signals is really simple. Slots are like normal methods, but with small decorations around. While signals needs little to no implementation at all.

Creating custom signals and slots is very simple. It is described by the following checklist

* add '''Q_OBJECT''' macro
* add '''signals''' section, and write signals prototypes.
* add '''public slots''' or '''protected slots''' or '''private slots''' sections, and write slots prototypes.
* implement slots as normal methods.
* establish connections.

=== Creating custom slots ===

In order to implement a slot, we first need to make the class be able to send signals and have slots (see previous chapter). This is done by setting the '''Q_OBJECT''' macro in the class declaration (often in the header).

After that, a slot should be declared in the corresponding section, and implemented as a normal method.

Finally, slots are connected to signals.

=== Creating signals ===

As for slots, we first need to add the '''Q_OBJECT''' macro.

Signals should also be declared in the ''signals'' section, and there is no need for them to be implemented.

They are emitted using the '''emit''' keyword :

&lt;code>
emit mySignal();
&lt;/code>

Note that in order to send signals that have parameters, you have to pass them in the signal emission

&lt;code>
emit mySignal(firstParameter, secondParameter …);
&lt;/code>

=== Example ===

==== Creating custom slots ====

Let's start with our window with the button :

''window.h''

&lt;code>
#ifndef WINDOW_H
#define WINDOW_H

#include &lt;QWidget>

class QPushButton;
class Window : public QWidget
{
public:
 explicit Window(QWidget *parent = 0);
private:
 QPushButton *m_button;
};

#endif // WINDOW_H
&lt;/code>

''window.cpp''

&lt;code>
#include "window.h"

#include &lt;QPushButton>

Window::Window(QWidget *parent) :
 QWidget(parent)
{
 // Set size of the window
 setFixedSize(100, 50);

// Create and position the button
 m_button = new QPushButton("Hello World", this);
 m_button->setGeometry(10, 10, 80, 30);
}
&lt;/code>

We might want to remove our previous connection that makes the application quit while clicking on the button. Now, we want that, when clicking on the button, the text is changed. More precisely, we want that the button can be ''checked'', and that, when checked, it displays "checked", and when unchecked, it restores "Hello World".

QPushButton does not implement such a specific slot, so we have to implement it on our own. As stated previously, we have to add the '''Q_OBJECT''' macro.

&lt;code>
class Window : public QWidget
{
 Q_OBJECT
public:
 explicit Window(QWidget *parent = 0);
private:
 QPushButton *m_button;
};
&lt;/code>

We also add our custom slot. Since we are trying to react from the button being checked, and since the corresponding signal is

&lt;code>
void QPushButton::clicked(bool checked)
&lt;/code>

we might implement a slot that has this signature :

&lt;code>
void Window::slotButtonClicked(bool checked);
&lt;/code>

Most of the time, by convention, we implement private and protected slots by prefixing them with "slot". Here, we are not interested in exposing this slot as a public function, we can make it private. The new header is then

''window.h''

&lt;code>
#ifndef WINDOW_H
#define WINDOW_H

#include &lt;QWidget>

class QPushButton;
class Window : public QWidget
{
 Q_OBJECT
public:
 explicit Window(QWidget *parent = 0);
private slots:
 void slotButtonClicked(bool checked);
private:
 QPushButton *m_button;
};

#endif // WINDOW_H
&lt;/code>

The implementation of this slot is

&lt;code>
void Window::slotButtonClicked(bool checked)
{
 if (checked) {
 m_button->setText("Checked");
 } else {
 m_button->setText("Hello World");
 }
}
&lt;/code>

We need to make the button checkable, and establish the connection, we have to add this code in the constructor :

&lt;code>
m_button->setCheckable(true);

connect(m_button, SIGNAL (clicked(bool)), this, SLOT (slotButtonClicked(bool)));
&lt;/code>

The resulting code is then

''window.cpp''

&lt;code>
#include "window.h"

#include &lt;QPushButton>

Window::Window(QWidget *parent) :
 QWidget(parent)
{
 // Set size of the window
 setFixedSize(100, 50);

 // Create and position the button
 m_button = new QPushButton("Hello World", this);
 m_button->setGeometry(10, 10, 80, 30);
 m_button->setCheckable(true);

connect(m_button, SIGNAL (clicked(bool)), this, SLOT (slotButtonClicked(bool)));
}

void Window::slotButtonClicked(bool checked)
{
 if (checked) {
 m_button->setText("Checked");
 } else {
 m_button->setText("Hello World");
 }
}
&lt;/code>

==== Emitting custom signals ====

Based on the previous example, we want to close the application if the button is clicked (checked or unchecked) 10 times. We first need to implement a counter that will count the number of clicks. These modifications implement it

&lt;code>
class Window : public QWidget
{
 Q_OBJECT
public:
 explicit Window(QWidget *parent = 0);
private slots:
 void slotButtonClicked(bool checked);
private:
 int m_counter;
 QPushButton *m_button;
};
&lt;/code>

and

&lt;code>
Window::Window(QWidget *parent) :
 QWidget(parent)
{
 // Set size of the window
 setFixedSize(100, 50);

// Create and position the button
 m_button = new QPushButton("Hello World", this);
 m_button->setGeometry(10, 10, 80, 30);
 m_button->setCheckable(true);

// Set the counter to 0
 m_counter = 0;

connect(m_button, SIGNAL (clicked(bool)), this, SLOT (slotButtonClicked(bool)));
}

void Window::slotButtonClicked(bool checked)
{
 if (checked) {
 m_button->setText("Checked");
 } else {
 m_button->setText("Hello World");
 }

m_counter ++;
}
&lt;/code>

Now, we have to create a custom signal that is used to notify other components, that the counter has reached 10. In order to declare a signal, we have to add a &lt;code>signals&lt;/code> section in the header. We might also declare a signal with the following signature

&lt;code>
void Window::counterReached()
&lt;/code>

The header class is then declared as followed

&lt;code>
class Window : public QWidget
{
 Q_OBJECT
public:
 explicit Window(QWidget *parent = 0);
signals:
 void counterReached();
private slots:
 void slotButtonClicked(bool checked);
private:
 int m_counter;
 QPushButton *m_button;
};
&lt;/code>

Even if the signal is declared as a method, there is no need to implement it. The meta-object compiler is used to do this.

Now we need to emit the signal when the counter reaches 10. It is simply done in the slot

&lt;code>
void Window::slotButtonClicked(bool checked)
{
 if (checked) {
 m_button->setText("Checked");
 } else {
 m_button->setText("Hello World");
 }

m_counter ++;
 if (m_counter == 10) {
 emit counterReached();
 }
}
&lt;/code>

We need to write the keyword '''emit''' to send the signal.

Connecting the newly created signal to the &lt;tt>quit&lt;/tt> slot is done as usual

&lt;code>
connect(this, SIGNAL (counterReached()), QApplication::instance(), SLOT (quit()));
&lt;/code>

The final code is

''window.h''

&lt;code>
#ifndef WINDOW_H
#define WINDOW_H

#include &lt;QWidget>

class QPushButton;
class Window : public QWidget
{
 Q_OBJECT
public:
 explicit Window(QWidget *parent = 0);
signals:
 void counterReached();
private slots:
 void slotButtonClicked(bool checked);
private:
 int m_counter;
 QPushButton *m_button;
};

#endif // WINDOW_H
&lt;/code>

''window.cpp''

&lt;code>
#include "window.h"

#include &lt;QPushButton>
#include &lt;QApplication>

Window::Window(QWidget *parent) :
 QWidget(parent)
{
 // Set size of the window
 setFixedSize(100, 50);

// Create and position the button
 m_button = new QPushButton("Hello World", this);
 m_button->setGeometry(10, 10, 80, 30);
 m_button->setCheckable(true);

// Set the counter to 0
 m_counter = 0;

connect(m_button, SIGNAL (clicked(bool)), this, SLOT (slotButtonClicked(bool)));
 connect(this, SIGNAL (counterReached()), QApplication::instance(), SLOT (quit()));
}

void Window::slotButtonClicked(bool checked)
{
 if (checked) {
 m_button->setText("Checked");
 } else {
 m_button->setText("Hello World");
 }

m_counter ++;
 if (m_counter == 10) {
 emit counterReached();
 }
}
&lt;/code>

And you can try and check that after clicking the button ten times, the application will quit.

== Troubleshooting ==

While compiling your program, especially when you are adding the macro Q_OBJECT, you might have this compilation error.

&lt;code>
main.cpp:(.text._ZN6WindowD2Ev[_ZN6WindowD5Ev]+0x3): undefined reference to `vtable for Window'
&lt;/code>

This is because of the meta-object compiler not being run on a class that should have meta-object. You should '''rerun qmake''', by doing Build > Run qmake.

== Widgets ==
Radio button is a standard GUI component. It is often used to make a unique choice from a list. In Qt, the {{DocLink|QRadioButton}} is used to create radio buttons.

Thanks to a nice heritance, a QRadioButton just behaves like a QPushButton. All properties of the QPushButton are also the same in the QRadioButton, and everything that was learnt in the second chapter can be reused here

* text
* icon
* tooltip
* ...

By default, QRadioButtons are not grouped, so many of them can be checked at the same time. In order to have the "exclusive" behaviour of many radio buttons, we need to use {{DocLink|QButtonGroup}}. This class can be used like this: We allocate a new button group and attach it to the parent object. Note that the parent object might be the mainwindow, or "this"

&lt;code>
QButtonGroup *buttonGroup = new QButtonGroup(object);

// Add buttons in the button group
buttonGroup->addButton(button1);
buttonGroup->addButton(button2);
buttonGroup->addButton(button3);
...
&lt;/code>

What we want is to create a menu picker. In a window, a list of yummy plates should be displayed with radio buttons, and a push button that is used to select the chosen plate should be displayed.

Obviously, nothing will happen (now) when the buttons are clicked.

== Signals and slots ==
Here is an example about signals and slots. We are going to write an application with two buttons. The first button should display information about Qt.

We provide you the following code to complete :

&lt;code>
#include &lt;QApplication>
#include &lt;QPushButton>

int main(int argc, char **argv)
{
 QApplication app (argc, argv);

QWidget window;
 window.setFixedSize(100, 80);

QPushButton *buttonInfo = new QPushButton("Info", &amp;window);
 buttonInfo->setGeometry(10, 10, 80, 30);

QPushButton *buttonQuit = new QPushButton("Quit", &amp;window);
 buttonQuit->setGeometry(10, 40, 80, 30);

window.show();

// Add your code here

return app.exec();
}
&lt;/code>

In order to display the information about Qt, you should use the following method

&lt;code>
void QApplication::aboutQt();
&lt;/code>

You can also add icons on the buttons, or resize them. Obviously, the "Quit" button should be more important, so why not make it bigger?

But we really recommend you to try and figure it out by yourself how to solve these exercises.

== Qt for beginners — Finding information in the documentation ==
Qt documentation is a very valuable piece of information. It is the place to find ''everything'' related to Qt. But, Qt documentation is not a tutorial on how to use Qt. It is a collection of all information related to classes, as well as some examples. The goal of this chapter is to introduce you to the documentation as a basis for programming with Qt.

== Where to find the documentation ==

The best source of documentation is on the internet, in this developer network :

[http://doc.qt.io/ Qt documentation on developer network]

It provides the full doc, as well as some DocNotes, that users can add. These DocNotes give more examples, and highlight some tricky points. The online documentation also has a quite powerful search engine and contains also all the documentation for all versions of Qt.

But it requires an internet connection. Without the internet connection, the doc is still available. If the QtSDK was installed correctly, the documentation that matches the current version of Qt should have been installed, and the ''Help'' section of QtCreator should not be empty. You can also use ''Qt Assistant'', that is a standalone doc browser.

== Important sections of the documentation ==

If you are running the offline documentation viewer, in either Qt Creator, or Qt Assistant, you will find in the summary that there are documentations for different components of the Qt SDK.
* Qt Assistant documentation
* Qt Designer documentation
* Qt Linguist documentation
* QMake documentation
* Qt reference documentation

The most important component is, of course, the Qt reference documentation.

Qt documentation provides a nice introduction of many components, and also the documentation for all the classes in Qt. This list is listed in the page [http://doc.qt.io/qt-4.8/classes.html All classes]. Another interesting page is the page that lists [http://doc.qt.io/qt-4.8/modules.html All modules]. This page provides information about the different components in Qt.

In this tutorial, we will mostly use these modules
* [http://doc.qt.io/qt-4.8/qtcore.html Qt Core]
* [http://doc.qt.io/qt-4.8/qtgui.html Qt GUI]

The search function is also quite important. If you know the class to use, and want to find the documentation, you can either type the name of this class in the search field (online), or in the filter in the index (offline). You can also search for methods and enumerations in these fields.

== Browse the documentation of a class ==

Classes documentation is always organized in the same fashion :
* Name and short description of the class
* Inheritance
* Enumerations
* Properties
* Public methods
* Public slots
* Signals
* Protected methods

Let's take the {{DocLink|QTextEdit}} class as an example.
</textarea><div class="templatesUsed"><div class="mw-templatesUsedExplanation"><p>Templates used on this page:
</p></div><ul>
<li><a href="http://wiki.qt.io/Template:DocLink" title="Template:DocLink">Template:DocLink</a> (<a href="http://wiki.qt.io/index.php?title=Template:DocLink&amp;action=edit" title="Template:DocLink">view source</a>) </li><li><a href="http://wiki.qt.io/Template:LangSwitch" title="Template:LangSwitch">Template:LangSwitch</a> (<a href="http://wiki.qt.io/index.php?title=Template:LangSwitch&amp;action=edit" title="Template:LangSwitch">view source</a>) </li></ul></div><p id="mw-returnto">Return to <a href="http://wiki.qt.io/Qt_for_Beginners" title="Qt for Beginners">Qt for Beginners</a>.</p>
</div>								<div class="printfooter">
				Retrieved from "<a href="http://wiki.qt.io/Qt_for_Beginners">http://wiki.qt.io/Qt_for_Beginners</a>"				</div>
												<div id='catlinks' class='catlinks catlinks-allhidden'></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Personal tools</h3>
	<ul>
<li id="pt-anonuserpage"><a href="http://wiki.qt.io/User:10.0.113.70" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">10.0.113.70</a></li><li id="pt-anontalk"><a href="http://wiki.qt.io/User_talk:10.0.113.70" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li><li id="pt-login"><a href="http://wiki.qt.io/index.php?title=Special:QtLogin&amp;returnto=Qt+for+Beginners" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Sign in</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="http://wiki.qt.io/Qt_for_Beginners"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://wiki.qt.io/index.php?title=Talk:Qt_for_Beginners&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Views</h3>
	<ul>
					<li id="ca-view"><span><a href="http://wiki.qt.io/Qt_for_Beginners" >Read</a></span></li>
					<li id="ca-viewsource" class="selected"><span><a href="http://wiki.qt.io/index.php?title=Qt_for_Beginners&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.qt.io/index.php?title=Qt_for_Beginners&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="http://wiki.qt.io/index.php" id="searchform">
					<div id="simpleSearch">
					<input type="search" name="search" placeholder="Search" title="Search Qt Wiki [f]" accesskey="f" id="searchInput" /><input type="hidden" value="Special:Search" name="title" /><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton" /><input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchButton" class="searchButton" />		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<div id="p-logo" role="banner"><a style="background-image: url(http://wiki.qt.io/skins/common/images/wiki.png);" href="http://wiki.qt.io/Main_Page"  title="Visit the main page"></a></div>
				<div class="portal" role="navigation" id='p-navigation' aria-labelledby='p-navigation-label'>
	<h3 id='p-navigation-label'>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage-description"><a href="http://wiki.qt.io/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
			<li id="n-recentchanges"><a href="http://wiki.qt.io/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="http://wiki.qt.io/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id='p-tb' aria-labelledby='p-tb-label'>
	<h3 id='p-tb-label'>Tools</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.qt.io/Special:WhatLinksHere/Qt_for_Beginners" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.qt.io/Special:RecentChangesLinked/Qt_for_Beginners" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.qt.io/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-info"><a href="http://wiki.qt.io/index.php?title=Qt_for_Beginners&amp;action=info">Page information</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-places">
											<li id="footer-places-terms"><a href='https://developer.qtcloudservices.com/legal/terms'>Käyttöehdot</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="http://wiki.qt.io/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.edit.collapsibleFooter","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","skins.vector.collapsibleNav"],null,true);
}</script>
<script src="http://wiki.qt.io/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54043535-2', 'auto');
  ga('send', 'pageview');

</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":329});
}</script>
	</body>

<!-- Mirrored from wiki.qt.io/index.php?title=Qt_for_Beginners&action=edit by HTTrack Website Copier/3.x [XR&CO'2013], Thu, 05 Nov 2015 08:18:50 GMT -->
</html>
